[{"path":"control/Comtrol.Compass.d.ts","content":"import Control, { ControlOptionsType } from './Control';\nimport Map from '../map/Map';\ndeclare class Compass extends Control {\n    _compass: HTMLDivElement;\n    _bearing: number;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLDivElement;\n    onAdd(): void;\n    _getCompass(): HTMLElement;\n    _registerDomEvents(): void;\n    _rotateCompass(): void;\n    onRemove(): void;\n    _resetView(): void;\n}\nexport default Compass;\nexport type CompassOptionsType = {} & ControlOptionsType;\n"},{"path":"control/Control.Attribution.d.ts","content":"import Control, { ControlOptionsType } from './Control';\n/**\n * @classdesc\n * A control to allows to display attribution content in a small text box on the map.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var map = new maptalks.Map('map', {\n *    center: [-0.113049, 51.498568],\n *    zoom: 14,\n *    attribution: {\n *       content : 'my attribution',\n *       position : 'bottom-left'\n *    },\n *    baseLayer: new maptalks.TileLayer('base', {\n *        urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n *        subdomains: ['a','b','c','d'],\n *        attribution: '&copy; <a href=\"http://osm.org\">OpenStreetMap</a> contributors, &copy; <a href=\"https://carto.com/\">CARTO</a>'\n *    })\n * });\n * map.addLayer(new maptalks.TileLayer('base', {\n *      urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n *      subdomains: ['a','b','c','d'],\n *      attribution: '&copy; <a href=\"http://osm.org\">OpenStreetMap</a> contributors, &copy; <a href=\"https://carto.com/\">CARTO</a>'\n * }));\n */\ndeclare class Attribution extends Control {\n    _attributionContainer: HTMLDivElement;\n    buildOn(): HTMLDivElement;\n    onAdd(): void;\n    onRemove(): void;\n    _update(): void;\n}\nexport default Attribution;\nexport type AttributionOptionsType = {\n    content?: string;\n} & ControlOptionsType;\n"},{"path":"control/Control.Compass.d.ts","content":"import Control, { ControlOptionsType, PositionType } from './Control';\nimport Map from '../map/Map';\ndeclare class Compass extends Control {\n    _compass: HTMLDivElement;\n    _bearing: number;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLDivElement;\n    onAdd(): void;\n    _getCompass(): HTMLElement;\n    _registerDomEvents(): void;\n    _rotateCompass(): void;\n    onRemove(): void;\n    _resetView(): void;\n}\nexport default Compass;\nexport type CompassOptionsType = {\n    position: string | PositionType;\n} & ControlOptionsType;\n"},{"path":"control/Control.d.ts","content":"import Class from '../core/Class';\nimport Point from '../geo/Point';\nimport Map from '../map/Map';\ndeclare const Control_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Class;\n/**\n * Base class for all the map controls, you can extend it to build your own customized Control.\n * It is abstract and not intended to be instantiated.\n * @category control\n * @memberOf control\n * @abstract\n * @extends Class\n * @mixes Eventable\n */\ndeclare abstract class Control extends Control_base {\n    _map: Map;\n    __ctrlContainer: HTMLElement;\n    _controlDom: HTMLElement;\n    options: ControlOptionsType;\n    static positions: {\n        [key: string]: PositionType;\n    };\n    /**\n     * Methods needs to implement:  <br>\n     *  <br>\n     * 1. Method to create UI's Dom element  <br>\n     * function buildOn : HTMLElement  <br>\n     *  <br>\n     * 2. Optional, a callback when the control is added.  <br>\n     * function onAdd : void  <br>\n     * 3. Optional, a callback when the control is removed.  <br>\n     * function onRemove : void  <br>\n     *  <br>\n     * @param  {Object} [options=null] configuration options\n     */\n    constructor(options: ControlOptionsType);\n    onAdd(): void;\n    onRemove(): void;\n    abstract buildOn(map?: Map): HTMLElement;\n    /**\n     * Adds the control to a map.\n     * @param {Map} map\n     * @returns {control.Control} this\n     * @fires control.Control#add\n     */\n    addTo(map: Map): this;\n    /**\n     * update control container\n     * @return {control.Control} this\n     */\n    update(): this;\n    /**\n     * Get the map that the control is added to.\n     * @return {Map}\n     */\n    getMap(): Map;\n    /**\n     * Get the position of the control\n     * @return {Object}\n     */\n    getPosition(): PositionType;\n    /**\n     * update the control's position\n     * @param {String|Object} position - can be one of 'top-left', 'top-right', 'bottom-left', 'bottom-right' or a position object like {'top': 40,'left': 60}\n     * @return {control.Control} this\n     * @fires control.Control#positionchange\n     */\n    setPosition(position: ControlPositionType): this;\n    /**\n     * Get the container point of the control.\n     * @return {Point}\n     */\n    getContainerPoint(): Point;\n    /**\n     * Get the control's container.\n     * Container is a div element wrapping the control's dom and decides the control's position and display.\n     * @return {HTMLElement}\n     */\n    getContainer(): HTMLElement;\n    /**\n     * Get html dom element of the control\n     * @return {HTMLElement}\n     */\n    getDOM(): HTMLElement;\n    /**\n     * Show\n     * @return {control.Control} this\n     */\n    show(): this;\n    /**\n     * Hide\n     * @return {control.Control} this\n     */\n    hide(): this;\n    /**\n     * Whether the control is visible\n     * @return {Boolean}\n     */\n    isVisible(): boolean;\n    /**\n     * Remove itself from the map\n     * @return {control.Control} this\n     * @fires control.Control#remove\n     */\n    remove(): this;\n    _parse(position: ControlPositionType): PositionType;\n    _updatePosition(): void;\n}\nexport type PositionType = {\n    top?: number | string;\n    bottom?: number | string;\n    left?: number | string;\n    right?: number | string;\n};\nexport type ControlPositionType = string | PositionType;\nexport type ControlOptionsType = {\n    position?: ControlPositionType;\n};\ndeclare module \"./../map/Map\" {\n    interface Map {\n        addControl(control: Control): this;\n        removeControl(control: Control): this;\n    }\n}\nexport default Control;\n"},{"path":"control/Control.LayerSwitcher.d.ts","content":"import type { Layer } from '../layer';\nimport Map from '../map/Map';\nimport Control, { ControlOptionsType } from './Control';\n/**\n * @classdesc\n * A LayerSwitcher control for the map.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var LayerSwitcher = new LayerSwitcher({\n *     position : {'top': '0', 'right': '0'}\n * }).addTo(map);\n*/\ndeclare class LayerSwitcher extends Control {\n    container: HTMLDivElement;\n    panel: HTMLDivElement;\n    button: HTMLButtonElement;\n    /**\n     * method to build DOM of the control\n     * @return {HTMLDOMElement}\n     */\n    buildOn(): HTMLDivElement;\n    onAdd(): void;\n    onRemove(): void;\n    _show(): void;\n    _hide(e: any): void;\n    _createPanel(): void;\n    _renderLayers(map: Map, elm: HTMLElement): void;\n    _isExcluded(layer: Layer): boolean;\n    _renderLayer(layer: any, isBase?: boolean, parentChecked?: boolean): HTMLElement;\n}\nexport default LayerSwitcher;\nexport type LayerSwitcherOptionsType = {\n    baseTitle?: string;\n    overlayTitle?: string;\n    containerClass?: string;\n    excludeLayers?: Array<string>;\n} & ControlOptionsType;\n"},{"path":"control/Control.Nav.d.ts","content":"import Control, { ControlOptionsType, PositionType } from './Control';\nexport default class Nav extends Control {\n    buildOn(): any;\n}\nexport type NavOptionsType = {\n    position: string | PositionType;\n} & ControlOptionsType;\n"},{"path":"control/Control.Overview.d.ts","content":"import Polygon from '../geometry/Polygon';\nimport Map from '../map/Map';\nimport Control, { ControlOptionsType } from './Control';\n/**\n * @classdesc\n * An overview control for the map.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var overview = new Overview({\n *     position: {'bottom': '0', 'right': '0'},\n *     size: [300, 200]\n * }).addTo(map);\n */\ndeclare class Overview extends Control {\n    mapContainer: HTMLDivElement;\n    button: HTMLDivElement;\n    _overview: Map;\n    _perspective: Polygon;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(): HTMLElement;\n    onAdd(): void;\n    onRemove(): void;\n    /**\n     * Maximize overview control\n     * @returns {control.Overview}\n     */\n    maxmize(): this;\n    /**\n     * Minimize overview control\n     * @returns {control.Overview}\n     */\n    minimize(): this;\n    /**\n     * Return overview's map object\n     * @returns {Map}\n     */\n    getOverviewMap(): Map;\n    _onButtonClick(): void;\n    _updateButtonText(): void;\n    _createOverview(): void;\n    _getOverviewZoom(): number;\n    _onDragEnd(): void;\n    _getPerspectiveCoords(): import(\"src/geo/Coordinate\").default[];\n    _update(): void;\n    _updateSpatialReference(): void;\n    _updateBaseLayer(): void;\n}\nexport default Overview;\nexport type OverviewOptionsType = {\n    level?: number;\n    size?: Array<number>;\n    maximize?: boolean;\n    symbol?: {\n        'lineWidth': number;\n        'lineColor': string;\n        'polygonFill': string;\n        'polygonOpacity': number;\n    };\n    containerClass?: string;\n    buttonClass?: string;\n} & ControlOptionsType;\n"},{"path":"control/Control.Panel.d.ts","content":"import { Point } from '../geo';\nimport DragHandler from '../handler/Drag';\nimport Control, { ControlOptionsType, PositionType } from './Control';\n/**\n * @classdesc\n * Class for panel controls.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var panel = new Panel({\n *     position : {'bottom': '0', 'right': '0'},\n *     draggable : true,\n *     custom : false,\n *     content : '<div class=\"map-panel\">hello </div>',\n *     closeButton : true\n * }).addTo(map);\n */\ndeclare class Panel extends Control {\n    draggable: DragHandler;\n    options: PanelOptionsType;\n    _startPos: Point;\n    _startPosition: PositionType;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(): HTMLDivElement;\n    /**\n     * update control container\n     * @return {control.Panel} this\n     */\n    update(): any;\n    /**\n     * Set the content of the Panel.\n     * @param {String|HTMLElement} content - content of the infowindow.\n     * return {control.Panel} this\n     * @fires Panel#contentchange\n     */\n    setContent(content: string | HTMLElement): this;\n    /**\n     * Get content of  the infowindow.\n     * @return {String|HTMLElement} - content of the infowindow\n     */\n    getContent(): string | HTMLElement;\n    _cancelOn(domEvent: any): boolean;\n    _onDragStart(param: any): void;\n    _onDragging(param: any): void;\n    _onDragEnd(param: any): void;\n    /**\n     * Get the connect points of panel for connector lines.\n     * @private\n     */\n    _getConnectPoints(): import(\"src/geo/Coordinate\").default[];\n}\nexport default Panel;\nexport type PanelOptionsType = {\n    draggable?: boolean;\n    custom?: boolean;\n    content?: string | HTMLElement;\n    closeButton?: boolean;\n} & ControlOptionsType;\n"},{"path":"control/Control.Reset.d.ts","content":"import Control, { ControlOptionsType } from './Control';\nimport { MapViewType } from '../map/Map';\ndeclare class Reset extends Control {\n    _reset: HTMLDivElement;\n    _view: MapViewType;\n    options: ResetOptionsType;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(): HTMLDivElement;\n    onAdd(): void;\n    setView(view: MapViewType): void;\n    _getReset(): HTMLDivElement;\n    _registerDomEvents(): void;\n    onRemove(): void;\n    _resetView(): void;\n}\nexport default Reset;\nexport type ResetOptionsType = {\n    view?: MapViewType;\n} & ControlOptionsType;\n"},{"path":"control/Control.Scale.d.ts","content":"import Map from '../map/Map';\nimport Control, { ControlOptionsType } from './Control';\ndeclare class Scale extends Control {\n    _scaleContainer: HTMLDivElement;\n    _mScale: HTMLDivElement;\n    _iScale: HTMLDivElement;\n    options: ScaleOptionsType;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLDivElement;\n    onRemove(): void;\n    _addScales(): void;\n    _update(): void;\n    _updateScales(maxMeters: number): void;\n    _updateMetric(maxMeters: number): void;\n    _updateImperial(maxMeters: number): void;\n    _updateScale(scale: HTMLDivElement, text: string, ratio: number): void;\n    _getRoundNum(num: number): number;\n}\nexport default Scale;\nexport type ScaleOptionsType = {\n    maxWidth?: number;\n    metric?: boolean;\n    imperial?: boolean;\n    containerClass?: string;\n} & ControlOptionsType;\n"},{"path":"control/Control.Toolbar.d.ts","content":"import Control, { ControlOptionsType } from './Control';\nimport type { Map } from './../map/Map';\n/**\n * @classdesc\n * A toolbar control of the map.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var toolbar = new Toolbar({\n *     position : 'top-right',\n *     items: [\n *          {\n *            item: 'item1',\n *            click: function () {\n *              alert('item1 clicked');\n *            }\n *          },\n *          {\n *            item: 'item2',\n *            click: function () {\n *              alert('item2 clicked');\n *            }\n *          }\n *      ]\n * }).addTo(map);\n */\ndeclare class Toolbar extends Control {\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLElement;\n    _createDropMenu(index: number): HTMLElement;\n    _getItems(): any;\n}\nexport default Toolbar;\nexport type ToolBarItem = {\n    item: string;\n    click: () => void;\n};\nexport type ToolbarOptionsType = {\n    height?: number;\n    vertical?: boolean;\n    reverseMenu?: boolean;\n    items: Array<ToolBarItem>;\n} & ControlOptionsType;\n"},{"path":"control/Control.Zoom.d.ts","content":"import Map from '../map/Map';\nimport Control, { ControlOptionsType } from './Control';\n/**\n * @classdesc\n * A zoom control with buttons to zoomin/zoomout and a slider indicator for the zoom level.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var zoomControl = new Zoom({\n *     position : 'top-left',\n *     slider : true,\n *     zoomLevel : false\n * }).addTo(map);\n */\ndeclare class Zoom extends Control {\n    _levelDOM: HTMLSpanElement;\n    _zoomInButton: HTMLLinkElement;\n    _zoomOutButton: HTMLLinkElement;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLElement;\n    onRemove(): void;\n    _update(): void;\n    _updateText(): void;\n    _registerDomEvents(): void;\n    _onZoomInClick(e: any): void;\n    _onZoomOutClick(e: any): void;\n}\nexport default Zoom;\nexport type ZoomOptionsType = {\n    zoomLevel?: boolean;\n    seamless?: boolean;\n} & ControlOptionsType;\n"},{"path":"control/index.d.ts","content":"import Control from './Control';\nimport Attribution from './Control.Attribution';\nimport Compass from './Control.Compass';\nimport LayerSwitcher from './Control.LayerSwitcher';\nimport Overview from './Control.Overview';\nimport Panel from './Control.Panel';\nimport Reset from './Control.Reset';\nimport Scale from './Control.Scale';\nimport Toolbar from './Control.Toolbar';\nimport Zoom from './Control.Zoom';\nexport { Control, Attribution, Compass, LayerSwitcher, Overview, Panel, Reset, Scale, Toolbar, Zoom };\n"},{"path":"core/Ajax.d.ts","content":"export type AjaxGetOption = {\n    headers: any;\n    responseType: any;\n    credentials: any;\n};\nexport type Callback = (...params: any[]) => any;\n/**\n * @classdesc\n * Ajax Utilities. It is static and should not be initiated.\n * @class\n * @static\n * @category core\n */\ndeclare const Ajax: {\n    /**\n     * Get JSON data by jsonp\n     * from https://gist.github.com/gf3/132080/110d1b68d7328d7bfe7e36617f7df85679a08968\n     * @param url - resource url\n     * @param callback  - callback function when completed\n     */\n    jsonp: (url: string, callback: Callback) => any;\n    /**\n     * Fetch remote resource by HTTP \"GET\" method\n     * @param  {String}   url - resource url\n     * @param  {Object}   [options=null] - request options\n     * @param  {Object}   [options.headers=null] - HTTP headers\n     * @param  {String}   [options.responseType=null] - responseType\n     * @param  {String}   [options.credentials=null]  - if with credentials, set it to \"include\"\n     * @param  {Function} cb  - callback function when completed\n     * @return {Ajax}  Ajax\n     * @example\n     * maptalks.Ajax.get(\n     *     'url/to/resource',\n     *     (err, data) => {\n     *         if (err) {\n     *             throw new Error(err);\n     *         }\n     *         // do things with data\n     *     }\n     * );\n     */\n    get: (url: string, options?: any, cb?: any) => any;\n    /**\n     * Fetch remote resource by HTTP \"POST\" method\n     * @param  {String}   url - resource url\n     * @param  {Object}   options - request options\n     * @param  {String|Object}  options.postData - post data\n     * @param  {Object}   [options.headers=null]  - HTTP headers\n     * @param  {Function} cb  - callback function when completed\n     * @return {Ajax}  Ajax\n     * @example\n     * maptalks.Ajax.post(\n     *   'url/to/post',\n     *   {\n     *     postData : {\n     *       'param0' : 'val0',\n     *       'param1' : 1\n     *     }\n     *   },\n     *   (err, data) => {\n     *     if (err) {\n     *       throw new Error(err);\n     *     }\n     *     // do things with data\n     *   }\n     * );\n     */\n    post: (url: string, options?: any, cb?: Callback) => any;\n    _wrapCallback: (client: any, cb: Callback) => () => void;\n    _getClient: (cb: Callback) => any;\n    /**\n     * Fetch resource as arraybuffer.\n     * @param {String} url    - url\n     * @param {Object} [options=null] - options, same as Ajax.get\n     * @param {Function} cb   - callback function when completed.\n     * @example\n     * maptalks.Ajax.getArrayBuffer(\n     *     'url/to/resource.bin',\n     *     (err, data) => {\n     *         if (err) {\n     *             throw new Error(err);\n     *         }\n     *         // data is a binary array\n     *     }\n     * );\n     */\n    getArrayBuffer(url: string, options: any, cb: Callback): any;\n    getImage(img: any, url: string, options: any): any;\n    getJSON: (url: string, options?: any, cb?: Callback) => any;\n};\nexport default Ajax;\n"},{"path":"core/Animation.d.ts","content":"export type Callback = (...params: any[]) => any;\n/**\n * @classdesc\n * Easing functions for anmation, from openlayers 3\n * @class\n * @category animation\n * @memberof animation\n * @protected\n */\ndeclare const Easing: {\n    outExpo(x: number): number;\n    outQuint(x: number): number;\n    /**\n     * Start slow and speed up.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    in(t: number): number;\n    /**\n     * Start fast and slow down.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    out(t: number): number;\n    /**\n     * Start slow, speed up, and then slow down again.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    inAndOut(t: number): number;\n    /**\n     * Maintain a constant speed over time.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    linear(t: number): number;\n    /**\n     * Start slow, speed up, and at the very end slow down again.  This has the\n     * same general behavior as {@link inAndOut}, but the final slowdown\n     * is delayed.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    upAndDown(t: number): number;\n};\n/**\n * Animation Frame used internally in animation player.\n * @category animation\n * @memberof animation\n * @protected\n */\ndeclare class Frame {\n    state: any;\n    styles: any;\n    /**\n     * Create an animation frame.\n     * @param {Object} state  - animation state\n     * @param {Object} styles - styles to animate\n     */\n    constructor(state: any, styles: any);\n    get playState(): any;\n    get symbol(): any;\n}\n/**\n * An [Web Animation API]{@link https://developer.mozilla.org/zh-CN/docs/Web/API/Animation} style animation player\n * @category animation\n * @memberof animation\n */\ndeclare class Player {\n    _animation: Callback;\n    options: AnimationOptionsPrivateType;\n    _onFrame: (frame: Frame) => void;\n    playState: string;\n    ready: boolean;\n    finished: boolean;\n    target: any;\n    duration: number;\n    _framer: (cb: Callback) => void;\n    currentTime: number;\n    startTime: number;\n    _playStartTime: number;\n    /**\n     * Create an animation player\n     * @param {Function} animation - animation [framing]{@link framing} function\n     * @param {Object} options     - animation options\n     * @param {Function} onFrame  - callback function for animation steps\n     */\n    constructor(animation: Callback, options: object, onFrame: Callback, target: object);\n    _prepare(): void;\n    /**\n     * Start or resume the animation\n     * @return {Player} this\n     */\n    play(): this;\n    /**\n     * Pause the animation\n     * @return {Player} this\n     */\n    pause(): this;\n    /**\n     * Cancel the animation play and ready to play again\n     * @return {Player} this\n     */\n    cancel(): this;\n    /**\n     * Finish the animation play, and can't be played any more.\n     * @return {Player} this\n     */\n    finish(): this;\n    reverse(): void;\n    _run(): void;\n}\n/**\n * @classdesc\n * Utilities for animation\n * @class\n * @category animation\n * @memberof animation\n */\ndeclare const Animation: {\n    /**\n     * @property {Object} speed         - predefined animation speed\n     * @property {Number} speed.slow    - 2000ms\n     * @property {Number} speed.normal  - 1000ms\n     * @property {Number} speed.fast    - 500ms\n     */\n    speed: {\n        slow: number;\n        normal: number;\n        fast: number;\n    };\n    /**\n     * resolve styles for animation, get a style group of start style, styles to animate and end styles.\n     * @param  {Object} styles - styles to resolve\n     * @return {Object[]}  styles resolved\n     * @private\n     */\n    _resolveStyles(styles: any): {}[];\n    /**\n     * Generate a framing function\n     * @param  {Object[]} styles        - animation style group\n     * @param  {Object} [options=null]  - options\n     * @param  {Object} [options.easing=null]  - animation easing\n     * @return {Function} framing function helps to generate animation frames.\n     */\n    framing(styles: any[], options?: any): (elapsed: number, duration: number) => Frame;\n    _requestAnimFrame(fn: Callback): void;\n    _a(): void;\n    _run(): void;\n    /**\n     * Create an animation player\n     * @param  {Object} styles  - styles to animate\n     * @param  {Object} options - animation options\n     * @param  {Function} step  - callback function for animation steps\n     * @return {Player} player\n     */\n    animate(styles: any, options: any, step: Callback, target: any): Player;\n    _frameFn: () => void;\n};\ndeclare const animate: (styles: any, options: any, step: Callback, target: any) => Player;\nexport { Animation, Easing, Player, Frame, animate };\nexport type EasingType = 'outExpo' | 'outQuint' | 'in' | 'out' | 'inAndOut' | 'linear' | 'upAndDown';\nexport type AnimationOptionsType = {\n    duration?: number;\n    easing?: EasingType;\n    repeat?: boolean;\n};\ntype AnimationOptionsPrivateType = {\n    speed?: number;\n    framer?: () => void;\n    startTime?: number;\n} & AnimationOptionsType;\n"},{"path":"core/Browser.d.ts","content":"declare let Browser: any;\nexport default Browser;\n"},{"path":"core/Canvas.d.ts","content":"import Extent from '../geo/Extent';\nimport Size from '../geo/Size';\nexport type Ctx = CanvasRenderingContext2D;\ndeclare const Canvas: {\n    getCanvas2DContext(canvas: HTMLCanvasElement): CanvasRenderingContext2D;\n    setHitTesting(testing: boolean): void;\n    createCanvas(width: number, height: number, canvasClass?: any): any;\n    prepareCanvasFont(ctx: Ctx, style: any): void;\n    /**\n     * Set canvas's fill and stroke style\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Object} style\n     * @param {Object} resources\n     * @param {Boolean} testing  - paint for testing, ignore stroke and fill patterns\n     */\n    prepareCanvas(ctx: Ctx, style: any, resources: any, testing?: boolean): void;\n    _createGradient(ctx: Ctx, g: any, extent: Extent): any;\n    _setStrokePattern(ctx: Ctx, strokePattern: string, strokeWidth: number, linePatternOffset: number, resources: any): void;\n    clearRect(ctx: Ctx, x1: number, y1: number, x2: number, y2: number): void;\n    fillCanvas(ctx: Ctx, fillOpacity: number, x?: number, y?: number): void;\n    getRgba(color: any, op: number): any;\n    normalizeColorToRGBA(fill: number[], opacity?: number): string;\n    image(ctx: Ctx, img: CanvasImageSource, x: number, y: number, width?: number, height?: number): void;\n    text(ctx: Ctx, text: any, pt: any, style: any, textDesc: any): import(\"./util/bbox\").BBOX;\n    _textOnMultiRow(ctx: Ctx, texts: any[], style: any, point: any, splitTextSize: Size, textSize: Size): import(\"./util/bbox\").BBOX;\n    _textOnLine(ctx: Ctx, text: any, pt: any, textHaloRadius: number, textHaloFill: any, textHaloAlpha: number): void;\n    fillText(ctx: any, text: any, pt: any, rgba?: any): void;\n    _stroke(ctx: any, strokeOpacity: any, x?: any, y?: any): void;\n    _path(ctx: any, points: any, lineDashArray?: any, lineOpacity?: any, ignoreStrokePattern?: any): void;\n    path(ctx: any, points: any, lineOpacity: any, fillOpacity?: any, lineDashArray?: any): void;\n    _multiClip(ctx: any, points: any): void;\n    polygon(ctx: any, points: any, lineOpacity: any, fillOpacity: any, lineDashArray?: any, smoothness?: any): void;\n    _ring(ctx: any, ring: any, lineDashArray: any, lineOpacity: any, ignorePattern?: any): void;\n    paintSmoothLine(ctx: any, points: any, lineOpacity: any, smoothValue: any, close: any, tailIdx?: any, tailRatio?: any): void;\n    /**\n     * draw an arc from p1 to p2 with degree of (p1, center) and (p2, center)\n     * @param  {Context} ctx    canvas context\n     * @param  {Point} p1      point 1\n     * @param  {Point} p2      point 2\n     * @param  {Number} degree arc degree between p1 and p2\n     */\n    _arcBetween(ctx: CanvasRenderingContext2D, p1: any, p2: any, degree: any): any[];\n    _lineTo(ctx: CanvasRenderingContext2D, p: any): void;\n    bezierCurveAndFill(ctx: CanvasRenderingContext2D, points: any, lineOpacity: any, fillOpacity: any): void;\n    _bezierCurveTo(ctx: CanvasRenderingContext2D, p1: any, p2: any, p3: any): void;\n    ellipse(ctx: CanvasRenderingContext2D, pt: any, width: any, heightTop: any, heightBottom: any, lineOpacity: any, fillOpacity: any): void;\n    rectangle(ctx: CanvasRenderingContext2D, pt: any, size: any, lineOpacity: any, fillOpacity: any): void;\n    sector(ctx: CanvasRenderingContext2D, pt: any, size: any, angles: any, lineOpacity: any, fillOpacity: any): void;\n    _isPattern(style: any): boolean;\n    drawCross(ctx: CanvasRenderingContext2D, x: number, y: number, lineWidth: number, color: string | CanvasGradient | CanvasPattern): void;\n    copy(canvas: HTMLCanvasElement, c?: HTMLCanvasElement): HTMLCanvasElement;\n    pixelRect(ctx: CanvasRenderingContext2D, point: number[], lineOpacity: number, fillOpacity: number): void;\n};\nexport default Canvas;\n"},{"path":"core/Class.d.ts","content":"export type ClassOptions = Record<string, any>;\n/**\n *\n * 基类（Class）\n * 该库中所有的类都继承于该基类。\n * 该类提供了定义新类时常用的工具方法，如管理配置options，添加 init hooks 等。\n *\n * @english\n * This library uses ES2015 class system.\n * Class is the root class of class hierachy.\n * It provides utility methods to make it easier to manage configration options, merge mixins and add init hooks.\n *\n * @example\n * const defaultOptions = {\n *     'foo' : 'bar'\n * };\n * class Foo extends maptalks.Class {\n *     constructor(id, options) {\n *         super(options);\n *         this.setId(id);\n *     }\n *\n *     setId(id) {\n *         this.id = id;\n *     }\n *\n *     whenCreated() {\n *         // .....\n *     }\n * }\n *\n * Foo.mergeOptions(defaultOptions);\n *\n * Foo.addInitHook('whenCreated');\n * @category core\n */\ndeclare class Class {\n    _isUpdatingOptions?: boolean;\n    _initHooksCalled?: boolean;\n    _initHooks?: Function[];\n    options?: ClassOptions;\n    /**\n     *\n     * @english\n     * Create an object, set options if given and call all the init hooks.<br />\n     * Options is where the object manages its configuration. Options passed to the object will be merged with parent's instead of overriding it.\n     *\n     * @param options - options to set\n     */\n    constructor(options?: ClassOptions);\n    proxyOptions(): this;\n    /**\n     * 遍历并执行该类或父类用 addInitHook 添加的 init hooks\n     *\n     * @english\n     * Visit and call all the init hooks defined on Class and its parents.\n     */\n    callInitHooks(): this;\n    /**\n     * 设置新的配置 options\n     *\n     * @english\n     * Merges options with the default options of the object.\n     * @param options - options to set\n     */\n    setOptions(options: ClassOptions): this;\n    /**\n     *\n     * 更新options中指定的配置项。\n     * 1. 如果没有提供参数，则返回options配置对象\n     * 2. 如果配置项有对应的handler，handler会被启用或停用，例如draggable\n     *\n     * @english\n     * 1. Return object's options if no parameter is provided. <br/>\n     * 2. update an option and enable/disable the handler if a handler with the same name existed.\n     *\n     * @example\n     * // Get marker's options;\n     * const options = marker.config();\n     * // Set map's option \"draggable\" to false and disable map's draggable handler.\n     * map.config('draggable', false);\n     * // You can update more than one options like this:\n     * map.config({\n     *     'scrollWheelZoom' : false,\n     *     'doubleClickZoom' : false\n     * });\n     * @param conf - config to update\n     * @return\n     */\n    config(conf?: string | ClassOptions, value?: any): ClassOptions | this;\n    /**\n     * options被更新时的回调函数\n     *\n     * @english\n     * Default callback when config is called\n     *\n     * @param conf - updated options\n     */\n    onConfig(conf: ClassOptions): void;\n    _visitInitHooks(proto: any): void;\n    /**\n     * 添加一个初始化钩子（init hook）方法，实例化时会被调用。\n     * 该方法一般用于插件开发，利用初始化钩子，子类无需重载父类的构造函数（constructor），就可以在实例化时执行一些必要的逻辑\n     *\n     * @english\n     * Add an init hook, which will be called when the object is initiated. <br>\n     * It is useful in plugin developing to do things when creating objects without changing class's constructor.\n     * @param fn - a hook function or name of the hook function\n     * @param args - arguments for the init hook function\n     */\n    static addInitHook(fn: Function | string, ...args: any[]): typeof Class;\n    /**\n     * 将一个或多个，sources中定义的方法或属性，mixin到该类的prototype中\n     *\n     * @english\n     * Mixin the specified objects into the class as prototype properties or methods.\n     * @param sources - objects to mixin\n     */\n    static include(...sources: any[]): typeof Class;\n    /**\n     * 用参数中的options定义扩展默认的options\n     *\n     * @english\n     * Mixin options with the class's default options.\n     * @param options - options to merge.\n     */\n    static mergeOptions(options: ClassOptions): typeof Class;\n}\nexport default Class;\n"},{"path":"core/CollisionIndex.d.ts","content":"export type Search = {\n    minX?: number;\n    minY?: number;\n    maxX?: number;\n    maxY?: number;\n};\n/**\n * 碰撞检测的实现思路：\n * 1. 选择 collsionIndex\n *    1.1 如果 collision scope 是 layer，则在layer上创建\n *    1.2 如果 collision scope 是 map, 则直接使用map的collisionIndex\n * 2. painter中查询collisionIndex中是否有命中\n *   2.1 如果有，则从 elements 中删除当前item\n *   2.2 如果没有，如果需要的，insert到collisionIndex中\n */\ndeclare class CollisionIndex {\n    _tree: any;\n    constructor();\n    /**\n     * Test if given box is collided with any other\n     * @param {Number[]} box - [minx, miny, maxx, maxy]\n     * @returns {Boolean}\n     */\n    collides(box: any): any;\n    /**\n     * Insert box in collision index\n     * @param {Number[]} box - [minx, miny, maxx, maxy]\n     * @returns {CollisionIndex} this\n     */\n    insertBox(box: any): this;\n    /**\n     * Bulk insert boxes in collision index\n     * Powered by rbush, it will perform better in subsquent query\n     * @param {Number[][]} boxes - [[minx, miny, maxx, maxy], ...]\n     * @returns {CollisionIndex} this\n     */\n    bulkInsertBox(boxes: any): this;\n    /**\n     * Clear the collision index\n     * @returns {CollisionIndex} this\n     */\n    clear(): this;\n}\nexport default CollisionIndex;\n"},{"path":"core/Constants.d.ts","content":"/**\n * INTERNAL_LAYER_PREFIX The id prefix of internal layers\n * @global\n */\nexport declare const INTERNAL_LAYER_PREFIX = \"_maptalks__internal_layer_\";\nexport declare const GEOMETRY_COLLECTION_TYPES: string[];\nexport declare const GEOJSON_TYPES: string[];\n/**\n * Symbol properties containing external resources\n */\nexport declare const RESOURCE_PROPERTIES: string[];\n/**\n * Corresponding size properties for the above resource properties\n */\nexport declare const RESOURCE_SIZE_PROPERTIES: string[][];\n/**\n * numeric symbol properties\n */\nexport declare const NUMERICAL_PROPERTIES: {\n    lineWidth: number;\n    lineOpacity: number;\n    lineDx: number;\n    lineDy: number;\n    polygonOpacity: number;\n    markerWidth: number;\n    markerHeight: number;\n    markerDx: number;\n    markerDy: number;\n    markerOpacity: number;\n    markerFillOpacity: number;\n    markerLineWidth: number;\n    markerLineOpacity: number;\n    textSize: number;\n    textOpacity: number;\n    textHaloRadius: number;\n    textWrapWidth: number;\n    textLineSpacing: number;\n    textDx: number;\n    textDy: number;\n};\n/**\n *  color symbol properties\n */\nexport declare const COLOR_PROPERTIES: string[];\nexport declare const DEFAULT_TEXT_SIZE = 14;\n"},{"path":"core/Eventable.d.ts","content":"import { MixinConstructor } from './Mixin';\ntype HandlerContext = {\n    handler: HandlerFn;\n    context: any;\n};\nexport type EventRecords = Record<string, HandlerFn>;\nexport type BaseEventParamsType = {\n    type?: string;\n    target?: any;\n    [propName: string]: any;\n};\nexport type HandlerFnResultType = {\n    type: string;\n    target: any;\n    [propName: string]: any;\n};\nexport type HandlerFn = (result?: HandlerFnResultType) => void | boolean;\nexport default function <T extends MixinConstructor>(Base: T): {\n    new (...args: any[]): {\n        _eventMap?: Record<string, HandlerContext[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        /**\n         * 注册事件的监听\n         *\n         * @english\n         * Register a handler function to be called whenever this event is fired.\n         *\n         * @param eventsOn           - event types to register, seperated by space if more than one.\n         * @param handler            - handler function to be called\n         * @param context            - the context of the handler\n         * @example\n         * foo.on('mousedown mousemove mouseup', onMouseEvent, foo);\n         */\n        on(eventsOn: string | EventRecords, handler: HandlerFn, context?: any): this;\n        /**\n         * on方法的alias\n         *\n         * @english\n         * Alias for [on]{@link Eventable.on}\n         *\n         * @param eventTypes     - event types to register, seperated by space if more than one.\n         * @param handler        - handler function to be called\n         * @param context        - the context of the handler\n         */\n        addEventListener(...args: any[]): this;\n        /**\n         * 与on方法作用类似，但监听方法只会执行一次\n         *\n         * @english\n         * Same as on, except the listener will only get fired once and then removed.\n         *\n         * @param eventTypes         - event types to register, seperated by space if more than one.\n         * @param handler            - listener handler\n         * @param context            - the context of the handler\n         * @example\n         * foo.once('mousedown mousemove mouseup', onMouseEvent, foo);\n         */\n        once(eventTypes: string | EventRecords, handler: HandlerFn, context?: any): any;\n        /**\n         *\n         * 取消对事件的监听\n         *\n         * @english\n         * Unregister the event handler for the specified event types.\n         *\n         * @param eventsOff         - event types to unregister, seperated by space if more than one.\n         * @param handler           - listener handler\n         * @param context           - the context of the handler\n         * @example\n         * foo.off('mousedown mousemove mouseup', onMouseEvent, foo);\n         */\n        off(eventsOff: string | EventRecords, handler: HandlerFn, context?: any): any;\n        /**\n         * off方法的别名 alias\n         *\n         * @english\n         * Alias for [off]{@link Eventable.off}\n         *\n         * @param eventTypes       - event types to unregister, seperated by space if more than one.\n         * @param handler          - listener handler\n         * @param context          - the context of the handler\n         */\n        removeEventListener(...args: any[]): any;\n        /**\n         * 是否监听了指定的事件\n         *\n         * @english\n         * Returns listener's count registered for the event type.\n         *\n         * @param eventType       - an event type\n         * @param hanlder         - listener function\n         * @param context         - the context of the handler\n         */\n        listens(eventType: string, handler?: HandlerFn, context?: any): number;\n        /**\n         * 返回所有监听的事件\n         * @english\n         * Get all the listening event types\n         */\n        getListeningEvents(): string[];\n        /**\n         * 把事件监听拷贝给给定的目标对象\n         * @english\n         * Copy all the event listener to the target object\n         * @param target - target object to copy to.\n         */\n        copyEventListeners(target: any): any;\n        /**\n         * 触发一个事件，并执行所有监听该事件的handler方法\n         *\n         * @english\n         * Fire an event, causing all handlers for that event name to run.\n         *\n         * @param  eventType - an event type to fire\n         * @param  param     - parameters for the listener function.\n         */\n        fire(eventType: string, param?: BaseEventParamsType): this;\n        _wrapOnceHandler(evtType: string, handler: HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        /**\n         * 设置一个事件父级对象，用来代替执行所有的事件监听\n         *\n         * @english\n         * Set a event parent to handle all the events\n         * @param parent - event parent\n         * @private\n         */\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: BaseEventParamsType): any;\n    };\n} & T;\nexport {};\n"},{"path":"core/GlobalEvent.d.ts","content":"declare class Base {\n}\ndeclare const GlobalEventable_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"./Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"./Eventable\").EventRecords, handler: import(\"./Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"./Eventable\").EventRecords, handler: import(\"./Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"./Eventable\").EventRecords, handler: import(\"./Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"./Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"./Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"./Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"./Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"./Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Base;\ndeclare class GlobalEventable extends GlobalEventable_base {\n}\nexport declare const GlobalEvent: GlobalEventable;\nexport declare const EVENT_DPR_CHANGE = \"dprchange\";\nexport declare const EVENT_DOC_VISIBILITY_CHANGE = \"docvisibilitychange\";\nexport declare const EVENT_DOC_DRAGSTART = \"dragstart\";\nexport declare const EVENT_DOC_DRAGEND = \"dragend\";\nexport {};\n"},{"path":"core/JSONAble.d.ts","content":"import { MixinConstructor } from \"./Mixin\";\n/**\n * A helper mixin for JSON serialization.\n * @mixin JSONAble\n */\nexport default function <Class extends MixinConstructor>(Base: Class): {\n    new (...args: any[]): {\n        _jsonType?: string;\n        /**\n         * 返回该类的JSON type\n         * @english\n         * Get object's JSON Type\n         */\n        getJSONType(): string;\n    };\n    /**\n     * 静态方法，用于将该类注册用于JSON序列化与反序列化\n     *\n     * @english\n     * It is a static method. <br>\n     * Register class for JSON serialization and assign a JSON type.\n     * @param  type - JSON type\n     */\n    registerJSONType(type: string): void;\n    /**\n     * 静态方法，返回type对应的注册类\n     * @english\n     * It is a static method. <br>\n     * Get class of input JSON type\n     * @param  type - JSON type\n     */\n    getJSONClass(type: string): Class | null;\n} & Class;\n"},{"path":"core/mapbox/index.d.ts","content":"import { loadFunctionTypes, isFunctionDefinition, getFunctionTypeResources, interpolated, hasFunctionDefinition } from '@maptalks/function-type';\n/**\n * @classdesc\n * Utilities from mapbox or implementations of mapbox specifications. It is static and should not be initiated.\n * @class\n * @category core\n * @name MapboxUtil\n */\nexport * from '@maptalks/feature-filter';\nexport { loadFunctionTypes, isFunctionDefinition, getFunctionTypeResources, interpolated, hasFunctionDefinition };\nexport declare function loadGeoSymbol(symbol: any, geo: any): any;\n"},{"path":"core/MicroTask.d.ts","content":"type runFunction = () => any;\ntype TaskCreateItem = runFunction | {\n    count?: number;\n    run: runFunction;\n};\n/**\n *\n * @param {Object|Function} task  - a micro task(Promise)\n * @param {Number} task.count - task run count\n * @param {Function} task.run - task run function\n * @return {Promise}\n * @example\n * const run =()=>{\n * //do some things\n * };\n * runTaskAsync({count:4,run}).then(result=>{})\n * runTaskAsync(run).then(result=>{})\n */\nexport declare function runTaskAsync(task: TaskCreateItem): Promise<any>;\nexport declare function startTasks(): void;\nexport declare function pushLoopHook(func: any): void;\nexport {};\n"},{"path":"core/Mixin.d.ts","content":"export type MixinConstructor = new (...args: any[]) => {};\n"},{"path":"core/ResourceProxy.d.ts","content":"type ProxyItemType = {\n    target: string;\n    [propName: string]: any;\n};\ntype ProxyConfig = {\n    [key: string]: ProxyItemType;\n};\ntype SpriteOptionsType = {\n    imgUrl: string;\n    jsonUrl: string;\n    sourceName?: string;\n};\ntype SVGOptionsType = {\n    url?: string;\n    symbols?: Array<SVGSymbolElement>;\n    sourceName?: string;\n    fill?: string;\n    stroke?: string;\n};\ndeclare function loadSprite(options?: SpriteOptionsType): Promise<unknown>;\ndeclare function loadSvgs(svgs: string | Array<SVGSymbolElement> | SVGOptionsType): Promise<unknown>;\n/**\n * simple Resouce Proxy implementation\n *\n * https://www.webpackjs.com/configuration/dev-server/#devserverproxy\n */\nexport declare const ResourceProxy: {\n    host: string;\n    resources: {\n        [key: string]: any;\n    };\n    proxy: ProxyConfig;\n    origin: ProxyConfig;\n    fromJSON(json: string | object): void;\n    toJSON(): {\n        host: string;\n        proxy: ProxyConfig;\n        origin: ProxyConfig;\n    };\n    getResource(name: string): any;\n    /**\n     * remove resource\n     * @param {String} name\n     */\n    removeResource(name: string): void;\n    /**\n     * add resource\n     * @param {String} name\n     * @param {Object} res\n     */\n    addResource(name: string, res: string | ImageBitmap): void;\n    /**\n    * update  resource (remove and add)\n     * @param {String} name\n     * @param {Object} res\n     */\n    updateResource(name: string, res: string | ImageBitmap): void;\n    /**\n     * get all resource [key,value]\n     * @returns {Object} source\n     */\n    allResource(): {\n        [key: string]: any;\n    };\n    loadSprite: typeof loadSprite;\n    loadSvgs: typeof loadSvgs;\n};\nexport declare function formatResourceUrl(path: string): any;\nexport declare function parseSVG(str: string): any[];\nexport {};\n"},{"path":"core/util/bbox.d.ts","content":"import Coordinate from '../../geo/Coordinate';\nexport type BBOX = [number, number, number, number];\nexport declare function getDefaultBBOX(): BBOX;\nexport declare const BBOX_TEMP: BBOX;\n/**\n * 重置bbox\n *\n * @english\n * reset bbox\n * @param bbox\n */\nexport declare function resetBBOX(bbox: BBOX): void;\n/**\n * cal points bbox:linestring,polygon etc\n *\n * @english\n * cal points bbox:linestring,polygon etc\n * @param points\n * @param out\n * @returns\n */\nexport declare function pointsBBOX(points: Coordinate, out: BBOX): void;\nexport declare function pointsBBOX(points: Coordinate[], out: BBOX): void;\nexport declare function setBBOX(bbox: BBOX, x1?: number | BBOX, y1?: number, x2?: number, y2?: number): void;\nexport declare function validateBBOX(bbox?: BBOX): boolean;\nexport declare function bufferBBOX(bbox: BBOX, bufferSize?: number): void;\n"},{"path":"core/util/common.d.ts","content":"export declare function now(): number;\n/**\n * @classdesc\n * Utilities methods used internally. It is static and should not be initiated.\n * @class\n * @static\n * @category core\n * @name Util\n */\n/**\n * Merges the properties of sources into destination object.\n * @param dest\n * @param source\n * @return\n * @module Util\n */\nexport declare function extend<T extends {}, U>(dest: T, source: U): T & U;\nexport declare function extend<T extends {}, U, V>(dest: T, source1: U, source2: V): T & U & V;\nexport declare function extend<T extends {}, U, V, W>(dest: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport declare function extend<T extends {}, U, V, W, X>(dest: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport declare function extend(dest: object, ...args: Array<any>): any;\n/**\n * Whether the object is null or undefined.\n * @param  obj - object\n * @return\n * @memberOf Util\n */\nexport declare function isNil(obj: Object): obj is null;\n/**\n * Whether val is a number and not a NaN.\n * @param  val - val\n * @return\n * @memberOf Util\n */\nexport declare function isNumber(val: Object): val is number;\n/**\n * Whether a number is an integer\n * @param  n\n * @return\n * @memberOf Util\n */\nexport declare function isInteger(n: number): boolean;\n/**\n * Whether the obj is a javascript object.\n * @param obj  - object\n * @return\n * @memberOf Util\n */\nexport declare function isObject(obj: Object): obj is object;\n/**\n * Check whether the object is a string\n * @param obj\n * @return\n * @memberOf Util\n */\nexport declare function isString(obj: Object): obj is string;\n/**\n * Check whether the object is a function\n * @param {Object} obj\n * @return {Boolean}\n * @memberOf Util\n */\nexport declare function isFunction(obj: Object): obj is Function;\n/**\n * Check whether the object owns the property.\n * @param obj - object\n * @param key - property\n * @return\n * @memberOf Util\n */\nexport declare function hasOwn(obj: Object, key: string): boolean;\n/**\n * Join an array, standard or a typed one.\n * @param  arr       array to join\n * @param  seperator  seperator\n * @return  result string\n * @private\n * @memberOf Util\n */\nexport declare function join(arr: Object[], seperator: string): string;\n/**\n * Determine if an object has any properties.\n * @param object The object to check.\n * @returns The object is empty\n * @memberOf Util\n */\nexport declare function isEmpty(object: Object): boolean;\nexport declare function toRadian(d: number): number;\nexport declare function toDegree(r: number): number;\n"},{"path":"core/util/dom.d.ts","content":"/**\n * DOM utilities used internally.\n * Learned a lot from Leaflet.DomUtil\n * @class\n * @category core\n */\nimport Point from '../../geo/Point';\nimport Size from '../../geo/Size';\n/**\n * Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).\n * @property {String} TRANSFORM\n */\nexport declare const TRANSFORM: string;\n/**\n * Vendor-prefixed tfransform-origin name (e.g. `'webkitTransformOrigin'` for WebKit).\n * @property {String} TRANSFORMORIGIN\n */\nexport declare const TRANSFORMORIGIN: string;\n/**\n * Vendor-prefixed transition name (e.g. `'WebkitTransition'` for WebKit).\n * @property {String} TRANSITION\n */\nexport declare const TRANSITION: string;\n/**\n * Vendor-prefixed filter name (e.g. `'WebkitFilter'` for WebKit).\n * @property {String} FILTER\n */\nexport declare const CSSFILTER: string;\n/**\n * Create a html element.\n * @param tagName\n * @param className\n * @returns\n */\nexport declare function createEl(tagName: string, className?: string): HTMLElement;\n/**\n * Create a html element on the specified container\n * @param tagName\n * @param style - css styles\n * @param container\n * @return\n */\nexport declare function createElOn(tagName: string, style: string, container: HTMLElement): HTMLElement;\n/**\n * Removes a html element.\n * @param node\n */\nexport declare function removeDomNode(node?: HTMLElement): any;\n/**\n * Adds a event listener to the dom element.\n * @param  obj     - dom element to listen on\n * @param  typeArr      - event types, seperated by space\n * @param  handler    - listener function\n * @param  context      - function context\n */\nexport declare function addDomEvent(obj: HTMLElement | Document, typeArr: string, handler: Function, context?: Object): any;\n/**\n * Removes event listener from a dom element\n * @param  obj         - dom element\n * @param  typeArr          - event types, separated by space\n * @param  handler        - listening function\n */\nexport declare function removeDomEvent(obj: HTMLElement | Document, typeArr: string, handler: Function): any;\n/**\n * Check if event type of the dom is listened by the handler\n * @param  obj     - dom element to check\n * @param  typeArr      - event\n * @param  handler    - the listening function\n * @return {Number} - the handler's index in the listener chain, returns -1 if not.\n */\nexport declare function listensDomEvent(obj: HTMLElement | Document, type: string, handler: Function): number;\n/**\n * Prevent default behavior of the browser. <br/>\n * preventDefault Cancels the event if it is cancelable, without stopping further propagation of the event.\n * @param {Event} event - browser event\n */\nexport declare function preventDefault(event: Event): any;\n/**\n * Stop browser event propagation\n * @param   e - browser event.\n */\nexport declare function stopPropagation(e: Event): any;\nexport declare function preventSelection(dom: any): any;\n/**\n * Get the dom element's current position or offset its position by offset\n * @param  dom - HTMLElement\n * @param  offset - position to set.\n * @return  dom element's current position if offset is null.\n */\nexport declare function offsetDom(dom: HTMLElement, offset?: Point): Point;\n/**\n * Compute dom's position\n * @param  dom\n * @return\n */\nexport declare function computeDomPosition(dom: HTMLElement): number[];\n/**\n * Get event's position from the top-left corner of the dom container\n * @param ev    event\n * @return\n */\nexport declare function getEventContainerPoint(ev: MouseEvent, dom: HTMLElement): Point;\n/**\n * set css style to the dom element\n * @param dom dom element\n * @param strCss css text\n */\nexport declare function setStyle(dom: HTMLElement, strCss: string): any;\n/**\n * Whether the dom has the given css class.\n * @param el HTML Element\n * @param name css class\n */\nexport declare function hasClass(el: HTMLElement, name: string): boolean;\n/**\n * add css class to dom element\n * @param el HTML Element\n * @param name css class\n */\nexport declare function addClass(el: HTMLElement, name: string): any;\n/**\n * Set dom's css class\n * @param el HTML Element\n * @param name css class\n */\nexport declare function setClass(el: HTMLElement, name: string): any;\n/**\n * Get dom's css class\n * @param name css class\n * @retrun class字符串\n */\nexport declare function getClass(el: HTMLElement): string;\nexport declare function setOpacity(el: HTMLElement, value: string): any;\n/**\n * Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n * @param el\n * @param offset\n */\nexport declare function setTransform(el: HTMLElement, offset: Point): any;\nexport declare function setTransformMatrix(el: any, m: any): any;\nexport declare function removeTransform(el: any): any;\nexport declare function isHTML(str: string): boolean;\nexport declare function measureDom(parentTag: any, dom: any): Size;\nexport declare function getDomRuler(tag: any): any;\n/**\n * Alias for [addDomEvent]{@link DomUtil.addDomEvent}\n * @param {HTMLElement} obj     - dom element to listen on\n * @param {String} typeArr      - event types, seperated by space\n * @param {Function} handler    - listener function\n * @param {Object} context      - function context\n * @static\n * @function\n * @return {DomUtil}\n */\nexport declare const on: typeof addDomEvent;\n/**\n * Alias for [removeDomEvent]{@link DomUtil.removeDomEvent}\n * @param {HTMLElement} obj         - dom element\n * @param {String} typeArr          - event types, separated by space\n * @param {Function} handler        - listening function\n * @static\n * @function\n * @return {DomUtil}\n */\nexport declare const off: typeof removeDomEvent;\nexport declare function isMoveEvent(type?: string): boolean;\nexport declare const MOUSEMOVE_THROTTLE_TIME = 48;\nexport declare function isMousemoveEventBlocked(target: HTMLElement | any, mousemoveThrottleTime: number): boolean;\n"},{"path":"core/util/draw.d.ts","content":"import { ResourceCache } from '../../renderer/layer/CanvasRenderer';\nexport declare function drawImageMarker(ctx: CanvasRenderingContext2D, image: any, point: any, symbol: any): void;\nexport declare function getImage(resources: ResourceCache, url: string): any;\nexport declare function drawVectorMarker(ctx: CanvasRenderingContext2D, point: any, symbol: any, resources: ResourceCache): HTMLCanvasElement;\ninterface TemplateSymbol {\n    markerLineColor: any;\n    markerLinePatternFile: any;\n    markerLineWidth: any;\n    markerLineOpacity: any;\n    markerLineDasharray: any;\n    markerFill: any;\n    markerFillPatternFile: any;\n    markerFillOpacity: any;\n}\nexport declare function translateMarkerLineAndFill<T extends Partial<TemplateSymbol>>(s: T): {\n    lineColor: any;\n    linePatternFile: any;\n    lineWidth: any;\n    lineOpacity: any;\n    lineDasharray: any;\n    lineCap: string;\n    lineJoin: string;\n    polygonFill: any;\n    polygonPatternFile: any;\n    polygonOpacity: any;\n};\nexport type MarkerType = 'triangle' | 'cross' | 'diamond' | 'square' | 'rectangle' | 'x' | 'bar' | 'pin' | 'pie';\nexport declare function getVectorMarkerPoints(markerType: MarkerType, width: number, height: number): any[];\nexport {};\n"},{"path":"core/util/env.d.ts","content":"/**\n * from detect-node\n * https://github.com/iliakan/detect-node\n *\n * @property {boolean} IS_NODE - whether running in nodejs but not on electron,node-webkit\n * @global\n * @name IS_NODE\n */\nexport declare const IS_NODE: boolean;\nexport declare function getGlobalThis(): typeof globalThis;\n"},{"path":"core/util/gl.d.ts","content":"export declare function createGLContext(canvas: HTMLCanvasElement, options: any): any;\n/**\n* Create a shader object\n* @param gl GL context\n* @param type the type of the shader object to be created\n* @param source shader program (string)\n* @return created shader object, or null if the creation has failed.\n* @private\n*/\nexport declare function compileShader(gl: WebGL2RenderingContext, type: number, source: string): WebGLShader;\n/**\n * Create the linked program object\n * @param gl WebGL2RenderingContext\n * @param vert a vertex shader program (string)\n * @param frag a fragment shader program (string)\n * @return created program object, or null if the creation has failed\n * @private\n */\nexport declare function createProgram(gl: WebGL2RenderingContext | any, vert: string, frag: string): {\n    program: any;\n    vertexShader: WebGLShader;\n    fragmentShader: WebGLShader;\n};\n/**\n * Enable vertex attributes\n * @param gl WebGL2RenderingContext\n * @param attributes [[name, stride, type], [name, stride, type]...]\n * @example\n * rendererr.enableVertexAttrib([\n *  ['a_position', 3, 'FLOAT'],\n *  ['a_normal', 3, 'FLOAT']\n * ]);\n * @private\n */\nexport declare function enableVertexAttrib(gl: WebGL2RenderingContext | any, program: WebGLProgram, attributes: any[]): void;\ndeclare const DEPTH_FUNC_CONSTANTS: {\n    never: number;\n    '<': number;\n    '=': number;\n    '<=': number;\n    '>': number;\n    '!=': number;\n    '>=': number;\n    always: number;\n};\nexport declare function getDepthFunc(v: keyof typeof DEPTH_FUNC_CONSTANTS): number;\nexport {};\n"},{"path":"core/util/index.d.ts","content":"export * from './common';\nexport * from './env';\nexport * from './util';\nexport * from './resource';\nexport * from './style';\nexport * from './strings';\nexport * from './mat4';\n"},{"path":"core/util/LRUCache.d.ts","content":"/**\n * from mapbox-gl-js\n * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)\n * with hash lookup made possible by keeping a list of keys in parallel to\n * an array of dictionary of values\n *\n * @public\n */\nexport declare class ArrayLRUCache {\n    max: number;\n    onRemove: Function;\n    data: any;\n    order: any[];\n    /**\n     * @param max number of permitted values\n     * @param onRemove callback called with items when they expire\n     */\n    constructor(max: number, onRemove: Function);\n    /**\n     * Clear the cache\n     *\n     * @returns this cache\n     */\n    reset(): this;\n    clear(): void;\n    /**\n     * Add a key, value combination to the cache, trimming its size if this pushes\n     * it over max length.\n     *\n     * @param key lookup key for the item\n     * @param data any value\n     * @returns this cache\n     */\n    add(key: string, data: any): this;\n    /**\n     * Determine whether the value attached to `key` is present\n     *\n     * @param key the key to be looked-up\n     * @returns whether the cache has this value\n     */\n    has(key: string): boolean;\n    /**\n     * List all keys in the cache\n     *\n     * @returns an array of keys in this cache.\n     */\n    keys(): string[];\n    /**\n     * Get the value attached to a specific key and remove data from cache.\n     * If the key is not found, returns `null`\n     *\n     * @param key the key to look up\n     * @returns the data, or null if it isn't found\n     */\n    getAndRemove(key: string): any;\n    /**\n     * Get the value attached to a specific key without removing data\n     * from the cache. If the key is not found, returns `null`\n     *\n     * @param key the key to look up\n     * @returns the data, or null if it isn't found\n     */\n    get(key: string): any;\n    /**\n     * Remove a key/value combination from the cache.\n     *\n     * @param key the key for the pair to delete\n     * @returns this cache\n     */\n    remove(key: string): this;\n    /**\n     * Change the max size of the cache.\n     *\n     * @param max the max size of the cache\n     * @returns this cache\n     */\n    setMaxSize(max: number): this;\n}\ndeclare const LRUCache: any;\nexport default LRUCache;\n"},{"path":"core/util/marker.d.ts","content":"import Point from '../../geo/Point';\nimport PointExtent from '../../geo/PointExtent';\nimport { type MarkerType } from './draw';\nimport { ResourceCache } from '../../renderer/layer/CanvasRenderer';\nexport declare const DEFAULT_MARKER_SYMBOLS: {\n    markerWidth: number;\n    markerHeight: number;\n    markerLineWidth: number;\n};\nexport declare function getMarkerRotationExtent(out: PointExtent, rad: number, width: number, height: number, dxdy: Point, alignPoint: Point): PointExtent;\nexport declare function getVectorMarkerFixedExtent(out: PointExtent, symbol: any, size?: [number, number]): PointExtent;\nexport declare function getDefaultHAlign(markerType?: MarkerType): \"right\" | \"middle\";\nexport declare function getDefaultVAlign(markerType?: MarkerType): \"bottom\" | \"middle\" | \"top\";\nexport declare function getVectorMarkerAnchor(symbol: any, w: number, h: number): Point;\nexport declare function calVectorMarkerSize(out: [number, number], symbol: any): [number, number];\nexport declare function getMarkerRotation(symbol: any, prop?: string): number;\nexport declare function getImageMarkerFixedExtent(out: PointExtent, symbol: any, resources?: ResourceCache): PointExtent;\nexport declare function getTextMarkerFixedExtent(out: PointExtent, symbol: any, textDesc: any): PointExtent;\nexport declare function getMarkerFixedExtent(out: PointExtent, symbol: any, resources: ResourceCache, textDesc: any): PointExtent;\nexport declare function isTextSymbol(symbol: any): boolean;\nexport declare function isImageSymbol(symbol: any): boolean;\nexport declare function isVectorSymbol(symbol: any): boolean;\nexport declare function isPathSymbol(symbol: any): boolean;\nexport declare const DYNAMIC_SYMBOL_PROPS: string[];\nexport declare const SIZE_SYMBOL_PROPS: string[];\nexport declare function emptyExtent(extent: PointExtent): void;\n"},{"path":"core/util/mat4.d.ts","content":"export type Matrix4 = [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number];\nexport type Matrix4InOut = Matrix4 | number[];\nexport type Vector3 = [number, number, number];\nexport type Vector4 = [number, number, number, number];\nexport type Vector = Vector3 | Vector4;\nexport declare function perspective(out: Matrix4InOut, fovy: number, aspect: number, near: number, far: number): Matrix4InOut;\nexport declare function translate(out: Matrix4InOut, a: Matrix4InOut, v: Vector): Matrix4InOut;\nexport declare function scale(out: Matrix4InOut, a: Matrix4InOut, v: Vector): Matrix4InOut;\nexport declare function rotateX(out: Matrix4InOut, a: Matrix4InOut, rad: number): Matrix4InOut;\nexport declare function rotateZ(out: Matrix4InOut, a: Matrix4InOut, rad: number): Matrix4InOut;\nexport declare function multiply(out: Matrix4InOut, a: Matrix4InOut, b: Matrix4InOut): Matrix4InOut;\nexport declare function invert(out: Matrix4InOut, a: Matrix4InOut): Matrix4InOut;\n/**\n * Set a mat4 to the identity matrix\n * @ignore\n * @param out the receiving matrix\n * @returns out\n */\nexport declare function identity(out: Matrix4InOut): Matrix4InOut;\n/**\n * Copy the values from one mat4 to another\n * @ignore\n * @param out the receiving matrix\n * @param a the source matrix\n * @returns out\n */\nexport declare function copy(out: Matrix4InOut, a: Matrix4InOut): Matrix4InOut;\n"},{"path":"core/util/math.d.ts","content":"import { Matrix4InOut, Vector3, Vector4 } from './mat4';\nexport declare function applyMatrix(out: Matrix4InOut, v: Vector3, e: Matrix4InOut): Matrix4InOut;\nexport declare function applyMatrix4(out: Matrix4InOut, v: Vector4, e: Matrix4InOut): any;\nexport declare function matrixToQuaternion(out: any, te: any): any;\nexport declare function quaternionToMatrix(out: Matrix4InOut, q: any): Matrix4InOut;\nexport declare function setPosition(out: Matrix4InOut, v: Vector3): Matrix4InOut;\nexport declare function lookAt(te: Matrix4InOut, eye: any, target: any, up: any): Matrix4InOut;\n"},{"path":"core/util/path.d.ts","content":"import Point from '../../geo/Point';\nimport Coordinate from '../../geo/Coordinate';\nexport declare function clipLine(points: any, bounds: any, round?: boolean, noCut?: boolean): any[];\nexport declare function clipSegment(a: any, b: any, bounds: any, useLastCode: any, round: any, noCut: any): false | any[];\nexport declare function clipPolygon(points: any, bounds: any, round?: boolean): any;\n/**\n * caculate the distance from a point to a segment.\n * @param p\n * @param p1\n * @param p2\n * @return distance from p to (p1, p2)\n * @memberOf Util\n */\nexport declare function distanceToSegment(p: Point, p1: Point, p2: Point): number;\n/**\n * Whether the coordinate is inside the polygon\n * @param p\n * @param points\n * @return\n * @memberOf Util\n */\nexport declare function pointInsidePolygon(p: Coordinate, points: Coordinate[]): boolean;\n/**\n * Is the point within an ellipse\n * @param  point\n * @param  center ellipse's center\n * @param  southeast ellipse's southeast point\n * @param  tolerance\n * @returns\n * @private\n * @memberOf Util\n */\nexport declare function withInEllipse(point: Point, center: Point, southeast: Point, tolerance: number): boolean;\nexport declare function getMinMaxAltitude(altitude: number | number[] | number[][]): [number, number];\n"},{"path":"core/util/resource.d.ts","content":"/**\n * Translate symbol properties to SVG properties\n * @param s - object with symbol properties\n * @return  object with SVG properties\n * @memberOf Util\n */\nexport declare function translateToSVGStyles(s: any): {\n    stroke: {\n        stroke: any;\n        'stroke-width': any;\n        'stroke-opacity': any;\n        'stroke-dasharray': any;\n        'stroke-linecap': string;\n        'stroke-linejoin': string;\n    };\n    fill: {\n        fill: any;\n        'fill-opacity': any;\n    };\n};\n/**\n * Get SVG Base64 String from a marker symbol with (markerType : path)\n * @param  symbol - symbol with markerType of path\n * @param  width\n * @param  height\n * @return SVG Base64 String\n * @memberOf Util\n */\nexport declare function getMarkerPathBase64(symbol: any, width?: number, height?: number): string;\n/**\n * Get external resources from the given symbol\n * @param symbol     - symbol\n * @param toAbsolute - whether convert url to aboslute\n * @return resource urls\n * @memberOf Util\n */\nexport declare function getExternalResources(symbol: any, toAbsolute?: boolean): string[];\n/**\n * Convert symbol's resources' urls from relative path to an absolute path.\n * @param symbol\n * @private\n * @memberOf Util\n */\nexport declare function convertResourceUrl(symbol: any): any;\nexport declare function isImageBitMap(img: any): boolean;\n"},{"path":"core/util/strings.d.ts","content":"import Point from '../../geo/Point';\nimport Size from '../../geo/Size';\n/**\n * @classdesc\n * Utilities methods for Strings used internally. It is static and should not be initiated.\n * @class\n * @static\n * @category core\n * @name StringUtil\n */\nexport declare const EMPTY_STRING = \"\";\n/**\n * Trim the string\n * @param str\n * @return\n * @memberOf StringUtil\n */\nexport declare function trim(str: string): string;\nexport declare function replaceAll(str: string, key: string, value: string): string;\n/**\n * Escape special characters from string.\n * Including: \\b \\t \\r \\v \\f\n * @param str string to escape\n * @return\n * @memberOf StringUtil\n */\nexport declare function escapeSpecialChars(str: string): string;\n/**\n * Split string by specified char\n * @param chr - char to split\n * @return\n * @memberOf StringUtil\n */\nexport declare function splitWords(chr: string): string[];\n/**\n * Gets width of the text with a certain font.\n * More performant than stringLength.\n * @param text - text to measure\n * @param font - font of the text, same as the CSS font.\n * @return\n * @memberOf StringUtil\n */\nexport declare function stringWidth(text: string, font?: string): number;\n/**\n * Gets size in pixel of the text with a certain font.\n * @param text - text to measure\n * @param font - font of the text, same as the CSS font.\n * @return\n * @memberOf StringUtil\n */\nexport declare function stringLength(text: string, font: string, size?: number): Size;\n/**\n * Split text content by dom.\n * @param content - content to split\n * @param font - font of the text, same as the CSS font.\n * @return wrapWidth - width to wrap\n * @return {String[]}\n * @memberOf StringUtil\n */\nexport declare function splitContent(content: string, font: string, wrapWidth: number, textWidth: number): any[];\n/**\n * Replace variables wrapped by square brackets ({foo}) with actual values in props.\n * @example\n *     // will returns 'John is awesome'\n *     const actual = replaceVariable('{foo} is awesome', {'foo' : 'John'});\n * @param str      - string to replace\n * @param props    - variable value properties\n * @return\n * @memberOf StringUtil\n */\nexport declare function replaceVariable(str: string, props: Object): string;\n/**\n * Generate text descriptors according to symbols\n * @return {Object} text descriptor\n * @memberOf StringUtil\n */\nexport declare function describeText(textContent: any, symbol: any): {\n    total: number;\n    size: Size;\n    rows: any[];\n    rawSize: Size;\n};\n/**\n * Gets text's align point according to the horizontalAlignment and verticalAlignment\n * @param  {Size} size                  - text size\n * @param  {String} horizontalAlignment - horizontalAlignment: left/middle/right\n * @param  {String} verticalAlignment   - verticalAlignment: top/middle/bottom\n * @return {Point}\n * @memberOf StringUtil\n */\nexport declare function getAlignPoint(size: Size, horizontalAlignment: string, verticalAlignment: string): Point;\nexport declare const DEFAULT_FONT = \"sans-serif\";\nexport declare const DEFAULT_TEXTSIZE = 14;\n/**\n * Returns CSS Font from a symbol with text styles.\n * @param  {Object} style symbol with text styles\n * @return {String}       CSS Font String\n * @memberOf StringUtil\n */\nexport declare function getFont(style: any): any;\n/**\n * Split a text to multiple rows according to the style.\n * @param {String} text     - text to split\n * @param {Object} style    - text style\n * @return {Object[]} the object's structure: { rowNum: rowNum, textSize: textSize, rows: textRows, rawSize : rawSize }\n * @memberOf StringUtil\n */\nexport declare function splitTextToRow(text: string, style: Object): {\n    total: number;\n    size: Size;\n    rows: any[];\n    rawSize: Size;\n};\nexport declare function hashCode(s: string): number;\n"},{"path":"core/util/style.d.ts","content":"/**\n * Whether the color is a gradient\n * @param g - color to test\n * @return\n * @memberOf Util\n */\nexport declare function isGradient(g: Object): boolean;\n/**\n * Get stamp of a gradient color object.\n * @param g gradient color object\n * @return gradient stamp\n * @memberOf Util\n */\nexport declare function getGradientStamp(g: Object): string;\nexport declare function getSymbolStamp(symbol: Object, prefix: string): string | number;\n/**\n * Get stamp of a symbol\n * @param symbol symbol\n * @return symbol's stamp\n * @memberOf Util\n */\nexport declare function getSymbolHash(symbol: Object | Object[], prefix?: string): string | number;\n/**\n * Reduce opacity of the color by ratio\n * @param symbol symbols to set\n * @param ratio  ratio of opacity to reduce\n * @return new symbol or symbols\n * @memberOf Util\n */\nexport declare function lowerSymbolOpacity(symbol: Object | Object[], ratio: number): Object | Object[];\n/**\n * Merges the properties of sources into the symbol. <br>\n * @param args - sources\n * @return merged symbol\n * @memberOf Util\n */\nexport declare function extendSymbol(...args: Object[]): Object | Object[];\nexport declare function parseStyleRootPath(style: any): any;\nexport declare function convertStylePath(styles: any[], replacer: any): void;\nexport declare function parseSymbolPath(symbol: any, replacer: string): void;\n/**\n * geometry symbol has lineDasharray\n * @memberOf Util\n */\nexport declare function isDashLine(symbolizers?: any[]): boolean;\n"},{"path":"core/util/util.d.ts","content":"declare let requestAnimFrame: any, cancelAnimFrame: typeof clearTimeout;\nexport { requestAnimFrame, cancelAnimFrame };\nexport declare function isSVG(url: string): 0 | 1 | 2;\n/**\n * Load a image, can be a remote one or a local file. <br>\n * If in node, a SVG image will be converted to a png file by [svg2img]{@link https://github.com/FuZhenn/node-svg2img}<br>\n * @param img  - the image object to load.\n * @param imgDesc - image's descriptor, it's an array. imgUrl[0] is the url string, imgUrl[1] is the width, imgUrl[2] is the height.\n * @private\n * @memberOf Util\n */\nexport declare function loadImage(img: any, imgDesc: Object[]): void;\nexport declare function UID(): number;\nexport declare const GUID: typeof UID;\n/**\n * Parse a JSON string to a object\n * @param str   - a JSON string\n * @return\n * @memberOf Util\n */\nexport declare function parseJSON(str: string): any;\nexport declare function pushIn<T extends Array<any>>(...args: T[]): number;\nexport declare function removeFromArray<T>(obj: T, array: T[]): void;\nexport declare function forEachCoord(arr: any[], fn: Function, context?: any): any;\nexport declare function getValueOrDefault<T>(v: T, d: T): T;\n/**\n * Polyfill for Math.sign\n * @param  x\n * @return\n * @memberOf Util\n */\nexport declare function sign(x: number): number;\nexport declare function log2(x: number): number;\n/**\n * Interpolate between two number.\n *\n * @param from\n * @param to\n * @param t interpolation factor between 0 and 1\n * @returns interpolated color\n */\nexport declare function interpolate(a: number, b: number, t: number): number;\n/**\n * constrain n to the given range, via modular arithmetic\n * @param n value\n * @param min the minimum value to be returned, inclusive\n * @param max the maximum value to be returned, inclusive\n * @returns constrained number\n * @private\n */\nexport declare function wrap(n: number, min: number, max: number): number;\n/**\n * constrain n to the given range via min + max\n *\n * @param n value\n * @param min the minimum value to be returned\n * @param max the maximum value to be returned\n * @returns the clamped value\n * @private\n */\nexport declare function clamp(n: number, min: number, max: number): number;\n/**\n * Is object an array and not empty.\n * @param obj\n * @return true|false\n * @private\n * @memberOf Util\n */\nexport declare function isArrayHasData(obj: Object): boolean;\n/**\n * Whether the input string is a valid url.\n * form: https://github.com/axios/axios/blob/master/lib/helpers/isAbsoluteURL.js\n * @param url - url to check\n * @return\n * @memberOf Util\n * @private\n */\nexport declare function isURL(url: string): boolean;\nexport declare function isCssUrl(str: string): 0 | 1 | 2 | 3;\nexport declare function extractCssUrl(str: string): any;\n/**\n * btoa or a polyfill in old browsers. <br>\n * Creates a base-64 encoded ASCII string from a String object in which each character in the string is treated as a byte of binary data.<br>\n * From https://github.com/davidchambers/Base64.js\n * @param input - input string to convert\n * @return ascii\n * @memberOf Util\n * @example\n *     const encodedData = Util.btoa(stringToEncode);\n */\nexport declare function btoa(input: string): string;\nexport declare function b64toBlob(b64Data: string, contentType: string): Blob;\n/**\n * Compute degree bewteen 2 points.\n * @param  x0\n * @param  y0\n * @param  x1\n * @param  y1\n * @return    degree between 2 points\n * @memberOf Util\n */\nexport declare function computeDegree(x0: number, y0: number, x1: number, y1: number): number;\n/**\n * Transparent 1X1 gif image\n * from https://css-tricks.com/snippets/html/base64-encode-of-1x1px-transparent-gif/\n * @memberOf Util\n */\nexport declare const emptyImageUrl = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n/**\n * shallow equal\n * @param  obj1\n * @param  obj2\n * @return\n * @private\n * @memberOf Util\n */\nexport declare function equalMapView(obj1: Object, obj2: Object): boolean;\n/**\n * Flash something, show and hide by certain internal for times of count.\n *\n * @param interval   - interval of flash, in millisecond (ms)\n * @param count      - flash times\n * @param cb         - callback function when flash ended\n * @param context    - callback context\n * @return this\n * @private\n * @memberOf Util\n */\nexport declare function flash(interval?: number, count?: number, cb?: Function, context?: any): any;\nexport declare function _defaults(obj: any, defaults: any): any;\nexport declare function getPointsResultPts(points?: any[], ptKey?: string): any[];\nexport declare function getImageBitMap<T>(data: {\n    data: T;\n}, cb: (d: T) => void | any): void;\nexport declare function getAbsoluteURL(url: string): string;\nexport declare function calCanvasSize(size: {\n    width: number;\n    height: number;\n}, devicePixelRatio?: number): {\n    cssWidth: string;\n    cssHeight: string;\n    width: number;\n    height: number;\n};\n"},{"path":"core/util/vec3.d.ts","content":"import { Matrix4InOut, Vector3 as Vec3 } from './mat4';\n/**\n * Set the components of a vec3 to the given values\n * @ignore\n * @param out the receiving vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @returns out\n */\nexport declare function set(out: Vec3, x: number, y: number, z: number): Vec3;\n/**\n * Adds two vec3's\n * @ignore\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @returns out\n */\nexport declare function add(out: Vec3, a: Vec3, b: Vec3): Vec3;\n/**\n * Subtracts vector b from vector a\n * @ignore\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @returns out\n */\nexport declare function subtract(out: Vec3, a: Vec3, b: Vec3): Vec3;\n/**\n * Calculates the length of a vec3\n * @ignore\n * @param a vector to calculate length of\n * @returns length of a\n */\nexport declare function length(a: Vec3): number;\n/**\n * Normalize a vec3\n * @ignore\n * @param out the receiving vector\n * @param a vector to normalize\n * @returns out\n */\nexport declare function normalize(out: Vec3, a: Vec3): Vec3;\n/**\n * Calculates the dot product of two vec3's\n * @ignore\n * @param a the first operand\n * @param b the second operand\n * @returns dot product of a and b\n */\nexport declare function dot(a: Vec3, b: Vec3): number;\n/**\n * Scales a vec3 by a scalar number\n * @ignore\n * @param out the receiving vector\n * @param a the vector to scale\n * @param b amount to scale the vector by\n * @returns out\n */\nexport declare function scale(out: Vec3, a: Vec3, b: number): Vec3;\n/**\n * Computes the cross product of two vec3's\n * @ignore\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @returns out\n */\nexport declare function cross(out: Vec3, a: Vec3, b: Vec3): Vec3;\n/**\n * Calculates the euclidian distance between two vec3's\n * @ignore\n * @param a the first operand\n * @param b the second operand\n * @returns distance between a and b\n */\nexport declare function distance(a: Vec3, b: Vec3): number;\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n * @ignore\n * @param out the receiving vector\n * @param a the vector to transform\n * @param m matrix to transform with\n * @returns out\n */\nexport declare function transformMat4(out: Vec3, a: Vec3, m: Matrix4InOut): Vec3;\nexport declare function angle(a: Vec3, b: Vec3): number;\n"},{"path":"core/worker/Actor.d.ts","content":"import WorkerPool from './WorkerPool';\nexport type Message<T = any> = {\n    command: \"broadcast\" | 'send';\n    data: T;\n    buffers: ArrayBuffer[];\n    cb: Function;\n    workerId?: number;\n};\n/**\n * An actor to exchange data from main-thread to workers\n * contains code from [mapbox-gl-js](https://github.com/mapbox/mapbox-gl-js)\n * @category core\n * @memberof worker\n * @example\n *  const workerKey = 'test_worker_key';\n    maptalks.registerWorkerAdapter(workerKey, function (exports, global) {\n      //will be called only for once when loaded in worker thread\n      exports.initialize = function () {\n        console.log('[worker] initialized');\n      };\n      //to receive message from main thread sent by maptalks.worker.Actor\n      exports.onmessage = function (message, postResponse) {\n        const data = message.data;\n        console.log(`[worker] received data : ` + data);\n        //send message back to main thread\n        //the parameters:\n        //error, data, buffers (arraybuffers in data)\n        postResponse(null, 'message from worker thread', null);\n      };\n    });\n\n    const MyActor = class extends maptalks.worker.Actor {\n      test(info, cb) {\n        //send data to worker thread\n        this.send(info, null, cb);\n      }\n    }\n\n    //must be same with workerKey for maptalks.registerWorkerAdapter\n    const actor = new MyActor(workerKey);\n    actor.test('hi', (err, data) => {\n      //received data from worker thread\n      console.log(data);\n    });\n */\ndeclare class Actor {\n    _delayMessages: Message[];\n    initializing: boolean;\n    workerKey: string;\n    workerPool: WorkerPool;\n    currentActor: number;\n    actorId: number;\n    workers: Worker[];\n    callbacks: {\n        [key: string]: Function;\n    };\n    callbackID: number;\n    receiveFn: any;\n    constructor(workerKey: string);\n    created(): void;\n    /**\n     * If the actor is active\n     * @returns\n     */\n    isActive(): boolean;\n    /**\n     * Broadcast a message to all Workers.\n     * @param {Object} data - data to send to worker thread\n     * @param {ArrayBuffer[]} buffers - arraybuffers in data as transferables\n     * @param {Function} cb - callback function when received message from worker thread\n     */\n    broadcast<T = any>(data: T, buffers: ArrayBuffer[], cb: Function): this;\n    /**\n     * Sends a message from a main-thread to a Worker and call callback when response received.\n     *\n     * @param {Object} data - data to send to worker thread\n     * @param {ArrayBuffer[]} buffers - arraybuffers in data as transferables\n     * @param {Function} cb - callback function when received message from worker thread\n     * @param {Number} [workerId=undefined] - Optional, a particular worker id to which to send this message.\n     */\n    send<T = any>(data: T, buffers: ArrayBuffer[], cb: Function, workerId?: number): this;\n    /**\n     * A listener callback for incoming message from worker thread.\n     * SHOULD NOT BE OVERRIDED only if you know what you are doing.\n     * @param {Object} message - response message from worker thread\n     */\n    receive(message: Message): void;\n    /**\n     * Remove the actor\n     */\n    remove(): void;\n    /**\n     * Send a message to a Worker.\n     * @param {Object} data - data to send\n     * @param {ArrayBuffer[]} buffers   - arraybuffers in data\n     * @param {Number} targetID The ID of the Worker to which to send this message. Omit to allow the dispatcher to choose.\n     * @returns {Number} The ID of the worker to which the message was sent.\n     */\n    post(data: any, buffers: ArrayBuffer[], targetID: number): number;\n    /**\n     * Get a dedicated worker in a round-robin fashion\n     */\n    getDedicatedWorker(): number;\n}\nexport default Actor;\n"},{"path":"core/worker/CoreWorkers.d.ts","content":"import WorkerPool from './WorkerPool';\nexport declare const imageFetchWorkerKey = \"core-fetch-image\";\nexport declare function setWorkerPool(pool: WorkerPool): void;\nexport declare function getWorkerPool(): WorkerPool;\nexport declare function setWorkersCreated(): void;\nexport declare function workersHasCreated(): boolean;\nexport declare function adapterHasCreated(workerKey: string): boolean;\nexport declare function pushAdapterCreated(workerKey: string): void;\n"},{"path":"core/worker/FPSCheckWorker.d.ts","content":"export declare const CHECK_FPS_WORKER_KEY = \"check_browser_max_fps\";\n"},{"path":"core/worker/Worker.d.ts","content":"type AdapterFunction = (exports: {\n    initialize: Function;\n    onmessage: (message: any, postResponse: Function) => void;\n}, global: any) => void;\ntype Adapter = string | AdapterFunction;\n/**\n * Register a worker adapter\n * @param {String} workerKey  - an unique key name of the worker adapter\n * @param {Function} adapter  - the worker adapter function, it must be a complete packaged function with no dependency of other functions\n * @example\n * maptalks.registerWorkerAdapter('foo', function (exports, global) {\n        //will be called only for once when loaded in worker thread\n        exports.initialize = function () {\n          console.log('[worker] initialized');\n        };\n        //to receive message from main thread sent by maptalks.worker.Actor\n        exports.onmessage = function (message, postResponse) {\n          const data = message.data;\n          console.log(`[worker] received data : ` + data);\n          //send message back to main thread\n          //the parameters:\n          //error, data, buffers (arraybuffers in data)\n          postResponse(null, 'message from worker thread', null);\n        };\n     });\n    @global\n    @static\n */\nexport declare function registerWorkerAdapter(workerKey: string, adapter: Adapter): void;\nexport declare function getWorkerSourcePath(): string;\nexport declare function createAdapter(key: string, cb: Function): void;\nexport {};\n"},{"path":"core/worker/WorkerPool.d.ts","content":"import { type Message } from './Actor';\ndeclare class MessageBatch {\n    _limit: number;\n    _messages: Message[];\n    buffers: ArrayBuffer[];\n    constructor(limit?: number);\n    addMessage(msg: Message, buffers: ArrayBuffer[]): void;\n    isFull(): boolean;\n    getMessage(): {\n        messageType: string;\n        messages: Message[];\n    };\n}\n/**\n * Worker Pool\n * contains code from [mapbox-gl-js](https://github.com/mapbox/mapbox-gl-js)\n * @private\n */\nexport default class WorkerPool {\n    active: {\n        [key: number]: boolean;\n    };\n    workerCount: number;\n    _messages: MessageBatch[][];\n    _messageBuffers: ArrayBuffer[];\n    workers: Worker[];\n    constructor();\n    acquire(id: number): Worker[];\n    release(id: number): void;\n    addMessage(workerId: number, data: any, buffers: ArrayBuffer[]): void;\n    commit(): void;\n    getWorkers(): Worker[];\n    broadcastIdleMessage(): this;\n}\nexport declare function getGlobalWorkerPool(): WorkerPool;\nexport {};\n"},{"path":"geo/Coordinate.d.ts","content":"import Position from './Position';\nexport type CoordinateJson = {\n    x: number;\n    y: number;\n    z?: number;\n};\nexport type CoordinateArray = [number, number] | [number, number, number];\nexport type CoordinateLike = Coordinate | CoordinateJson | CoordinateArray;\n/**\n * 坐标 `Coordinate` 的实现，例如一个地理坐标点（经度，纬度）\n *\n * @english\n *\n * Represents a coordinate point <br>\n * e.g. <br>\n * A geographical point (longitude, latitude)\n * @example\n *\n * ```ts\n * const coord = new Coordinate(0, 0);\n * ```\n * @example\n *\n * ```ts\n * const coord = new Coordinate([ 0, 0 ]);\n * ```\n * @example\n *\n * ```ts\n * const coord = new Coordinate({ x : 0, y : 0 });\n * ```\n * @category basic types\n */\ndeclare class Coordinate extends Position {\n    /**\n     * 将一个或多个坐标对象转换为GeoJSON风格的坐标。\n     *\n     * @english\n     *\n     * Convert one or more Coordinate objects to GeoJSON style coordinates\n     * @param coordinates - coordinates to convert\n     * @example\n     *\n     * ```ts\n     * // result is [[100,0], [101,1]]\n     * const numCoords = Coordinate.toNumberArrays([new Coordinate(100,0), new Coordinate(101,1)]);\n     * ```\n     */\n    static toNumberArrays(coordinates: Coordinate): any;\n    static toNumberArrays(coordinates: Coordinate[]): any;\n    static toNumberArrays(coordinates: Coordinate[][]): any;\n    static toNumberArrays(coordinates: Coordinate[][][]): any;\n    /**\n     * 将一个或多个GeoJSON风格的坐标转换为坐标对象。\n     *\n     * @english\n     *\n     * Convert one or more GeoJSON style coordiantes to Coordinate objects\n     * @param coordinates - coordinates to convert\n     * @example\n     *\n     * ```ts\n     * const coordinates = Coordinate.toCoordinates([[100,0], [101,1]]);\n     * ```\n     */\n    static toCoordinates(coordinates: CoordinateArray | CoordinateArray[] | CoordinateArray[][] | Coordinate | Coordinate[] | Coordinate[][]): Coordinate | Coordinate[] | Coordinate[][];\n    /**\n     * 使用差值与另一个坐标进行比较，判断是否临近\n     *\n     * @english\n     *\n     * Compare with another Coordinate with a delta\n     * @param p\n     * @param delta\n     */\n    closeTo(p: Coordinate, delta?: number): boolean;\n    /**\n     * 返回该坐标的经纬度绝对值的坐标对象（不会改变原始数据）\n     *\n     * @english\n     *\n     * Return abs value of the coordinate\n     * @returns abs Coordinate\n     */\n    abs(): Coordinate;\n    /**\n     * 类似于数学中的四舍五入，对坐标的 x 和 y 进行舍入，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Like math.round, rounding the coordinate's xy.\n     * @returns rounded coordinate\n     */\n    round(): Coordinate;\n    /**\n     * 对坐标的 x 和 y 向上取整，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Like math.ceil, ceil the coordinate's xy.\n     * @returns ceiled coordinate\n     */\n    ceil(): Coordinate;\n    /**\n     * 对坐标的 x 和 y 向下取整，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Like math.floor, floor the coordinate's xy.\n     * @returns floored coordinate\n     */\n    floor(): Coordinate;\n    /**\n     * 返回当前坐标的 copy\n     *\n     * @english\n     *\n     * Returns a copy of the coordinate\n     * @returns copy\n     */\n    copy(): Coordinate;\n    /**\n     * 坐标数字保留指定位数的小数\n     *\n     * @english\n     *\n     * Formats coordinate number using fixed-coordinate notation.\n     * @param n - The number of digits to appear after the decimal coordinate\n     * @returns fixed coordinate\n     */\n    toFixed(n: number): Coordinate;\n    /**\n     * 与传入坐标相加，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Returns the result of addition of another coordinate.\n     * @param x - coordinate to add\n     * @returns result\n     */\n    add(x: CoordinateLike): Coordinate;\n    /**\n     * 与传入坐标相加，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Returns the result of addition of another coordinate.\n     * @param x - coordinate to add\n     * @param y - coordinate to add\n     * @returns result\n     */\n    add(x: number, y: number): Coordinate;\n    /**\n     * 与传入坐标相减，返回一个新 Coordinate。\n     *\n     * @english\n     *\n     * Returns the result of subtraction of another coordinate.\n     * @param x - coordinate to add\n     * @returns result\n     */\n    sub(x: CoordinateLike): Coordinate;\n    /**\n     * 与传入坐标相减，返回一个新 Coordinate。\n     *\n     * @english\n     *\n     * Returns the result of subtraction of another coordinate.\n     * @param x - coordinate to add\n     * @param y - coordinate to add\n     * @returns result\n     */\n    sub(x: number, y: number): Coordinate;\n    /**\n     * Returns the result of multiplication of the current coordinate by the given number.\n     * @param ratio - ratio to multi\n     * @returns result\n     */\n    multi(ratio: number): Coordinate;\n    /**\n     * 与另外一个 coordinate 进行比较，以查看它们是否相等\n     *\n     * @english\n     *\n     * Compare with another coordinate to see whether they are equal.\n     * @param c - coordinate to compare\n     */\n    equals(c: Coordinate): boolean;\n}\nexport default Coordinate;\n"},{"path":"geo/CRS.d.ts","content":"import type { WithNull } from '../types/typings';\n/**\n * 表示由 [GeoJSON](http://geojson.org/geojson-spec.html#coordinate-reference-system-objects)定义的 CRS\n * @english\n *\n * Represent CRS defined by [GeoJSON]{@link http://geojson.org/geojson-spec.html#coordinate-reference-system-objects}\n *\n * @category geo\n */\ndeclare class CRS {\n    type: string;\n    properties: any;\n    /**\n     * @param type type of the CRS\n     * @param properties CRS's properties\n     */\n    constructor(type: string, properties: Record<string, any>);\n    /**\n     * 使用 maptalks 创建 [proj4](https://github.com/OSGeo/proj.4) 形式的 CRS\n     * @english\n     * Create a [proj4](https://github.com/OSGeo/proj.4) style CRS used by maptalks <br>\n     * @example\n     * {\n     *     \"type\"       : \"proj4\",\n     *     \"properties\" : {\n     *         \"proj\"   : \"+proj=longlat +datum=WGS84 +no_defs\"\n     *     }\n     * }\n     * var crs_wgs84 = CRS.createProj4(\"+proj=longlat +datum=WGS84 +no_defs\");\n     * @param proj a proj4 projection string.\n     */\n    static createProj4(proj: string): CRS;\n    /**\n     * 使用 maptalks 创建 [epsg](https://spatialreference.org/ref/epsg/) 形式的 CRS\n     * @english\n     * Create a [epsg](https://spatialreference.org/ref/epsg/) style CRS used by maptalks <br>\n     * @example\n     * var crs_wgs84 = CRS.createProj4(\"EPSG:4326\");\n     * @param code a proj4 projection string.\n     */\n    static fromProjectionCode(code: string): WithNull<CRS>;\n    /**\n     * 预定义的WGS84坐标参考系统（也称为EPSG:4326）。\n     * @english\n     * Predefined CRS of well-known WGS84 (aka EPSG:4326)\n     */\n    static WGS84: CRS;\n    /**\n     * CRS.WGS84 的别名\n     * @english\n     * Alias for CRS.WGS84\n     */\n    static EPSG4326: CRS;\n    /**\n     * 谷歌地图使用的投影坐标系统具有以下别名：'EPSG:3785'、'GOOGLE'、'EPSG:900913'。\n     * @english\n     * Projected Coordinate System used by google maps that has the following alias: 'EPSG:3785', 'GOOGLE', 'EPSG:900913'\n     */\n    static EPSG3857: CRS;\n    /**\n     * 一个代表简单的笛卡尔坐标系统。<br>\n     * 它直接映射x、y坐标，对于平面地图（例如室内地图、游戏地图）非常有用。\n     *\n     * @english\n     * A CRS represents a simple Cartesian coordinate system. <br>\n     * Maps x, y directly, is useful for maps of flat surfaces (e.g. indoor maps, game maps).\n     */\n    static IDENTITY: CRS;\n    /**\n     * 中国官方坐标系统（即EPSG:4490），在大多数情况下，可以认为与WGS84相同。\n     *\n     * @english\n     * Official coordinate system in China (aka EPSG:4490), in most cases, it can be considered the same with WGS84.\n     * @see  [7408](http://spatialreference.org/ref/sr-org/7408/)\n     */\n    static CGCS2000: CRS;\n    /**\n     * CRS.CGCS2000 的别名\n     *\n     * @english\n     * Alias for CRS.CGCS2000\n     */\n    static EPSG4490: CRS;\n    /**\n     * 百度地图使用的投影坐标系统。\n     *\n     * @english\n     * Projection used by [Baidu Map](http://map.baidu.com), a popular web map service in China.\n     */\n    static BD09LL: CRS;\n    /**\n     * 中国的大多数在线地图服务中所使用一种加密的坐标参考系统（CRS）。\n     *\n     * @english\n     * A encrypted CRS usded in the most online map services in China.\n     * @see [Restrictions_on_geographic_data_in_China](https://en.wikipedia.org/wiki/Restrictions_on_geographic_data_in_China)\n     */\n    static GCJ02: CRS;\n}\nexport default CRS;\n"},{"path":"geo/Extent.d.ts","content":"import Coordinate, { CoordinateLike } from './Coordinate';\nimport Point from './Point';\nimport Size from './Size';\nimport type PointExtent from './PointExtent';\nimport type { WithNull } from '../types/typings';\nexport type Projection = any;\nexport type Position = Point | Coordinate;\nexport type ArrayExtent = [number, number, number, number];\nexport type JsonExtent = {\n    xmin: number;\n    xmax: number;\n    ymin: number;\n    ymax: number;\n};\nexport type ExtentLike = Extent | JsonExtent | ArrayExtent;\nexport interface Constructable<T> {\n    new (p1?: WithNull<ExtentLike>, p?: Projection): T;\n    new (p1: Position, p2: Position, p?: Projection): T;\n    new (p1: number, p2: number, p3: number, p4: number, p?: Projection): T;\n}\n/**\n * 表示地图上的边界框，即具有最小和最大坐标的矩形地理区域。 <br>\n * 有多种方法可以创建范围：\n *\n * @english\n *\n * Represent a bounding box on the map, a rectangular geographical area with minimum and maximum coordinates. <br>\n * There are serveral ways to create a extent:\n * @category basic types\n * @example\n *\n * ```ts\n * //with 4 numbers: xmin, ymin, xmax and ymax\n * var extent = new Extent(100, 10, 120, 20);\n *\n * //with 2 coordinates\n * var extent = new Extent(new Coordinate(100, 10), new Coordinate(120, 20));\n *\n * //with a json object containing xmin, ymin, xmax and ymax\n * var extent = new Extent({xmin : 100, ymin: 10, xmax: 120, ymax:20});\n *\n * var extent1 = new Extent(100, 10, 120, 20);\n * //with another extent\n * var extent2 = new Extent(extent1);\n * ```\n */\ndeclare class Extent {\n    _clazz: typeof Coordinate | typeof Point;\n    _dirty: boolean;\n    projection: any;\n    xmin: WithNull<number>;\n    xmax: WithNull<number>;\n    ymin: WithNull<number>;\n    ymax: WithNull<number>;\n    pxmin: number;\n    pxmax: number;\n    pymin: number;\n    pymax: number;\n    left?: number;\n    right?: number;\n    top?: number;\n    bottom?: number;\n    constructor(p1?: WithNull<ExtentLike>, p?: Projection);\n    constructor(p1: Position, p2: Position, p?: Projection);\n    constructor(p1: number, p2: number, p3: number, p4: number, p?: Projection);\n    _initialize(p1: WithNull<ExtentLike>): void;\n    _initialize(p1: Position, p2: Position): void;\n    _initialize(p1: number, p2: number, p3: number, p4: number): void;\n    /**\n     * 与坐标或点相加, 会改变原数据\n     *\n     * @english\n     *\n     * Add the extent with a coordinate or a point.\n     * @returns a new extent\n     * @param p\n     */\n    _add(p: Extent): this;\n    _add(p: PointExtent): this;\n    _add(p: Position): this;\n    _add(p: number[]): this;\n    /**\n     * 与坐标或点相加, 返回一个新的 extent\n     *\n     * @english\n     *\n     * Add the extent with a coordinate or a point.\n     * @returns a new extent\n     * @param p\n     */\n    add(p: Extent): this;\n    add(p: PointExtent): this;\n    add(p: Position): this;\n    add(p: number[]): this;\n    /**\n     * 缩放当前 extent\n     *\n     * @english\n     *\n     * scale extent\n     *\n     * @param s\n     */\n    _scale(s: number): this;\n    /**\n     * 当前范围减去 coordinate、point 或者 extent（改变原数据）\n     *\n     * @english\n     *\n     * Substract the extent with a coordinate or a point.\n     * @param p\n     */\n    _sub(p: [number, number]): this;\n    _sub(p: Position): this;\n    _sub(p: Extent | PointExtent): this;\n    /**\n     * _sub 的别名\n     *\n     * @english\n     *\n     * Alias for _sub\n     * @param p\n     */\n    _substract(p: [number, number]): this;\n    _substract(p: Position): this;\n    _substract(p: Extent | PointExtent): this;\n    /**\n     * 当前范围减去 coordinate 或者 point\n     *\n     * @english\n     *\n     * Substract the extent with a coordinate or a point.\n     * @returns a new extent\n     * @param p\n     */\n    sub(p: [number, number]): this;\n    sub(p: Position): this;\n    sub(p: Extent | PointExtent): this;\n    /**\n     * sub 的别名\n     *\n     * @english\n     *\n     * Alias for sub\n     * @returns a new extent\n     * @param p\n     */\n    substract(p: [number, number]): this;\n    substract(p: Position): this;\n    substract(p: Extent | PointExtent): this;\n    /**\n     * 对 Extent 边界值进行四舍五入，返回一个新的 Extent\n     *\n     * @english\n     *\n     * Round the extent\n     * @returns rounded extent\n     */\n    round(): PointExtent | Extent;\n    /**\n     * 对当前 Extent 边界值进行四舍五入\n     *\n     * @english\n     *\n     * Round the extent\n     * @returns rounded extent\n     */\n    _round(): this;\n    /**\n     * 获取 Extent 的最小点\n     *\n     * @english\n     * Get the minimum point\n     * @params [out=undefined] - optional point to receive result\n     */\n    getMin(out?: Point): Point;\n    getMin(out?: Coordinate): Coordinate;\n    /**\n     * 获取 Extent 的最大点\n     *\n     * @english\n     * Get the maximum point\n     * @params [out=undefined] - optional point to receive result\n     */\n    getMax(out?: Point): Point;\n    getMax(out?: Coordinate): Coordinate;\n    /**\n     * 获取 Extent 的中心点\n     *\n     * @english\n     * Get center of the extent.\n     * @params [out=undefined] - optional point to receive result\n     */\n    getCenter(out?: Position): Position;\n    /**\n     * 检查 Extent 是否有效\n     *\n     * @english\n     * Whether the extent is valid\n     * @protected\n     */\n    isValid(): boolean;\n    /**\n     * 与另一个 extent 进行比较它们是否相等\n     *\n     * @english\n     *\n     * Compare with another extent to see whether they are equal.\n     * @param ext2 - extent to compare\n     */\n    equals(ext2: Extent | PointExtent): boolean;\n    /**\n     * 是否与另一个范围相交\n     * @english\n     *\n     * Whether it intersects with another extent\n     * @param ext2 - another extent\n     */\n    intersects(ext2: Extent | PointExtent): boolean;\n    /**\n     * 判断当前 extent 是否在其他 extent 范围内\n     * @english\n     *\n     * Whether the extent is within another extent\n     * @param extent - another extent\n     */\n    within(extent: Extent | PointExtent): boolean;\n    /**\n     * 该范围是否包含输入点\n     * @english\n     * Whether the extent contains the input point.\n     * @param c - input point\n     */\n    contains(c: CoordinateLike): boolean;\n    /**\n     * 获取Extent的宽度\n     *\n     * @english\n     * Get the width of the Extent\n     */\n    getWidth(): number;\n    /**\n     * 获取Extent的高度\n     *\n     * @english\n     * Get the height of the Extent\n     */\n    getHeight(): number;\n    /**\n     * 获取Extent的大小 - 高度和宽度构造的 Size 对象\n     *\n     * @english\n     * Get size of the Extent\n     */\n    getSize(): Size;\n    /**\n     * 设置 extent 的边界值\n     *\n     * @english\n     *\n     * set extent value\n     *\n     * @param xmin\n     * @param ymin\n     * @param xmax\n     * @param ymax\n     */\n    set(xmin: WithNull<number>, ymin: WithNull<number>, xmax: WithNull<number>, ymax: WithNull<number>): this;\n    __combine(extent: Position | Extent | PointExtent): number[];\n    /**\n     * 与其他 extent 合并\n     * @english\n     * Combine it with another extent to a larger extent.\n     * @param extent - extent/coordinate/point to combine into\n     * @returns extent combined\n     */\n    _combine(extent: Position | Extent | PointExtent): this;\n    /**\n     * 与其他 extent 合并到一个更大的 extent，返回一个新 extent\n     * @english\n     * Combine it with another extent to a larger extent.\n     * @param extent - extent/coordinate/point to combine into\n     * @returns extent combined\n     */\n    combine(extent: Position | Extent | PointExtent): any;\n    /**\n     * 获取当前 extent 与另一个 extent 的交集范围\n     *\n     * @english\n     *\n     * Gets the intersection extent of this and another extent.\n     * @param extent - another extent\n     * @returns intersection extent\n     */\n    intersection(extent: Extent | PointExtent): any;\n    /**\n     * 扩大 extent，返回一个新 Extent\n     * @english\n     *\n     * Expand the extent by distance\n     * @param distance  - distance to expand\n     * @returns a new extent expanded from\n     */\n    expand(distance: number | Size): PointExtent | Extent;\n    /**\n     * 扩大 extent\n     * @english\n     * Expand the extent by distance\n     * @param distance  - distance to expand\n     */\n    _expand(distance: number | Size): this;\n    /**\n     * 获取 extent 的 JSON 对象。\n     *\n     * @english\n     * Get extent's JSON object.\n     * @returns jsonObject\n     * @example\n     *\n     * ```ts\n     * // {xmin : 100, ymin: 10, xmax: 120, ymax:20}\n     * var json = extent.toJSON();\n     * ```\n     */\n    toJSON(): JsonExtent;\n    /**\n     * 获取extent矩形区域的坐标数组，包含5个坐标，第一个坐标与最后一个坐标相等。\n     * @english\n     * Get a coordinate array of extent's rectangle area, containing 5 coordinates in which the first equals with the last.\n     * @returns coordinates array\n     */\n    toArray(out?: Position[]): Position[];\n    /**\n     * 获取 extent 的 xmin、ymin、xmax、ymax 组成的字符串\n     *\n     * @english\n     *\n     * Get the string consisting of xmin, ymin, xmax, and ymax of extent\n     */\n    toString(): string;\n    /**\n     * 复制 extent\n     *\n     * @english\n     *\n     * Get a copy of the extent.\n     * @returns copy\n     */\n    copy(): PointExtent | Extent;\n    /**\n     * 转换到新的 extent\n     *\n     * @english\n     *\n     * Convert to a new extent\n     * @param fn convert function on each point\n     * @param out temp out\n     */\n    convertTo(fn: (p: Point) => Point, out?: Extent | PointExtent): Extent | PointExtent;\n    convertTo(fn: (p: Coordinate) => Coordinate, out?: Extent | PointExtent): Extent | PointExtent;\n    /**\n     * 计算给定 Extent 的投影范围\n     *\n     * @english\n     *\n     * Calculate the projected range of the given Extent\n     * @param ext extent\n     */\n    _project(ext: Extent | PointExtent): void;\n}\nexport default Extent;\n"},{"path":"geo/index.d.ts","content":"export { default as Coordinate } from './Coordinate';\nexport { default as CRS } from './CRS';\nexport { default as Extent } from './Extent';\nexport { default as Point } from './Point';\nexport { default as PointExtent } from './PointExtent';\nexport { default as Size } from './Size';\nexport { default as Transformation } from './transformation/Transformation';\nimport * as projection from './projection';\nimport * as measurer from './measurer';\nexport { projection, measurer };\n"},{"path":"geo/measurer/Common.d.ts","content":"import Coordinate from '../Coordinate';\ndeclare const common: {\n    /**\n     * 测量两点之间的距离\n     *\n     * @english\n     * Measure length between coordinate c1 and coordinate c2\n     * @param c1 coordinate\n     * @param c2 coordinate\n     * @returns length\n     */\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport type CommonMeasurer = typeof common;\n/**\n * 这提供了用于通用测量器的方法。 它是一个 mixin，不适合直接使用。\n * @english\n * This provides methods used for common measurer. It's a mixin and not meant to be used directly.\n * @mixin Common\n * @group measurer\n * @protected\n */\nexport default common;\n"},{"path":"geo/measurer/Identity.d.ts","content":"import Coordinate, { CoordinateJson } from '../Coordinate';\nimport type { WithNull } from '../../types/typings';\ndeclare const extended: {\n    /**\n     * the code of the measurer\n     */\n    measure: string;\n    /**\n     * 计算两个坐标之间的距离\n     *\n     * @english\n     * Measure the length between 2 coordinates.\n     * @param c1\n     * @param c2\n     */\n    measureLenBetween: (c1: Coordinate | CoordinateJson, c2: Coordinate | CoordinateJson) => number;\n    /**\n     * 测量给定闭合坐标的面积\n     *\n     * @english\n     * Measure the area closed by the given coordinates.\n     * @param coordinates\n     */\n    measureArea: (coordinates: (Coordinate | CoordinateJson)[]) => number;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c\n     * @param xDist\n     * @param yDist\n     * @param out\n     */\n    locate: (c: Coordinate | CoordinateJson, xDist: number, yDist: number, out?: Coordinate) => any;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标（这是一个私有方法）\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c     - source coordinate\n     * @param xDist     - x-axis distance\n     * @param yDist     - y-axis distance\n     * @private\n     */\n    _locate: (c: Coordinate, xDist: number, yDist: number) => WithNull<Coordinate>;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     *\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     */\n    rotate: (c: Coordinate | CoordinateJson, pivot: Coordinate, angle: number) => any;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     *\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     * @private\n     */\n    _rotate: (c: Coordinate, pivot: Coordinate, angle: number) => Coordinate;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport type IdentityMeasurerType = typeof extended;\n/**\n * Identity 的measurer，适用于笛卡尔坐标系\n * @english\n * Identity measurer, a measurer for Cartesian coordinate system.\n *\n * @category geo\n * @protected\n * @group measurer\n * @module Identity\n * {@inheritDoc measurer.Common}\n */\nexport default extended;\n"},{"path":"geo/measurer/index.d.ts","content":"/** @namespace measurer */\nimport Identity, { type IdentityMeasurerType } from './Identity';\nimport { type WGS84SphereType, type BaiduSphereType } from './Sphere';\nexport { Identity, IdentityMeasurerType };\nexport * from './Sphere';\n/**\n * 默认 measurer, [WGS84Sphere]{@link WGS84Sphere}\n * @english\n * Default measurer, [WGS84Sphere]{@link WGS84Sphere}\n *\n * @category geo\n * @protected\n * @group measurer\n * @module DEFAULT\n * {@inheritDoc measurer.WGS84Sphere}\n */\nexport declare const DEFAULT: {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n    };\n    measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n    measureArea(coordinates: import(\"src\").Coordinate[]): number;\n    _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n    _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n};\n/**\n * 带有测量功能的方法，不能直接初始化。\n * Measurer提供了地理计算的方法，例如长度和面积测量等。\n *\n * @english\n * Utilities with measurers. It is static and should not be initiated.<br>\n * Measurer provides methods for geographical computations such as length and area measuring, etc.\n * @module Measurer\n * @group measurer\n * @category geo\n */\nexport declare const Measurer: {\n    /**\n     * 获取量测计算的实例\n     *\n     * @english\n     * Get a measurer instance.\n     * @param name - code of the measurer: 'EPSG:4326', 'Identity', 'BAIDU'\n     * @returns a measurer object\n     * @function Measurer.getInstance\n     */\n    getInstance(name?: string): IdentityMeasurerType | WGS84SphereType | BaiduSphereType;\n};\n"},{"path":"geo/measurer/Sphere.d.ts","content":"import Coordinate, { type CoordinateJson } from '../Coordinate';\nimport type { WithNull } from '../../types/typings';\ntype CoordsLike = Coordinate | CoordinateJson;\n/**\n * 具有 Sphere 通用测量方法的辅助类。\n *\n * @english\n * A helper class with common measure methods for Sphere.\n * @group measurer\n * @private\n */\ndeclare class Sphere {\n    radius: number;\n    /**\n     * @param radius Sphere's radius\n     */\n    constructor(radius: number);\n    /**\n     * 计算两个坐标之间的距离\n     *\n     * @english\n     * Measure the length between 2 coordinates.\n     * @param c1\n     * @param c2\n     */\n    measureLenBetween(c1: CoordsLike, c2: CoordsLike): number;\n    /**\n     * 测量给定闭合坐标的面积\n     *\n     * @english\n     * Measure the area closed by the given coordinates.\n     * @param coordinates\n     */\n    measureArea(coordinates: CoordsLike[]): number;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c\n     * @param xDist\n     * @param yDist\n     * @param out\n     */\n    locate(c: CoordsLike, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c     - source coordinate\n     * @param xDist     - x-axis distance\n     * @param yDist     - y-axis distance\n     * @private\n     */\n    _locate(c: Coordinate, xDist: number, yDist: number): WithNull<Coordinate>;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     */\n    rotate(c: CoordsLike, pivot: Coordinate, angle: number): Coordinate;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     * @private\n     */\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n}\n/**\n * WGS84 椭球球体\n * @english\n * WGS84 Sphere measurer.\n * @category geo\n * @protected\n * @group measurer\n * @module WGS84Sphere\n * {@inheritDoc measurer.Common}\n */\nexport declare const WGS84Sphere: {\n    measure: string;\n    sphere: Sphere;\n    /**\n     * 计算两个坐标之间的距离\n     *\n     * @english\n     * Measure the length between 2 coordinates.\n     * @param c1\n     * @param c2\n     */\n    measureLenBetween(c1: CoordsLike, c2: CoordsLike): number;\n    /**\n     * 计算给定闭合坐标的面积\n     *\n     * @english\n     * Measure the area closed by the given coordinates.\n     * @param coordinates\n     */\n    measureArea(coordinates: Coordinate[]): number;\n    _locate(c: CoordsLike, xDist: number, yDist: number): any;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标。\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c - source coordinate\n     * @param xDist - x-axis distance\n     * @param yDist - y-axis distance\n     * @param out - out\n     */\n    locate(c: CoordsLike, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     */\n    rotate(c: CoordsLike, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\n/**\n * 百度地图所使用的椭球体\n *\n * @english\n * Baidu sphere measurer\n * @category geo\n * @protected\n * @group measurer\n * @module BaiduSphere\n * {@inheritDoc measurer.Common}\n */\nexport declare const BaiduSphere: {\n    measure: string;\n    sphere: Sphere;\n    /**\n     * 计算两个坐标之间的距离\n     *\n     * @english\n     * Measure the length between 2 coordinates.\n     * @param c1\n     * @param c2\n     */\n    measureLenBetween(c1: CoordsLike, c2: CoordsLike): number;\n    /**\n     * 计算给定闭合坐标的面积\n     *\n     * @english\n     * Measure the area closed by the given coordinates.\n     * @param coordinates\n     */\n    measureArea(coordinates: CoordsLike[]): number;\n    _locate(c: Coordinate, xDist: number, yDist: number): any;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标。\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c - source coordinate\n     * @param xDist - x-axis distance\n     * @param yDist - y-axis distance\n     * @param out - out\n     */\n    locate(c: CoordsLike, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     */\n    rotate(c: CoordsLike, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport type BaiduSphereType = typeof BaiduSphere;\nexport type WGS84SphereType = typeof WGS84Sphere;\nexport {};\n"},{"path":"geo/Point.d.ts","content":"import Position from './Position';\nexport type PointJson = {\n    x: number;\n    y: number;\n    z?: number;\n};\nexport type PointArray = [number, number] | [number, number, number];\nexport type PointLike = Point | PointJson | PointArray;\n/**\n * 2D 点实现\n * @english\n * Represents a 2d point.<br>\n * Can be created in serveral ways:\n *\n * @example\n *\n * ```ts\n *\n * var point = new Point(1000, 1000);\n *\n * var point = new Point([1000, 1000]);\n *\n * var point = new Point({ x:1000, y:1000 });\n * ```\n *\n * @category basic types\n */\ndeclare class Point extends Position {\n    /**\n     * 使用差值与另一个点进行比较，判断是否临近\n     *\n     * @english\n     *\n     * Compare with another point with a delta\n     * @param p\n     * @param delta\n     */\n    closeTo(p: Point, delta?: number): boolean;\n    /**\n     * 计算对应的单位向量\n     * 这意味着计算点到[0, 0]坐标的距离将等于1，并且从计算点到[0, 0]坐标的角度与之前相同\n     * @english\n     *\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @returns unit vector point\n     */\n    unit(): Point;\n    _unit(): this;\n    /**\n     * 计算一个垂直点，其中新的y坐标是旧的x坐标，而新的x坐标是旧的y坐标乘以-1。\n     *\n     * @english\n     *\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @returns perpendicular point\n     */\n    perp(): Point;\n    _perp(): this;\n    /**\n     * 获取这个点与另一个点之间的角度，单位为弧度\n     *\n     * @english\n     *\n     * Get the angle between this point and another point, in radians\n     * from mapbox/point-geometry\n     * @param b - the other point\n     * @returns angle\n     */\n    angleWith(b: Point): number;\n    /**\n     * 找到两个向量之间的角度\n     *\n     * @english\n     *\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin(θ) for θ.\n     * from mapbox/point-geometry\n     *\n     * @param x the x-coordinate\n     * @param y the y-coordinate\n     * @returns the angle in radians\n     */\n    angleWithSep(x: number, y: number): number;\n    _rotate(angle: number): this;\n    /**\n     * 围绕0,0原点旋转这个点，旋转角度a以弧度为单位\n     *\n     * @english\n     *\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * from mapbox/point-geometry\n     *\n     * @param a angle to rotate around, in radians\n     * @returns output point\n     */\n    rotate(a: number): Point;\n    /**\n     * 返回该点绝对值的 `Point` 对象（不会改变原始数据）\n     *\n     * @english\n     *\n     * Return abs value of the point\n     * @returns abs point\n     */\n    abs(): Point;\n    /**\n     * 类似于数学中的四舍五入，对点的 x 和 y 坐标进行舍入，返回一个新 Point\n     *\n     * @english\n     *\n     * Like math.round, rounding the point's xy.\n     * @returns rounded point\n     */\n    round(): Point;\n    /**\n     * 对点的 x 和 y 坐标向上取整，返回一个新 Point\n     *\n     * @english\n     *\n     * Like math.ceil, ceil the point's xy.\n     * @returns ceiled point\n     */\n    ceil(): Point;\n    /**\n     * 对点的 x 和 y 坐标向下取整，返回一个新 Point\n     *\n     * @english\n     *\n     * Like math.floor, floor the point's xy.\n     * @returns floored point\n     */\n    floor(): Point;\n    /**\n     * 返回当前点的 copy\n     *\n     * @english\n     *\n     * Returns a copy of the point\n     * @returns copy\n     */\n    copy(): Point;\n    /**\n     * 坐标数字保留指定位数的小数\n     *\n     * @english\n     *\n     * Formats point number using fixed-point notation.\n     * @param n - The number of digits to appear after the decimal point\n     * @returns fixed point\n     */\n    toFixed(n: number): Point;\n    /**\n     * 与传入坐标相加，返回一个新 Point\n     *\n     * @english\n     *\n     * Returns the result of addition of another coordinate.\n     * @param x - point to add\n     * @returns result\n     */\n    add(x: PointLike): Point;\n    /**\n     * 与传入坐标相加，返回一个新 Point\n     *\n     * @english\n     *\n     * Returns the result of addition of another coordinate.\n     * @param x - point to add\n     * @param y - point to add\n     * @returns result\n     */\n    add(x: number, y: number): Point;\n    /**\n     * 与传入坐标相减，返回一个新 Point。\n     *\n     * @english\n     *\n     * Returns the result of subtraction of another point.\n     * @param x - point to add\n     * @returns result\n     */\n    sub(x: PointLike): Point;\n    /**\n     * 与传入坐标相减，返回一个新 Point。\n     *\n     * @english\n     *\n     * Returns the result of subtraction of another point.\n     * @param x - point to add\n     * @param y - point to add\n     * @returns result\n     */\n    sub(x: number, y: number): Point;\n    /**\n     * Returns the result of multiplication of the current coordinate by the given number.\n     * @param ratio - ratio to multi\n     * @returns result\n     */\n    multi(ratio: number): Point;\n    /**\n     * 与另外一个 point 进行比较，以查看它们是否相等\n     *\n     * @english\n     *\n     * Compare with another point to see whether they are equal.\n     * @param c - point to compare\n     */\n    equals(c: Point): boolean;\n}\nexport default Point;\n"},{"path":"geo/PointExtent.d.ts","content":"import Extent, { ExtentLike, Position, Projection } from './Extent';\nimport type { WithNull } from '../types/typings';\n/**\n * 表示二维表面上的边界框，即具有最小点和最大点的矩形区域。 <br>\n * 有多种方法可以创建 PointExtent：\n *\n * @english\n * Represent a bounding box on 2d surface , a rectangular area with minimum and maximum points. <br>\n * There are serveral ways to create a PointExtent:\n * @category basic types\n * @example\n *\n * ```ts\n * // with 4 numbers\n * var extent = new PointExtent(100, 10, 120, 20);\n *\n * // with 2 points\n * var extent = new PointExtent(new Point(100, 10), new Point(120, 20));\n *\n * // with a json object containing xmin, ymin, xmax and ymax\n * var extent = new PointExtent({xmin : 100, ymin: 10, xmax: 120, ymax:20});\n *\n * var extent1 = new PointExtent(100, 10, 120, 20);\n * // with another extent\n * var extent2 = new PointExtent(extent1);\n * ```\n */\ndeclare class PointExtent extends Extent {\n    constructor(p1?: WithNull<ExtentLike>, p?: Projection);\n    constructor(p1: Position, p2: Position, p?: Projection);\n    constructor(p1: number, p2: number, p3: number, p4: number, p?: Projection);\n}\nexport default PointExtent;\n"},{"path":"geo/Position.d.ts","content":"import type Point from './Point';\nimport type { PointArray, PointJson } from './Point';\nimport type Coordinate from './Coordinate';\nimport type { CoordinateArray, CoordinateJson } from './Coordinate';\nimport type { WithUndef } from '../types/typings';\ntype NumberAble = number | string;\nexport type PositionJson<T> = {\n    x: T;\n    y: T;\n    z?: T;\n};\nexport type PositionArray<T> = [T, T] | [T, T, T];\nexport type PositionLike = Point | Coordinate | PositionJson<NumberAble> | PointJson | CoordinateJson;\n/**\n * `Point` 和 `Coordinate` 的抽象类\n * @english\n *\n * Abstract parent class for Point and Coordinate\n * @category basic types\n */\ndeclare abstract class Position {\n    x: number;\n    y: number;\n    z: WithUndef<number>;\n    constructor(x: PositionLike);\n    constructor(x: PositionArray<NumberAble>);\n    constructor(x: PointArray);\n    constructor(x: CoordinateArray);\n    constructor(x: NumberAble, y: NumberAble, z?: NumberAble);\n    /**\n     * 设置点或坐标的 x、y 值\n     *\n     * @english\n     *\n     * Set point or coordinate's x, y value\n     * @param x - x value\n     * @param y - y value\n     * @param z - z value\n     */\n    set(x: number, y: number, z?: number): this;\n    abstract abs(): Point | Coordinate;\n    /**\n     * 修改原数据的绝对值\n     *\n     * @english\n     * destructive abs\n     */\n    _abs(): this;\n    /**\n     * 对原数据的 x 和 y 四舍五入\n     *\n     * @english\n     * destructive round\n     */\n    _round(): this;\n    abstract round(): Point | Coordinate;\n    /**\n     * 对原数据的 x 和 y 进行向上取整\n     *\n     * @english\n     * destructive ceil\n     */\n    _ceil(): this;\n    abstract ceil(): Point | Coordinate;\n    /**\n     * 返回当前点与给定点之间的距离\n     *\n     * @english\n     *\n     * Returns the distance between the current and the given point.\n     * @param  point - another point\n     * @returns distance\n     */\n    distanceTo(point: Point | Coordinate): number;\n    /**\n     * 返回该点的大小：这是从 0,0 坐标到该点的 x 和 y 坐标的欧几里得距离\n     *\n     * @english\n     *\n     * Return the magnitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @returns magnitude\n     */\n    mag(): number;\n    /**\n     * 对原数据的 x 和 y 进行向下取整\n     *\n     * @english\n     * destructive floor\n     */\n    _floor(): this;\n    abstract floor(): Point | Coordinate;\n    abstract copy(): Point | Coordinate;\n    _add(x: PositionLike): this;\n    _add(x: number, y: number): this;\n    abstract add(x: any, y?: number): Point | Coordinate;\n    _sub(x: PositionLike): this;\n    _sub(x: number, y: number): this;\n    /**\n     * `_sub` 方法的别名\n     *\n     * @english\n     *\n     * Alias for _sub\n     *\n     * @param x\n     * @param y\n     */\n    _substract(x: PositionLike | number, y?: number): this;\n    abstract sub(x: any, y?: number): Point | Coordinate;\n    /**\n     * `sub` 方法的别名。\n     *\n     * @english\n     *\n     * Alias for sub\n     * @returns result\n     * @param x\n     * @param y\n     */\n    substract(x: PositionLike | number, y?: number): Coordinate | Point;\n    abstract multi(ratio: number): Point | Coordinate;\n    _multi(ratio: number): this;\n    /**\n     * 返回当前坐标除以给定数字\n     *\n     * @english\n     *\n     * Returns the result of division of the current point by the given number.\n     * @param n - number to div\n     * @returns result\n     */\n    div(n: number): Coordinate | Point;\n    /**\n     * 除以给定的数字\n     *\n     * @english\n     *\n     * div by the given number\n     * @param n\n     */\n    _div(n: number): this;\n    abstract equals(c: Point | Coordinate): boolean;\n    /**\n     * `Coordinate` / `Point`是否是 `NaN`\n     *\n     * @english\n     *\n     * Whether the coordinate is NaN\n     * @returns\n     */\n    _isNaN(): boolean;\n    /**\n     * `Coordinate` / `Point`是否为零\n     *\n     * @english\n     *\n     * Whether the coordinate/point is zero\n     */\n    isZero(): boolean;\n    /**\n     * 转换为数组形式\n     *\n     * @english\n     *\n     * Convert to a number array [x, y]\n     * @returns number array\n     */\n    toArray(): PositionArray<number>;\n    /**\n     * 坐标数字保留指定位数的小数\n     *\n     * @english\n     *\n     * Formats coordinate number using fixed-point notation.\n     * @param n - The number of digits to appear after the decimal point\n     * @returns fixed coordinate\n     */\n    abstract toFixed(n: number): Point | Coordinate;\n    /**\n     * 转换到 json 对象\n     *\n     * @english\n     * Convert to a json object {x : .., y : ..}\n     * @returns json\n     */\n    toJSON(): PositionJson<number>;\n}\nexport default Position;\n"},{"path":"geo/projection/etmerc.d.ts","content":"declare function pj_etmerc(P: any): void;\nexport default pj_etmerc;\n"},{"path":"geo/projection/index.d.ts","content":"/** @namespace projection */\nimport EPSG3857, { type EPSG3857ProjectionType } from './Projection.EPSG3857';\nimport type { EPSG4326ProjectionType } from './Projection.EPSG4326';\nimport type { EPSG9807ProjectionType } from './Projection.EPSG9807';\nimport type { BAIDUProjectionType } from './Projection.Baidu';\nimport type { UTMProjectionType } from './Projection.UTM';\nimport type { IdentityProjectionType } from './Projection.IDENTITY';\nexport { default as EPSG4326, EPSG4326ProjectionType } from './Projection.EPSG4326';\nexport { default as EPSG9807, EPSG9807ProjectionParams, EPSG9807ProjectionType } from './Projection.EPSG9807';\nexport { default as UTM, UTMProjectionParams, UTMProjectionType } from './Projection.UTM';\nexport { default as BAIDU, BAIDUProjectionType } from './Projection.Baidu';\nexport { default as IDENTITY, IdentityProjectionType } from './Projection.IDENTITY';\nexport { EPSG3857, EPSG3857ProjectionType };\nexport { default as Common, CommonProjectionType } from './Projection';\nexport type ProjectionType = EPSG3857ProjectionType | EPSG4326ProjectionType | EPSG9807ProjectionType | BAIDUProjectionType | UTMProjectionType | IdentityProjectionType;\n/**\n * 默认投影, [EPSG3857]{@link projection.EPSG3857}\n * @english\n * Default projection, [EPSG3857]{@link projection.EPSG3857}\n *\n * @category geo\n * @protected\n * @group projection\n * @module DEFAULT\n * {@inheritDoc projection.EPSG3857}\n */\nexport declare const DEFAULT: {\n    code: string;\n    is(code: string): boolean;\n    project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n    unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n    wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    code: string;\n    rad: number;\n    metersPerDegree: number;\n    maxLatitude: number;\n    project: (lnglat: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n    unproject: (pLnglat: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n} & {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n    };\n    measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n    measureArea(coordinates: import(\"src\").Coordinate[]): number;\n    _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n    _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n};\n"},{"path":"geo/projection/Projection.Baidu.d.ts","content":"import { type CommonProjectionType } from './Projection';\nimport Coordinate from '../Coordinate';\nimport { BaiduSphereType } from '../measurer';\ndeclare const ProjectionMethods: {\n    EARTHRADIUS: number;\n    MCBAND: number[];\n    LLBAND: number[];\n    MC2LL: number[][];\n    LL2MC: number[][];\n    convertMC2LL: (cB: Coordinate, out?: Coordinate) => Coordinate;\n    convertLL2MC: (T: Coordinate, out?: Coordinate) => Coordinate;\n    convertor: (cC: Coordinate, cD: number, out?: Coordinate) => Coordinate;\n    toRadians: (T: number) => number;\n    toDegrees: (T: number) => number;\n    getRange: (cC: number, cB: number, T: number) => number;\n    getLoop: (cC: number, cB: number, T: number) => number;\n};\ndeclare const BAIDUProjection: {\n    /**\n     * \"BAIDU\", Code of the projection\n     * @constant\n     */\n    code: string;\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n};\nexport type BAIDUProjectionType = CommonProjectionType & typeof BAIDUProjection & BaiduSphereType & typeof ProjectionMethods;\n/**\n * 百度地图所使用的投影 [Baidu Map]{@link http://map.baidu.com}\n *\n * @english\n * Projection used by [Baidu Map]{@link http://map.baidu.com}\n *\n * @category geo\n * @protected\n * @group projection\n * @name BAIDU\n * {@inheritDoc projection.Common}\n * {@inheritDoc BaiduSphere}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    /**\n     * \"BAIDU\", Code of the projection\n     * @constant\n     */\n    code: string;\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n} & {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n        _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n    };\n    measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n    measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number;\n    _locate(c: Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n} & {\n    EARTHRADIUS: number;\n    MCBAND: number[];\n    LLBAND: number[];\n    MC2LL: number[][];\n    LL2MC: number[][];\n    convertMC2LL: (cB: Coordinate, out?: Coordinate) => Coordinate;\n    convertLL2MC: (T: Coordinate, out?: Coordinate) => Coordinate;\n    convertor: (cC: Coordinate, cD: number, out?: Coordinate) => Coordinate;\n    toRadians: (T: number) => number;\n    toDegrees: (T: number) => number;\n    getRange: (cC: number, cB: number, T: number) => number;\n    getLoop: (cC: number, cB: number, T: number) => number;\n};\nexport default _default;\n"},{"path":"geo/projection/Projection.d.ts","content":"import Coordinate from '../Coordinate';\nimport Extent from '../Extent';\ndeclare const CommonProjection: {\n    code: string;\n    is(code: string): boolean;\n    /**\n     * 将地理坐标投影到投影坐标（二维坐标）\n     * @english\n     * Project a geographical coordinate to a projected coordinate (2d coordinate)\n     * @param p - coordinate to project\n     * @function projection.Common.project\n     */\n    project(p: Coordinate): Coordinate;\n    /**\n     * 将投影坐标转到地理坐标（二维坐标）\n     *\n     * @english\n     * Unproject a projected coordinate to a geographical coordinate (2d coordinate)\n     * @param p - coordinate to project\n     * @function projection.Common.unproject\n     */\n    unproject(p: Coordinate): Coordinate;\n    /**\n     * 批量将地理坐标投影到投影坐标\n     *\n     * @english\n     * Project a group of geographical coordinates to projected coordinates.\n     * @param coordinates - coordinates to project\n     * @function projection.Common.projectCoords\n     */\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    /**\n     * 批量将投影坐标转到地理坐标\n     *\n     * @english\n     * Unproject a group of projected coordinates to geographical coordinates.\n     * @param projCoords - projected coordinates to unproject\n     * @function projection.Common.unprojectCoords\n     */\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    /**\n     * 投影是否为球面\n     *\n     * @english\n     * Whether the projection is spherical\n     */\n    isSphere(): boolean;\n    /**\n     * 判断传入的投影坐标是否超出椭球体范围\n     *\n     * @english\n     * If the projected coord out of the sphere\n     * @param pcoord projected coord\n     * @return {Boolean}\n     */\n    isOutSphere(pcoord: Coordinate): boolean;\n    /**\n     * 限制投影坐标在球体中\n     *\n     * @english\n     * Wrap the projected coord in the sphere\n     * @param pcoord projected coord\n     * @returns wrapped projected coord\n     */\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): Extent;\n};\nexport type CommonProjectionType = typeof CommonProjection;\n/**\n * 投影公共方法\n * @english\n * Common Methods of Projections.\n * @protected\n * @group projection\n * @namespace Common\n */\nexport default CommonProjection;\n"},{"path":"geo/projection/Projection.EPSG3857.d.ts","content":"import { type CommonProjectionType } from './Projection';\nimport Coordinate from '../Coordinate';\nimport { type WGS84SphereType } from '../measurer';\ndeclare const EPSG3857Projection: {\n    /**\n     * \"EPSG:3857\", Code of the projection\n     * @constant\n     */\n    code: string;\n    rad: number;\n    metersPerDegree: number;\n    maxLatitude: number;\n    project: (lnglat: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (pLnglat: Coordinate, out?: Coordinate) => Coordinate;\n};\nexport type EPSG3857ProjectionType = CommonProjectionType & typeof EPSG3857Projection & WGS84SphereType;\n/**\n * Google 地图或 OSM 地图使用的常规投影，又名墨卡托投影。<br>\n * 这是地图的默认投影。\n *\n * @english\n * Well-known projection used by Google maps or Open Street Maps, aka Mercator Projection.<br>\n * It is map's default projection.\n *\n * @category geo\n * @protected\n * @group projection\n * @name EPSG3857\n * {@inheritDoc projection.Common}\n * {@inheritDoc measurer.WGS84Sphere}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    /**\n     * \"EPSG:3857\", Code of the projection\n     * @constant\n     */\n    code: string;\n    rad: number;\n    metersPerDegree: number;\n    maxLatitude: number;\n    project: (lnglat: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (pLnglat: Coordinate, out?: Coordinate) => Coordinate;\n} & {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n        _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n    };\n    measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n    measureArea(coordinates: Coordinate[]): number;\n    _locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport default _default;\n"},{"path":"geo/projection/Projection.EPSG4326.d.ts","content":"import { type CommonProjectionType } from './Projection';\nimport Coordinate from '../Coordinate';\nimport { type WGS84SphereType } from '../measurer';\ndeclare const EPSG4326Projection: {\n    /**\n     * \"EPSG:4326\", Code of the projection\n     * @constant\n     */\n    code: string;\n    aliases: string[];\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n};\nexport type EPSG4326ProjectionType = CommonProjectionType & typeof EPSG4326Projection & WGS84SphereType;\n/**\n * GIS 中常见的 CRS。 使用简单的等距矩形投影\n *\n * @english\n * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\n *\n * @category geo\n * @protected\n * @group projection\n * @name EPSG4326\n * {@inheritDoc projection.Common}\n * {@inheritDoc measurer.WGS84Sphere}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    /**\n     * \"EPSG:4326\", Code of the projection\n     * @constant\n     */\n    code: string;\n    aliases: string[];\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n} & {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n        _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n    };\n    measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n    measureArea(coordinates: Coordinate[]): number;\n    _locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport default _default;\n"},{"path":"geo/projection/Projection.EPSG9807.d.ts","content":"import { type CommonProjectionType } from './Projection';\nimport Coordinate from '../Coordinate';\nexport interface EPSG9807ProjectionParams {\n    falseEasting: number;\n    falseNorthing: number;\n    scaleFactor: number;\n    centralMeridian: number;\n    latitudeOfOrigin: number;\n    startLongtitude: number;\n    startLatitude: number;\n}\ndeclare const EPSG9807Projection: {\n    code: string;\n    aliases: string[];\n    centralMeridian: number;\n    create(params: Partial<EPSG9807ProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: Coordinate): Coordinate;\n        unproject(p: Coordinate): Coordinate;\n        projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n        unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: Coordinate): boolean;\n        wrapCoord(pcoord: Coordinate): Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        /**\n         * \"EPSG:9807\", Code of the projection\n         * @type {String}\n         * @constant\n         */\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: Coordinate, out?: Coordinate) => Coordinate;\n        unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n            measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number; /**\n             * \"EPSG:9807\", Code of the projection\n             * @type {String}\n             * @constant\n             */\n            locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n            _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n            rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n            _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        };\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: Coordinate[]): number;\n        _locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: Coordinate, c2: Coordinate) => number;\n    };\n};\nexport type EPSG9807ProjectionType = CommonProjectionType & typeof EPSG9807Projection;\n/**\n * 横轴墨卡托投影\n *\n * @english\n * Traverse Mercator Projection\n *\n * @category geo\n * @protected\n * @group projection\n * @name EPSG9807\n * {@inheritDoc projection.Common}\n * {@inheritDoc measurer.WGS84Sphere}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    code: string;\n    aliases: string[];\n    centralMeridian: number;\n    create(params: Partial<EPSG9807ProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: Coordinate): Coordinate;\n        unproject(p: Coordinate): Coordinate;\n        projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n        unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: Coordinate): boolean;\n        wrapCoord(pcoord: Coordinate): Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        /**\n         * \"EPSG:9807\", Code of the projection\n         * @type {String}\n         * @constant\n         */\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: Coordinate, out?: Coordinate) => Coordinate;\n        unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n            measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number; /**\n             * \"EPSG:9807\", Code of the projection\n             * @type {String}\n             * @constant\n             */\n            locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n            _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n            rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n            _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        };\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: Coordinate[]): number;\n        _locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: Coordinate, c2: Coordinate) => number;\n    };\n};\nexport default _default;\n"},{"path":"geo/projection/Projection.IDENTITY.d.ts","content":"import Coordinate from '../Coordinate';\nimport { type CommonProjectionType } from './Projection';\nimport { type IdentityMeasurerType } from '../measurer';\ndeclare const IdentityProjection: {\n    /**\n     * \"IDENTITY\", Code of the projection\n     * @constant\n     */\n    code: string;\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n};\nexport type IdentityProjectionType = CommonProjectionType & typeof IdentityProjection & IdentityMeasurerType;\n/**\n * 基于笛卡尔坐标系的投影。<br>\n * 该投影直接映射 x、y，常用于平面地图（例如室内地图、游戏地图）。\n *\n * @english\n * A projection based on Cartesian coordinate system.<br>\n * This projection maps x, y directly, it is useful for maps of flat surfaces (e.g. indoor maps, game maps).\n *\n * @category geo\n * @protected\n * @group projection\n * @name IDENTITY\n * {@inheritDoc projection.Common}\n * {@inheritDoc measurer.Identity}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    /**\n     * \"IDENTITY\", Code of the projection\n     * @constant\n     */\n    code: string;\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n} & {\n    measure: string;\n    measureLenBetween: (c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate) => number;\n    measureArea: (coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]) => number;\n    locate: (c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate) => any;\n    _locate: (c: Coordinate, xDist: number, yDist: number) => Coordinate;\n    rotate: (c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number) => any;\n    _rotate: (c: Coordinate, pivot: Coordinate, angle: number) => Coordinate;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport default _default;\n"},{"path":"geo/projection/Projection.UTM.d.ts","content":"import { type EPSG9807ProjectionType } from './Projection.EPSG9807';\nexport interface UTMProjectionParams {\n    zone: string;\n    south: boolean;\n}\ndeclare const UTMProjection: {\n    /**\n     * \"EPSG:4490\", Code of the projection\n     * @constant\n     */\n    code: string;\n    aliases: any[];\n    create(params: Partial<UTMProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n        wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n        unproject: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n            measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n            locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n            _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n            rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n            _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        };\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: import(\"src\").Coordinate[]): number;\n        _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n    };\n};\nexport type UTMProjectionType = EPSG9807ProjectionType & typeof UTMProjection;\n/**\n * Universal Traverse Mercator projection\n *\n * @class\n * @category geo\n * @protected\n * @memberOf projection\n * @name EPSG4490\n * {@inheritDoc projection.EPSG9807}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n    unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n    wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    code: string;\n    aliases: string[];\n    centralMeridian: number;\n    create(params: Partial<import(\"./Projection.EPSG9807\").EPSG9807ProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n        wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n        unproject: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n            measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n            locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n            _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n            rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n            _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        };\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: import(\"src\").Coordinate[]): number;\n        _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n    };\n} & {\n    /**\n     * \"EPSG:4490\", Code of the projection\n     * @constant\n     */\n    code: string;\n    aliases: any[];\n    create(params: Partial<UTMProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n        wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n        unproject: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n            measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n            locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n            _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n            rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n            _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        };\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: import(\"src\").Coordinate[]): number;\n        _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n    };\n};\nexport default _default;\n"},{"path":"geo/Size.d.ts","content":"import Point from './Point';\nexport type JsonSize = {\n    width: number;\n    height: number;\n};\nexport type ArraySize = [number, number];\n/**\n * A {@link Size} object\n *\n * @category basic types\n *\n * @example\n * ```ts\n * let size1 = new Size(100, 100);\n * let size2 = [100，100];\n * let size3 = { width: 100, height: 100 };\n * ```\n */\nexport type SizeLike = Size | JsonSize;\n/**\n * 表示一个大小的实现类\n *\n * @english\n * Represents a size.\n * @category basic types\n *\n * @example\n *\n * ```ts\n * const a1 = new Size(1, 2);\n * const a2 = new Size([1, 2]);\n * const a3 = new Size({ width: 1, height: 2 });\n * const a4 = new Size(a3);\n * ```\n */\ndeclare class Size {\n    width: number;\n    height: number;\n    /**\n     * @param width - width value\n     */\n    constructor(width: SizeLike);\n    /**\n     * @param width - width value\n     */\n    constructor(width: ArraySize);\n    /**\n     * @param width - width value\n     * @param height - height value\n     */\n    constructor(width: number, height: number);\n    /**\n     * 返回 `Size` 的拷贝\n     * @english\n     * Returns a copy of the size\n     */\n    copy(): Size;\n    /**\n     * @overload\n     *\n     * 返回当前`Size` 与另一个 `Size` 相加的结果\n     *\n     * @english\n     * Returns the result of addition of another size.\n     * @param x - Size\n     * @returns result\n     */\n    add(x: Size): Size;\n    /**\n     * @overload\n     *\n     * 返回当前`Size` 的 xy 与传入的 xy 相加的结果\n     *\n     * @english\n     * Returns the result of addition of another size.\n     * @param x - x\n     * @param y - y\n     * @returns result\n     */\n    add(x: number, y: number): Size;\n    /**\n     * 与另一个 `Size` 进行比较，以判断它们是否相等。\n     *\n     * @english\n     * Compare with another size to see whether they are equal.\n     * @param size - size to compare\n     */\n    equals(size: Size): boolean;\n    /**\n     * 返回当前大小与给定数字相乘的结果，返回一个新的 Size 对象\n     * @english\n     * Returns the result of multiplication of the current size by the given number.\n     * @param ratio - ratio to multi\n     * @returns result\n     */\n    multi(ratio: number): Size;\n    /**\n     * 返回当前大小与给定数字相乘的结果\n     * @english\n     * Returns the result of multiplication of the current size by the given number.\n     * @param ratio - ratio to multi\n     * @returns result\n     */\n    _multi(ratio: number): this;\n    _round(): this;\n    /**\n     * 将当前 `Size` 对象转为一个点对象 {@link Point}\n     * @english\n     * Converts the size object to a {@link Point}\n     * @returns point\n     */\n    toPoint(): Point;\n    /**\n     * 将 `Size` 对象转换为数组\n     * @english\n     * Converts the size object to an array [width, height]\n     */\n    toArray(): ArraySize;\n    /**\n     * 将 `Size` 实例对象转换为 包含 `width` 和 `height` 的 json 对象\n     * @english\n     * Convert the size object to a json object {width : ., height : .}\n     * @returns json\n     */\n    toJSON(): JsonSize;\n}\nexport default Size;\n"},{"path":"geo/transformation/Transformation.d.ts","content":"import Coordinate from '../Coordinate';\nimport Point from '../Point';\n/**\n * 投影坐标和基础二维点系统之间的转换。\n * 内部使用的核心类，用于将地图（通常是地理）坐标映射到 2d 点\n *\n * @english\n * Transformation between projected coordinates and base 2d point system.\n * A core class used internally for mapping map's (usually geographical) coordinates to 2d points.<br>\n *\n * @category geo\n * @protected\n */\ndeclare class Transformation {\n    matrix: number[];\n    /**\n     * The base 2d point system is a fixed system that is consistent with HTML coordinate system: on X-Axis, left is smaller and right is larger; on Y-Axis, top is smaller and bottom is larger. <br>\n     * As map's coordinates may not be in the same order(e.g. on a mercator projected earth, top is larger and bottom is smaller), <br>\n     * transformation provides mapping functions to map arbitrary coordinates system to the fixed 2d point system. <br>\n     * How to transform is decided by the constructor parameters which is a 4 number array [a, b, c, d]:<br>\n     * a : the order scale of X-axis values 1 means right is larger and -1 means the reverse, left is larger;<br>\n     * b : the order scale of Y-axis values 1 means bottom is larger and -1 means the reverse, top is larger;<br>\n     * c : x of the origin point of the projected coordinate system <br>\n     * d : y of the origin point of the projected coordinate system <br>\n     * e.g.: Transformation parameters for Google map: [1, -1, -20037508.34, 20037508.34] <br>\n     * @param  matrix transformation array\n     */\n    constructor(matrix: number[]);\n    /**\n     * 将投影坐标变换为二维点，\n     * 变换/非变换方法中的参数scale用于在地图的不同缩放级别上缩放结果2d点。\n     *\n     * @english\n     * Transform a projected coordinate to a 2d point. <br>\n     * Parameter scale in transform/untransform method is used to scale the result 2d points on map's different zoom levels.\n     * @param coordinates - projected coordinate to transform\n     * @param scale - transform scale\n     * @param out - tmp point\n     * @returns 2d point.\n     */\n    transform(coordinates: Coordinate, scale: number, out?: Point): Point;\n    /**\n     * 将 2d 点变换为投影坐标。\n     *\n     * @english\n     *\n     * Transform a 2d point to a projected coordinate.\n     * @param point - 2d point\n     * @param scale - transform scale\n     * @param out tmp coordinates\n     * @returns projected coordinate.\n     */\n    untransform(point: Point, scale: number, out?: Coordinate): Coordinate;\n}\nexport default Transformation;\n"},{"path":"geometry/ArcCurve.d.ts","content":"import Curve, { CurveOptionsType } from './Curve';\n/**\n * @classdesc\n * Circle Arc Curve\n * @category geometry\n * @extends Curve\n * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve\n * @param {Object} [options=null]   - construct options defined in [ArcCurve]{@link ArcCurve#options}\n * @example\n * var curve = new ArcCurve(\n *     [\n *         [121.47083767181408,31.214448123476995],\n *         [121.4751292062378,31.215475523000404],\n *         [121.47869117980943,31.211916269810335]\n *     ],\n *     {\n *         arcDegree : 120,\n *         symbol : {\n *             'lineWidth' : 5\n *         }\n *     }\n * ).addTo(layer);\n */\ndeclare class ArcCurve extends Curve {\n    _toJSON(options: any): any;\n    _paintOn(ctx: CanvasRenderingContext2D, points: any, lineOpacity: number): void;\n    static fromJSON(json: any): ArcCurve;\n}\nexport default ArcCurve;\nexport type ArcCurveOptionsType = CurveOptionsType & {\n    arcDegree?: number;\n};\n"},{"path":"geometry/CenterMixin.d.ts","content":"import { MixinConstructor } from '../core/Mixin';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport { CommonProjectionType } from '../geo/projection';\nimport type { Map } from '../map';\n/**\n * 基于几何图形的通用方法\n * @english\n * Common methods for geometry classes that base on a center, e.g. Marker, Circle, Ellipse , etc\n * @mixin CenterMixin\n */\nexport default function <T extends MixinConstructor>(Base: T): {\n    new (...args: any[]): {\n        _coordinates: Coordinate;\n        _pcenter: Coordinate;\n        _dirtyCoords: boolean;\n        getMap?(): Map;\n        _getProjection?(): CommonProjectionType;\n        onPositionChanged?(): void;\n        _verifyProjection?(): void;\n        _clearCache?(): void;\n        /**\n         * 获取几何图形的中心点\n         * @english\n         * Get geometry's center\n         * @return {Coordinate} - center of the geometry\n         * @function CenterMixin.getCoordinates\n         */\n        getCoordinates(): Coordinate;\n        /**\n         * 设置几何图形的中心点\n         * @english\n         * Set a new center to the geometry\n         * @param {Coordinate|Number[]} coordinates - new center\n         * @return {Geometry} this\n         * @fires Geometry#positionchange\n         * @function CenterMixin.setCoordinates\n         */\n        setCoordinates(coordinates: Coordinate | Array<number>): any;\n        _getCenter2DPoint(res?: number): Point;\n        _getPrjCoordinates(): Coordinate;\n        _setPrjCoordinates(pcenter: Coordinate): void;\n        _updateCache(): void;\n        _clearProjection(): void;\n        _computeCenter(): Coordinate | null;\n    };\n} & T;\n"},{"path":"geometry/Circle.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\nimport Point from '../geo/Point';\nimport { CommonProjectionType } from '../geo/projection';\nimport Polygon, { PolygonOptionsType, RingCoordinates, RingsCoordinates } from './Polygon';\ndeclare const Circle_base: {\n    new (...args: any[]): {\n        _coordinates: Coordinate;\n        _pcenter: Coordinate;\n        _dirtyCoords: boolean;\n        getMap?(): import(\"src\").Map;\n        _getProjection?(): {\n            code: string;\n            is(code: string): boolean;\n            project(p: Coordinate): Coordinate;\n            unproject(p: Coordinate): Coordinate;\n            projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            isSphere(): boolean;\n            isOutSphere(pcoord: Coordinate): boolean;\n            wrapCoord(pcoord: Coordinate): Coordinate;\n            getCircum(): Record<string, number>;\n            getSphereExtent(): Extent;\n        };\n        onPositionChanged?(): void;\n        _verifyProjection?(): void;\n        _clearCache?(): void;\n        getCoordinates(): Coordinate;\n        setCoordinates(coordinates: number[] | Coordinate): any;\n        _getCenter2DPoint(res?: number): Point;\n        _getPrjCoordinates(): Coordinate;\n        _setPrjCoordinates(pcenter: Coordinate): void;\n        _updateCache(): void;\n        _clearProjection(): void;\n        _computeCenter(): Coordinate;\n    };\n} & typeof Polygon;\n/**\n * @classdesc\n * Represents a Circle Geometry. <br>\n * @category geometry\n * @extends Polygon\n * @mixes Geometry.Center\n * @example\n * var circle = new Circle([100, 0], 1000, {\n *     id : 'circle0',\n *     properties : {\n *         foo : 'bar'\n *     }\n * });\n * @mixes CenterMixin\n */\nexport declare class Circle extends Circle_base {\n    _radius: number;\n    static fromJSON(json: Record<string, any>): Circle;\n    /**\n     * @param {Coordinate} center - center of the circle\n     * @param {Number} radius           - radius of the circle, in meter\n     * @param {Object} [options=null]   - construct options defined in [Circle]{@link Circle#options}\n     */\n    constructor(coordinates: Coordinate | Array<number>, radius: number, options?: CircleOptionsType);\n    /**\n     * 获取圆形的半径\n     * @english\n     * Get radius of the circle\n     * @return {Number}\n     */\n    getRadius(): number;\n    /**\n     * 给圆形设置新的半径\n     * @english\n     * Set a new radius to the circle\n     * @param {Number} radius - new radius\n     * @return {Circle} this\n     * @fires Circle#shapechange\n     */\n    setRadius(radius: number): this;\n    /**\n     * 获取作为多边形的圆的外壳，外壳点数由[options.numberOfShellPoints决定\n     * @english\n     * Gets the shell of the circle as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Circle#options}\n     * @return {Coordinate[]} - shell coordinates\n     */\n    getShell(): RingCoordinates;\n    /**\n     * 圆没有任何孔，总是返回null\n     * @english\n     * Circle won't have any holes, always returns null\n     * @return {Object[]} an empty array\n     */\n    getHoles(): RingsCoordinates;\n    animateShow(): any;\n    _containsPoint(point: Point, tolerance?: number): boolean;\n    _computePrjExtent(projection: CommonProjectionType): Extent;\n    _computeExtent(measurer: any): Extent;\n    _getMinMax(measurer: any): [Coordinate, Coordinate, Coordinate, Coordinate];\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        coordinates: any;\n    };\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        coordinates: number[];\n        radius: number;\n    };\n}\nexport default Circle;\nexport type CircleOptionsType = PolygonOptionsType & {\n    numberOfShellPoints?: number;\n};\n"},{"path":"geometry/ConnectorLine.d.ts","content":"import LineString, { LineStringOptionsType } from './LineString';\nimport Geometry from './Geometry';\nimport ArcCurve, { ArcCurveOptionsType } from './ArcCurve';\nimport { type Map } from '../map';\nimport Coordinate from '../geo/Coordinate';\ndeclare const ConnectorLine_base: {\n    new (...args: any[]): {\n        options: ConnectableOptionsType;\n        _connSource: Geometry;\n        _connTarget: Geometry;\n        getMap?(): Map;\n        getCoordinates?(): Coordinate[];\n        setCoordinates?(coordinates: Coordinate[]): any;\n        hide?(): any;\n        show?(): any;\n        remove?(): any;\n        /**\n         * 获取连接线的源\n         * @english\n         * Gets the source of the connector line.\n         * @return {Geometry|control.Control|UIComponent}\n         * @function Connectable.getConnectSource\n         */\n        getConnectSource(): Geometry;\n        /**\n         * 设置连接线的源\n         * @english\n         * Sets the source to the connector line.\n         * @param {Geometry|control.Control|UIComponent} src\n         * @return {ConnectorLine} this\n         * @function Connectable.setConnectSource\n         */\n        setConnectSource(src: Geometry): any;\n        /**\n         * 获取连接线的目标\n         * @english\n         * Gets the target of the connector line.\n         * @return {Geometry|control.Control|UIComponent}\n         * @function Connectable.getConnectTarget\n         */\n        getConnectTarget(): Geometry;\n        /**\n         * 设置连接线目标\n         * @english\n         * Sets the target to the connector line.\n         * @param {Geometry|control.Control|UIComponent} target\n         * @return {ConnectorLine} this\n         * @function Connectable.setConnectTarget\n         */\n        setConnectTarget(target: Geometry): any;\n        _updateCoordinates(): void;\n        onAdd(): void;\n        onRemove(): void;\n        _showConnect(): void;\n        _registerEvents(): void;\n    };\n    _hasConnectors(geometry: any): boolean;\n    _getConnectors(geometry: any): any;\n} & typeof LineString;\n/**\n * 直线连接线几何图形可以将几何图形或ui组件相互连接。\n * @english\n * A straight connector line geometry can connect geometries or ui components with each other. <br>\n *\n * @category geometry\n * @extends LineString\n * @example\n * var src = new Marker([0,0]).addTo(layer),\n *     dst = new Marker([1,0]).addTo(layer),\n *     line = new ConnectorLine(src, dst, {\n *         showOn : 'always', //'moving', 'click', 'mouseover', 'always'\n *         arrowStyle : 'classic',\n *         arrowPlacement : 'vertex-last', //vertex-first, vertex-last, vertex-firstlast, point\n *         symbol: {\n *           lineColor: '#34495e',\n *           lineWidth: 2\n *        }\n *     }).addTo(layer);\n * @mixes connectorLineMixin\n */\ndeclare class ConnectorLine extends ConnectorLine_base {\n    /**\n     * @param {Geometry|control.Control|UIComponent} src     - source to connect\n     * @param {Geometry|control.Control|UIComponent} target  - target to connect\n     * @param {Object} [options=null]  - construct options defined in [ConnectorLine]{@link ConnectorLine#options}\n     */\n    constructor(src: Geometry, target: Geometry, options?: ConnectorLineOptionsType);\n}\ndeclare const ArcConnectorLine_base: {\n    new (...args: any[]): {\n        options: ConnectableOptionsType;\n        _connSource: Geometry;\n        _connTarget: Geometry;\n        getMap?(): Map;\n        getCoordinates?(): Coordinate[];\n        setCoordinates?(coordinates: Coordinate[]): any;\n        hide?(): any;\n        show?(): any;\n        remove?(): any;\n        /**\n         * 获取连接线的源\n         * @english\n         * Gets the source of the connector line.\n         * @return {Geometry|control.Control|UIComponent}\n         * @function Connectable.getConnectSource\n         */\n        getConnectSource(): Geometry;\n        /**\n         * 设置连接线的源\n         * @english\n         * Sets the source to the connector line.\n         * @param {Geometry|control.Control|UIComponent} src\n         * @return {ConnectorLine} this\n         * @function Connectable.setConnectSource\n         */\n        setConnectSource(src: Geometry): any;\n        /**\n         * 获取连接线的目标\n         * @english\n         * Gets the target of the connector line.\n         * @return {Geometry|control.Control|UIComponent}\n         * @function Connectable.getConnectTarget\n         */\n        getConnectTarget(): Geometry;\n        /**\n         * 设置连接线目标\n         * @english\n         * Sets the target to the connector line.\n         * @param {Geometry|control.Control|UIComponent} target\n         * @return {ConnectorLine} this\n         * @function Connectable.setConnectTarget\n         */\n        setConnectTarget(target: Geometry): any;\n        _updateCoordinates(): void;\n        onAdd(): void;\n        onRemove(): void;\n        _showConnect(): void;\n        _registerEvents(): void;\n    };\n    _hasConnectors(geometry: any): boolean;\n    _getConnectors(geometry: any): any;\n} & typeof ArcCurve;\n/**\n * 弧形曲线连接线几何图形可以将几何图形或ui组件相互连接\n * @english\n * An arc curve connector line geometry can connect geometries or ui components with each other. <br>\n *\n * @category geometry\n * @extends ArcCurve\n * @example\n * var src = new Marker([0,0]).addTo(layer),\n *     dst = new Marker([1,0]).addTo(layer),\n *     line = new ArcConnectorLine(src, dst, {\n *         arcDegree : 120,\n *         showOn : 'always', //'moving', 'click', 'mouseover', 'always'\n *         arrowStyle : 'classic',\n *         arrowPlacement : 'vertex-last', //vertex-first, vertex-last, vertex-firstlast, point\n *         symbol: {\n *           lineColor: '#34495e',\n *           lineWidth: 2\n *        }\n *     }).addTo(layer);\n * @mixes connectorLineMixin\n */\ndeclare class ArcConnectorLine extends ArcConnectorLine_base {\n    /**\n     * @param {Geometry|control.Control|UIComponent} src     - source to connect\n     * @param {Geometry|control.Control|UIComponent} target  - target to connect\n     * @param {Object} [options=null]  - construct options defined in [ConnectorLine]{@link ConnectorLine#options}\n     */\n    constructor(src: Geometry, target: Geometry, options?: ArcConnectorLineOptionsType);\n}\nexport { ConnectorLine, ArcConnectorLine };\nexport type ConnectableOptionsType = {\n    showOn?: 'always' | 'moving' | 'click' | 'mouseover';\n};\nexport type ConnectorLineOptionsType = LineStringOptionsType & ConnectableOptionsType;\nexport type ArcConnectorLineOptionsType = ArcCurveOptionsType & ConnectableOptionsType;\n"},{"path":"geometry/CubicBezierCurve.d.ts","content":"import Curve, { CurveOptionsType } from './Curve';\n/**\n * 三次贝塞尔曲线\n * @english\n * Cubic Bezier Curve\n * @category geometry\n * @extends Curve\n * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve\n * @param {Object} [options=null]   - construct options defined in [CubicBezierCurve]{@link CubicBezierCurve#options}\n * @example\n * var curve = new CubicBezierCurve(\n *     [\n *         [121.47083767181408,31.214448123476995],\n *         [121.4751292062378,31.215475523000404],\n *         [121.47869117980943,31.211916269810335]\n *     ],\n *     {\n *         symbol : {\n *             'lineWidth' : 5\n *         }\n *     }\n * ).addTo(layer);\n */\ndeclare class CubicBezierCurve extends Curve {\n    static fromJSON(json: any): CubicBezierCurve;\n    _toJSON(options: any): any;\n    _paintOn(ctx: CanvasRenderingContext2D, points: any, lineOpacity: number): void;\n    _getArrowPoints(arrows: any[], segments: [], lineWidth: number, arrowStyle: any, tolerance: any): any;\n}\nexport default CubicBezierCurve;\nexport type CubicBezierCurveOptionsType = CurveOptionsType;\n"},{"path":"geometry/Curve.d.ts","content":"import LineString, { LineStringOptionsType } from './LineString';\n/**\n * 曲线样式LineString，所有曲线的抽象父类。\n * @english\n * Curve style LineString, an abstract parent class for all the curves.\n * @category geometry\n * @abstract\n * @extends LineString\n * @param {Coordinate[]|Number[][]} coordinates - coordinates of the line string\n * @param {Object} [options=null] - construct options defined in [LineString]{@link LineString#options}\n * @property {Boolean} [options.enableSimplify=false] - whether to simplify path before rendering\n * @property {Boolean} [options.enableClip=false] - whether to clip curve with map's current extent\n */\ndeclare class Curve extends LineString {\n    _arc(ctx: CanvasRenderingContext2D, points: any, lineOpacity: number): void;\n    _quadraticCurve(ctx: CanvasRenderingContext2D, points: any): void;\n    _bezierCurve(ctx: CanvasRenderingContext2D, points: any): void;\n    _getCurveArrowPoints(arrows: any[], segments: [], lineWidth: number, arrowStyle: any, tolerance: any, step: number): void;\n}\nexport default Curve;\nexport type CurveOptionsType = LineStringOptionsType & {\n    enableSimplify?: boolean;\n    enableClip?: boolean;\n};\n"},{"path":"geometry/editor/GeometryEditor.d.ts","content":"import Class from '../../core/Class';\nimport EditHandle from '../../renderer/edit/EditHandle';\nimport { GeometryEditOptionsType } from '../ext/Geometry.Edit';\ntype GeometryEvents = {\n    'symbolchange': any;\n    'dragstart': any;\n    'dragend': any;\n    'positionchange shapechange': any;\n};\ndeclare const GeometryEditor_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Class;\n/**\n * 内部使用的几何图形编辑器\n * @english\n * Geometry editor used internally for geometry editing.\n * @category geometry\n * @protected\n * @extends Class\n * @mixes Eventable\n */\ndeclare class GeometryEditor extends GeometryEditor_base {\n    _geometry: any;\n    private _originalSymbol;\n    private _shadowLayer;\n    private _shadow;\n    private _geometryDraggble;\n    private _history;\n    private _historyPointer;\n    private _editOutline;\n    private _refreshHooks;\n    private _updating;\n    editing: boolean;\n    options: GeometryEditOptionsType;\n    /**\n     * @param {Geometry} geometry geometry to edit\n     * @param {Object} [opts=null] options\n     * @param {Object} [opts.symbol=null] symbol of being edited.\n     */\n    constructor(geometry: any, opts: GeometryEditOptionsType);\n    /**\n     * 获取地图对象\n     * @english\n     * Get map\n     * @return {Map} map\n     */\n    getMap(): any;\n    /**\n     * 准备编辑\n     * @english\n     * Prepare to edit\n     */\n    prepare(): void;\n    _prepareEditStageLayer(): void;\n    /**\n     * 开始编辑\n     * @english\n     * Start to edit\n     */\n    start(): void;\n    /**\n     * 停止编辑\n     * @english\n     * Stop editing\n     */\n    stop(): void;\n    /**\n     * 编辑器是否在编辑\n     * @english\n     * Whether the editor is editing\n     * @return {Boolean}\n     */\n    isEditing(): boolean;\n    _getGeometryEvents(): GeometryEvents;\n    _switchGeometryEvents(oper: any): void;\n    _onGeoSymbolChange(param: any): void;\n    _onMarkerDragEnd(): void;\n    /**\n     * 创建几何图形的矩形轮廓\n     * @english\n     * create rectangle outline of the geometry\n     * @private\n     */\n    _createOrRefreshOutline(): any;\n    _createCenterHandle(): void;\n    _createHandleInstance(containerPoint: any, opts: any): EditHandle;\n    createHandle(containerPoint: any, opts: any): EditHandle;\n    /**\n     * 为几何图形创建可以调整大小的事件\n     * @english\n     * create resize handles for geometry that can resize.\n     * @param {Array} blackList handle indexes that doesn't display, to prevent change a geometry's coordinates\n     * @param {fn} onHandleMove callback\n     * @private\n     */\n    _createResizeHandles(blackList: Array<any>, onHandleMove: any, onHandleUp: any): any;\n    /**\n     * 创建标记编辑器\n     * @english\n     * Create marker editor\n     * @private\n     */\n    createMarkerEditor(): void;\n    /**\n     * 创建圆形编辑器\n     * @english\n     * Create circle editor\n     * @private\n     */\n    createCircleEditor(): void;\n    /**\n     * 创建椭圆或者矩形编辑器\n     * @english\n     * editor of ellipse or rectangle\n     * @private\n     */\n    createEllipseOrRectEditor(): void;\n    /**\n     * 创建多边形编辑器\n     * @english\n     * Editor for polygon\n     * @private\n     */\n    createPolygonEditor(): void;\n    _refresh(): void;\n    _hideContext(): void;\n    _addRefreshHook(fn: any): void;\n    _update(method: any, ...args: any): void;\n    _updateCoordFromShadow(ignoreRecord?: any): void;\n    _recordHistory(method: any, ...args: any): void;\n    cancel(): GeometryEditor;\n    /**\n     * 获取视图历史记录中的上一个地图视图\n     * @english\n     * Get previous map view in view history\n     * @return {Object} map view\n     */\n    undo(): any;\n    /**\n     * 获取视图历史记录中的下一个地图视图\n     * @english\n     * Get next view in view history\n     * @return {Object} map view\n     */\n    redo(): any;\n    _exeAndReset(record: any): void;\n    _onDragStart(): void;\n    _onDragEnd(): void;\n    _exeHistory(record: any): void;\n}\nexport default GeometryEditor;\n"},{"path":"geometry/editor/TextEditable.d.ts","content":"import TextMarker from '../../geometry/TextMarker';\nimport UIMarker from '../../ui/UIMarker';\n/**\n * Mixin methods for text editing.\n * @mixin TextEditable\n */\ndeclare const TextEditable: {\n    /**\n     * 开始编辑文本，每当点击地图时，编辑将自动结束\n     * @english\n     * Start to edit the text, editing will be ended automatically whenever map is clicked.\n     *\n     * @return {TextMarker} this\n     * @fires TextMarker#edittextstart\n     */\n    startEditText(): TextMarker;\n    /**\n     * 结束编辑\n     * @english\n     * End text edit.\n     *\n     * @return {TextMarker} this\n     * @fires TextMarker#edittextend\n     */\n    endEditText(): any;\n    /**\n     * 是否正在编辑文本\n     * @english\n     * Whether the text is being edited.\n     *\n     * @return {Boolean}\n     */\n    isEditingText(): boolean;\n    /**\n     * 获取正在编辑的文本对象\n     * @english\n     * Get the text editor which is an [ui.UIMarker]{@link ui.UIMarker}\n     * @return {ui.UIMarker} text editor\n     */\n    getTextEditor(): UIMarker;\n    _prepareEditor(): void;\n    _getEditorOffset(): object;\n    _createEditor(): HTMLElement;\n    _setCursorToLast(obj: any): void;\n};\nexport default TextEditable;\n"},{"path":"geometry/Ellipse.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Polygon, { PolygonOptionsType, RingCoordinates, RingsCoordinates } from './Polygon';\nimport Point from '../geo/Point';\nimport Extent from '../geo/Extent';\ndeclare const Ellipse_base: {\n    new (...args: any[]): {\n        _coordinates: Coordinate;\n        _pcenter: Coordinate;\n        _dirtyCoords: boolean;\n        getMap?(): import(\"src\").Map;\n        _getProjection?(): {\n            code: string;\n            is(code: string): boolean;\n            project(p: Coordinate): Coordinate;\n            unproject(p: Coordinate): Coordinate;\n            projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            isSphere(): boolean;\n            isOutSphere(pcoord: Coordinate): boolean;\n            wrapCoord(pcoord: Coordinate): Coordinate;\n            getCircum(): Record<string, number>;\n            getSphereExtent(): Extent;\n        };\n        onPositionChanged?(): void;\n        _verifyProjection?(): void;\n        _clearCache?(): void;\n        getCoordinates(): Coordinate;\n        setCoordinates(coordinates: number[] | Coordinate): any;\n        _getCenter2DPoint(res?: number): Point;\n        _getPrjCoordinates(): Coordinate;\n        _setPrjCoordinates(pcenter: Coordinate): void;\n        _updateCache(): void;\n        _clearProjection(): void;\n        _computeCenter(): Coordinate;\n    };\n} & typeof Polygon;\n/**\n * 表示椭圆几何体\n * @english\n * Represents a Ellipse Geometry. <br>\n * @category geometry\n * @extends Polygon\n * @mixes CenterMixin\n * @example\n * var ellipse = new Ellipse([100, 0], 1000, 500, {\n *     id : 'ellipse0'\n * });\n */\nexport declare class Ellipse extends Ellipse_base {\n    width: number;\n    height: number;\n    options: EllipseOptionsType;\n    static fromJSON(json: Record<string, any>): Ellipse;\n    /**\n     * @param {Coordinate} center  - center of the ellipse\n     * @param {Number} width  - width of the ellipse, in meter\n     * @param {Number} height - height of the ellipse, in meter\n     * @param {Object}  [options=null] - construct options defined in [Ellipse]{@link Ellipse#options}\n     */\n    constructor(coordinates: Coordinate | Array<number>, width: number, height: number, options?: EllipseOptionsType);\n    /**\n     * 获取椭圆的宽度\n     * @english\n     * Get ellipse's width\n     * @return {Number}\n     */\n    getWidth(): number;\n    /**\n     * 设置椭圆的宽度\n     * Set new width to ellipse\n     * @param {Number} width - new width\n     * @fires Ellipse#shapechange\n     * @return {Ellipse} this\n     */\n    setWidth(width: number): this;\n    /**\n     * 获取椭圆高度\n     * @english\n     * Get ellipse's height\n     * @return {Number}\n     */\n    getHeight(): number;\n    /**\n     * 设置椭圆高度\n     * @english\n     * Set new height to ellipse\n     * @param {Number} height - new height\n     * @fires Ellipse#shapechange\n     * @return {Ellipse} this\n     */\n    setHeight(height: number): this;\n    /**\n     * 获取作为多边形的椭圆的外壳，外壳点数由决定\n     * @english\n     * Gets the shell of the ellipse as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Circle#options}\n     * @return {Coordinate[]} - shell coordinates\n     */\n    getShell(): RingCoordinates;\n    _getShell(): RingCoordinates;\n    _getPrjShell(): RingCoordinates;\n    /**\n     * 椭圆没有任何孔，总是返回null\n     * @english\n     * Ellipse won't have any holes, always returns null\n     * @return {Object[]} an empty array\n     */\n    getHoles(): RingsCoordinates;\n    animateShow(): any;\n    _containsPoint(point: Point, tolerance?: number): boolean;\n    _computePrjExtent(): Extent;\n    _computeExtent(): any;\n    _getMinMax(measurer: any): [Coordinate, Coordinate, Coordinate, Coordinate];\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        coordinates: any;\n    };\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        coordinates: number[];\n        width: number;\n        height: number;\n    };\n}\nexport default Ellipse;\nexport type EllipseOptionsType = PolygonOptionsType & {\n    numberOfShellPoints?: number;\n    debug?: boolean;\n};\n"},{"path":"geometry/ext/Geometry.Animation.d.ts","content":"import { AnimationOptionsType, Frame, Player } from '../../core/Animation';\ntype AnimationStyles = {\n    [key: string]: any;\n};\ndeclare module \"../Geometry\" {\n    interface Geometry {\n        _animPlayer: Player;\n        animate(styles: AnimationStyles, options?: AnimationOptionsType | ((frame: Frame) => void), step?: (frame: Frame) => void): Player;\n    }\n}\nexport {};\n"},{"path":"geometry/ext/Geometry.Drag.d.ts","content":"import Handler from '../../handler/Handler';\n/**\n * 几何图形的拖动处理程序\n * @english\n * Drag handler for geometries.\n * @category handler\n * @extends Handler\n * @ignore\n */\ndeclare class GeometryDragHandler extends Handler {\n    container: any;\n    private _dragHandler;\n    private _shadow;\n    private _dragStageLayer;\n    private _shadowConnectors;\n    private _lastCoord;\n    private _lastPoint;\n    private _startParam;\n    private _moved;\n    private _isDragging;\n    /**\n     * @param  {Geometry} target geometry target to drag\n     */\n    constructor(target: any);\n    addHooks(): void;\n    removeHooks(): void;\n    _prepareDragHandler(): void;\n    _prepareShadow(): void;\n    _updateShadowSymbol(shadow: any, target: any): void;\n    _prepareShadowConnectors(): void;\n    _onTargetUpdated(): void;\n    _prepareDragStageLayer(): void;\n    _startDrag(param: any): void;\n    _dragging(param: any): void;\n    _endDrag(param?: any): void;\n    isDragging(): boolean;\n    _updateTargetAndRemoveShadow(eventParam: any): void;\n    _correctCoord(coord: any): any;\n}\ndeclare module \"../Geometry\" {\n    interface Geometry {\n        isDragging(): boolean;\n    }\n}\nexport default GeometryDragHandler;\n"},{"path":"geometry/ext/Geometry.Edit.d.ts","content":"export type GeometryEditSymbolType = {\n    'markerType': string;\n    'markerFill': string;\n    'markerLineColor': string;\n    'markerLineWidth': number;\n    'markerWidth': number;\n    'markerHeight': number;\n    'opacity': number;\n};\nexport type GeometryEditOptionsType = {\n    symbol?: {\n        [key: string]: any;\n    };\n    fixAspectRatio?: boolean;\n    centerHandleSymbol?: GeometryEditSymbolType;\n    vertexHandleSymbol?: GeometryEditSymbolType;\n    newVertexHandleSymbol?: GeometryEditSymbolType;\n    removeVertexOn?: string;\n    collision?: boolean;\n    collisionBufferSize?: number;\n    vertexZIndex?: number;\n    newVertexZIndex?: number;\n};\ndeclare module \"../Geometry\" {\n    interface Geometry {\n        startEdit(opts?: GeometryEditOptionsType): this;\n        endEdit(): this;\n        redoEdit(): this;\n        undoEdit(): this;\n        cancelEdit(): this;\n        isEditing(): boolean;\n    }\n}\n"},{"path":"geometry/ext/Geometry.Events.d.ts","content":"declare module \"../Geometry\" {\n    interface Geometry {\n        _onEvent(event: MouseEvent | TouchEvent, type?: string): void;\n    }\n}\nexport {};\n"},{"path":"geometry/ext/Geometry.InfoWindow.d.ts","content":"import InfoWindow, { InfoWindowOptionsType } from '../../ui/InfoWindow';\nimport type Coordinate from '../../geo/Coordinate';\ndeclare module \"../Geometry\" {\n    interface Geometry {\n        _infoWindow: InfoWindow;\n        setInfoWindow(options: InfoWindowOptionsType): this;\n        getInfoWindow(): InfoWindow;\n        openInfoWindow(coordinate?: Coordinate): this;\n        closeInfoWindow(): this;\n        removeInfoWindow(): this;\n        _bindInfoWindow(): this;\n        _unbindInfoWindow(): this;\n    }\n}\n"},{"path":"geometry/ext/Geometry.JSON.d.ts","content":"export {};\n"},{"path":"geometry/GeoJSON.d.ts","content":"/**\n * GeoJSON工具类\n * @english\n * GeoJSON utilities\n * @category geometry\n */\ndeclare const GeoJSON: {\n    /**\n     * 将一个或多个GeoJSON对象转换为几何体\n     * @english\n     * Convert one or more GeoJSON objects to geometry\n     * @param  {String|Object|Object[]} geoJSON - GeoJSON objects or GeoJSON string\n     * @param  {Function} [foreachFn=undefined] - callback function for each geometry\n     * @return {Geometry|Geometry[]} a geometry array when input is a FeatureCollection\n     * @example\n     * var collection = {\n     *      \"type\": \"FeatureCollection\",\n     *      \"features\": [\n     *          { \"type\": \"Feature\",\n     *            \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.0, 0.5]},\n     *            \"properties\": {\"prop0\": \"value0\"}\n     *           },\n     *           { \"type\": \"Feature\",\n     *             \"geometry\": {\n     *                 \"type\": \"LineString\",\n     *                 \"coordinates\": [\n     *                     [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]\n     *                 ]\n     *             },\n     *             \"properties\": {\n     *                 \"prop0\": \"value0\",\n     *                 \"prop1\": 0.0\n     *             }\n     *           },\n     *           { \"type\": \"Feature\",\n     *             \"geometry\": {\n     *                 \"type\": \"Polygon\",\n     *                 \"coordinates\": [\n     *                     [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n     *                       [100.0, 1.0], [100.0, 0.0] ]\n     *                 ]\n     *             },\n     *             \"properties\": {\n     *                 \"prop0\": \"value0\",\n     *                 \"prop1\": {\"this\": \"that\"}\n     *             }\n     *          }\n     *      ]\n     *  }\n     *  // A geometry array.\n     *  const geometries = GeoJSON.toGeometry(collection, geometry => { geometry.config('draggable', true); });\n     */\n    toGeometry: (geoJSON: any, foreachFn?: any) => any;\n    /**\n     * async将一个或多个GeoJSON对象转换为几何体\n     * @english\n    * async Convert one or more GeoJSON objects to geometry\n    * @param  {String|Object|Object[]} geoJSON - GeoJSON objects or GeoJSON string\n    * @param  {Function} [foreachFn=undefined] - callback function for each geometry\n    * @param  {Number} [countPerTime=2000] - Number of graphics converted per time\n    * @return {Promise}\n    * @example\n    *  GeoJSON.toGeometryAsync(geoJSON).then(geos=>{\n    *    console.log(geos);\n    * })\n    * */\n    toGeometryAsync(geoJSON: any, foreachFn: any, countPerTime?: number): any;\n    /**\n     * 转换单个GeoJSON对象\n     * @english\n     * Convert single GeoJSON object\n     * @param  {Object} geoJSONObj - a GeoJSON object\n     * @return {Geometry}\n     * @private\n     */\n    _convert: (json: any, foreachFn?: any) => any;\n    _isGeoJSON(json: any): boolean;\n    /**\n     * 正在请求一个大容量的geojson文件。解决主线程阻塞问题\n     * @english\n    * Requesting a large volume geojson file.Solve the problem of main thread blocking\n    * @param  {String} url - GeoJSON file path\n    * @param  {Number} [countPerTime=2000] - Number of graphics converted per time\n    * @return {Promise}\n    * @example\n    *  GeoJSON.fetch('https://abc.com/file.geojson',2000).then(geojson=>{\n    *    console.log(geojson);\n    * })\n    * */\n    fetch(url: any, countPerTime?: number): any;\n};\nexport default GeoJSON;\n"},{"path":"geometry/Geometry.d.ts","content":"import Class from '../core/Class';\nimport { BaseEventParamsType } from '../core/Eventable';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport Extent from '../geo/Extent';\nimport PointExtent from '../geo/PointExtent';\nimport Painter from '../renderer/geometry/Painter';\nimport CollectionPainter from '../renderer/geometry/CollectionPainter';\nimport { SizeLike } from '../geo/Size';\nimport type { ProjectionType } from '../geo/projection';\nimport OverlayLayer, { addGeometryFitViewOptions } from '../layer/OverlayLayer';\nimport GeometryCollection from './GeometryCollection';\nimport type { Map } from '../map';\nimport { WithNull } from '../types/typings';\nimport { InfoWindowOptionsType } from '../ui/InfoWindow';\ndeclare const Geometry_base: {\n    new (...args: any[]): {\n        _jsonType?: string;\n        getJSONType(): string;\n    };\n    registerJSONType(type: string): void;\n    getJSONClass(type: string): {\n        new (...args: any[]): {\n            _eventMap?: Record<string, {\n                handler: import(\"../core/Eventable\").HandlerFn;\n                context: any;\n            }[]>;\n            _eventParent?: any;\n            _eventTarget?: any;\n            on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            addEventListener(...args: any[]): any;\n            once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            removeEventListener(...args: any[]): any;\n            listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n            getListeningEvents(): string[];\n            copyEventListeners(target: any): any;\n            fire(eventType: string, param?: BaseEventParamsType): any;\n            _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n            _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n            _clearListeners(eventType: string): void;\n            _clearAllListeners(): void;\n            _setEventParent(parent: any): any;\n            _setEventTarget(target: any): any;\n            _fire(eventType: string, param: BaseEventParamsType): any;\n        };\n    } & {\n        new (...args: any[]): {\n            _handlers?: import(\"src\").Handler[];\n            addHandler(name: any, handlerClass: any): any;\n            removeHandler(name: any): any;\n            _clearHandlers(): void;\n        };\n    } & typeof Class;\n} & {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: BaseEventParamsType): any;\n    };\n} & {\n    new (...args: any[]): {\n        _handlers?: import(\"src\").Handler[];\n        addHandler(name: any, handlerClass: any): any;\n        removeHandler(name: any): any;\n        _clearHandlers(): void;\n    };\n} & typeof Class;\n/**\n * 所有几何图形的基类。\n * 它定义了所有几何图形类共享的通用方法。\n * 它是抽象的，不打算被实例化而是被扩展。\n * @english\n * Base class for all the geometries. <br/>\n * It defines common methods that all the geometry classes share. <br>\n * It is abstract and not intended to be instantiated but extended.\n *\n * @category geometry\n * @abstract\n * @extends Class\n * @mixes Eventable\n * @mixes Handlerable\n * @mixes JSONAble\n * @mixes ui.Menuable\n */\nexport declare class Geometry extends Geometry_base {\n    options: GeometryOptionsType;\n    type: string;\n    _layer: OverlayLayer;\n    _angle: number;\n    _pivot: Coordinate;\n    _id: string;\n    properties: Record<string, any>;\n    _symbol: any;\n    _symbolUpdated: any;\n    _compiledSymbol: any;\n    _symbolHash: any;\n    _textDesc: any;\n    _eventSymbolProperties: any;\n    _sizeSymbol: any;\n    _internalId: number;\n    _extent: Extent;\n    _fixedExtent: PointExtent;\n    _extent2d: PointExtent;\n    _externSymbol: any;\n    _parent: Geometry | GeometryCollection;\n    _silence: boolean;\n    _projCode: string;\n    _painter: Painter;\n    _maskPainter: CollectionPainter | Painter;\n    _dirtyCoords: any;\n    _pcenter: Coordinate;\n    _coordinates: any;\n    _infoWinOptions: InfoWindowOptionsType;\n    _minAlt: number;\n    _maxAlt: number;\n    _isCheck?: boolean;\n    _cPoint?: any;\n    _inCurrentView?: boolean;\n    isPoint?: boolean;\n    _paintAsPath?: () => any;\n    _getPaintParams?: (disableSimplify?: boolean) => any[];\n    _simplified?: boolean;\n    getHoles?(): Array<Array<Coordinate>>;\n    __connectors: Array<Geometry>;\n    getShell?(): Array<Coordinate>;\n    getGeometries?(): Geometry[];\n    getCoordinates?(): Coordinate | Array<Coordinate> | Array<Array<Coordinate>> | Array<Array<Array<Coordinate>>>;\n    setCoordinates?(coordinate: any): this;\n    _computeCenter?(T: any): Coordinate;\n    _computeExtent?(T: any): Extent;\n    onRemove?(): void;\n    _computeGeodesicLength?(T: any): number;\n    _computeGeodesicArea?(T: any): number;\n    getRotateOffsetAngle?(): number;\n    _computePrjExtent?(T: null | ProjectionType): Extent;\n    _updateCache?(): void;\n    onAdd?(): void;\n    constructor(options: GeometryOptionsType);\n    static fromJSON(json: {\n        [key: string]: any;\n    } | Array<{\n        [key: string]: any;\n    }>): Geometry | Array<Geometry>;\n    /**\n     * 获取几何图形第一个坐标点\n     * @english\n     * Returns the first coordinate of the geometry.\n     *\n     * @return {Coordinate} First Coordinate\n     */\n    getFirstCoordinate(): Coordinate;\n    /**\n     * 获取几何图形最后一个坐标点\n     * @english\n     * Returns the last coordinate of the geometry.\n     *\n     * @return {Coordinate} Last Coordinate\n     */\n    getLastCoordinate(): Coordinate;\n    /**\n     * 将几何图形添加到指定图层上\n     * @english\n     * Adds the geometry to a layer\n     * @param {Layer} layer    - layer add to\n     * @param {Boolean} [fitview=false] - automatically set the map to a fit center and zoom for the geometry\n     * @return {Geometry} this\n     * @fires Geometry#add\n     */\n    addTo(layer: OverlayLayer, fitview?: boolean | addGeometryFitViewOptions): this;\n    /**\n     * 获取几何图形所在的图层\n     * @english\n     * Get the layer which this geometry added to.\n     * @returns {Layer} - layer added to\n     */\n    getLayer(): OverlayLayer;\n    /**\n     * 获取几何图形所在的地图对象\n     * @english\n     * Get the map which this geometry added to\n     * @returns {Map} - map added to\n     */\n    getMap(): Map | null;\n    /**\n     * 获取几何图形的id\n     * @english\n     * Gets geometry's id. Id is set by setId or constructor options.\n     * @returns {String|Number} geometry的id\n     */\n    getId(): string;\n    /**\n     * 给几何图形设置id\n     * @english\n     * Set geometry's id.\n     * @param {String} id - new id\n     * @returns {Geometry} this\n     * @fires Geometry#idchange\n     */\n    setId(id: string): this;\n    /**\n     * 获取几何图形的属性\n     * @english\n     * Get geometry's properties. Defined by GeoJSON as [feature's properties]{@link http://geojson.org/geojson-spec.html#feature-objects}.\n     *\n     * @returns {Object} properties\n     */\n    getProperties(): {\n        [key: string]: any;\n    } | null;\n    /**\n     * 给几何图形设置新的属性\n     * Set a new properties to geometry.\n     * @param {Object} properties - new properties\n     * @returns {Geometry} this\n     * @fires Geometry#propertieschange\n     */\n    setProperties(properties: {\n        [key: string]: any;\n    }): this;\n    /**\n     * 获取几何图形的类型,例如“点”,\"线\"\n     * @english\n     * Get type of the geometry, e.g. \"Point\", \"LineString\"\n     * @returns {String} type of the geometry\n     */\n    getType(): string;\n    /**\n     * 获取几何图形的样式\n     * @english\n     * Get symbol of the geometry\n     * @returns {Object} geometry's symbol\n     */\n    getSymbol(): any;\n    /**\n     * 给几何图形设置样式\n     * @english\n     * Set a new symbol to style the geometry.\n     * @param {Object} symbol - new symbol\n     * @see {@tutorial symbol Style a geometry with symbols}\n     * @return {Geometry} this\n     * @fires Geometry#symbolchange\n     */\n    setSymbol(symbol: any): this;\n    /**\n     * 获取样式的哈希值\n     * @english\n     * Get symbol's hash code\n     * @return {String}\n     */\n    getSymbolHash(): string;\n    /**\n     * 更新几何图形当前的样式\n     * @english\n     * Update geometry's current symbol.\n     *\n     * @param  {Object | Array} props - symbol properties to update\n     * @return {Geometry} this\n     * @fires Geometry#symbolchange\n     * @example\n     * var marker = new Marker([0, 0], {\n     *  // if has markerFile , the priority of the picture is greater than the vector and the path of svg\n     *  // svg image type:'path';vector type:'cross','x','diamond','bar','square','rectangle','triangle','ellipse','pin','pie'\n     *    symbol : {\n     *       markerType : 'ellipse',\n     *       markerWidth : 20,\n     *       markerHeight : 30\n     *    }\n     * });\n     * // update symbol's markerWidth to 40\n     * marker.updateSymbol({\n     *     markerWidth : 40\n     * });\n     */\n    updateSymbol(props: any): this;\n    /**\n     * 如果几何图形有文本内容，就获取它\n     * @english\n     * Get geometry's text content if it has\n     * @returns {String}\n     */\n    getTextContent(): any;\n    getTextDesc(): any;\n    /**\n     * 获取几何图形中心点\n     * @english\n     * Get the geographical center of the geometry.\n     *\n     * @returns {Coordinate}\n     */\n    getCenter(): Coordinate;\n    /**\n     * 获取几何图形的包围盒范围\n     * @english\n     * Get the geometry's geographical extent\n     *\n     * @returns {Extent} geometry's extent\n     */\n    getExtent(): Extent;\n    /**\n     * 获取几何图形的屏幕像素范围\n     * @english\n     * Get geometry's screen extent in pixel\n     *\n     * @returns {PointExtent}\n     */\n    getContainerExtent(out?: PointExtent): PointExtent;\n    _getFixedExtent(): PointExtent;\n    get2DExtent(): PointExtent;\n    /**\n     * 获取几何体的像素大小，不同缩放级别的像素大小可能会有所不同。\n     * @english\n     * Get pixel size of the geometry, which may vary in different zoom levels.\n     *\n     * @returns {Size}\n     */\n    getSize(): SizeLike;\n    /**\n     * 几何体是否包含输入容器点\n     * @english\n     * Whehter the geometry contains the input container point.\n     *\n     * @param  {Point|Coordinate} point - input container point or coordinate\n     * @param  {Number} [t=undefined] - tolerance in pixel\n     * @return {Boolean}\n     * @example\n     * var circle = new Circle([0, 0], 1000)\n     *     .addTo(layer);\n     * var contains = circle.containsPoint(new maptalks.Point(400, 300));\n     */\n    containsPoint(containerPoint: Point, t?: number): boolean;\n    _containsPoint(containerPoint: Point, t?: number): boolean;\n    /**\n     * 显示几何图形\n     * @english\n     * Show the geometry.\n     *\n     * @return {Geometry} this\n     * @fires Geometry#show\n     */\n    show(): this;\n    /**\n     * 隐藏几何图形\n     * @english\n     * Hide the geometry\n     *\n     * @return {Geometry} this\n     * @fires Geometry#hide\n     */\n    hide(): this;\n    /**\n     * 几何图形是否可见\n     * @english\n     * Whether the geometry is visible\n     *\n     * @returns {Boolean}\n     */\n    isVisible(): boolean;\n    /**\n     * symbol是否可见\n     * @english\n     * Whether the geometry symbol is visible\n     *\n     * @returns {Boolean}\n     */\n    symbolIsVisible(): boolean;\n    /**\n     * 获取几何图形所在层级，默认是0\n     * @english\n     * Get zIndex of the geometry, default is 0\n     * @return {Number} zIndex\n     */\n    getZIndex(): number;\n    /**\n     * 给几何图形设置新的层级并触发zindexchange事件（将导致层对几何体进行排序并进行渲染）\n     * @english\n     * Set a new zIndex to Geometry and fire zindexchange event (will cause layer to sort geometries and render)\n     * @param {Number} zIndex - new zIndex\n     * @return {Geometry} this\n     * @fires Geometry#zindexchange\n     */\n    setZIndex(zIndex: number): this;\n    /**\n     * 仅将新的zIndex设置为Geometry，而不触发zindexchange事件\n     * 当需要更新许多几何图形的zIndex时，可以用来提高性能\n     * 当更新了N个几何体时，可以将setZIndexSilently与（N-1）个几何体一起使用，并将setZIendex与要排序和渲染的层的最后一个几何体一同使用。\n     * @english\n     * Only set a new zIndex to Geometry without firing zindexchange event. <br>\n     * Can be useful to improve perf when a lot of geometries' zIndex need to be updated. <br>\n     * When updated N geometries, You can use setZIndexSilently with (N-1) geometries and use setZIndex with the last geometry for layer to sort and render.\n     * @param {Number} zIndex - new zIndex\n     * @return {Geometry} this\n     */\n    setZIndexSilently(zIndex: number): this;\n    /**\n     * 将几何图形至于顶层\n     * @english\n     * Bring the geometry on the top\n     * @return {Geometry} this\n     * @fires Geometry#zindexchange\n     */\n    bringToFront(): this;\n    /**\n     * 将几何图形置于底层\n     * @english\n     * Bring the geometry to the back\n     * @return {Geometry} this\n     * @fires Geometry#zindexchange\n     */\n    bringToBack(): this;\n    /**\n     * 按给定偏移平移或移动几何体\n     * @english\n     * Translate or move the geometry by the given offset.\n     *\n     * @param  {Coordinate} offset - translate offset\n     * @return {Geometry} this\n     * @fires Geometry#positionchange\n     * @fires Geometry#shapechange\n     */\n    /**\n     * Translate or move the geometry by the given offset.\n     *\n     * @param  {Number} x - x offset\n     * @param  {Number} y - y offset\n     * @return {Geometry} this\n     * @fires Geometry#positionchange\n     * @fires Geometry#shapechange\n     */\n    translate(x: number | Coordinate, y?: number): this;\n    /**\n     * 闪烁几何图形，按一定的内部显示和隐藏计数次数。\n     * @english\n     * Flash the geometry, show and hide by certain internal for times of count.\n     *\n     * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)\n     * @param {Number} [count=4]          - flash times\n     * @param {Function} [cb=null]        - callback function when flash ended\n     * @param {*} [context=null]          - callback context\n     * @return {Geometry} this\n     */\n    flash(interval: number, count: number, cb: () => void, context: any): this;\n    /**\n     * 返回不包含事件侦听器的几何体的副本。\n     * @english\n     * Returns a copy of the geometry without the event listeners.\n     * @returns {Geometry} copy\n     */\n    copy(): Geometry;\n    /**\n     * 将其自身从图层中移除（如果有的话）。\n     * @english\n     * remove itself from the layer if any.\n     * @returns {Geometry} this\n     * @fires Geometry#removestart\n     * @fires Geometry#remove\n     */\n    remove(): this;\n    /**\n     * 将几何对象导出成geojson对象\n     * @english\n     * Exports [geometry]{@link http://geojson.org/geojson-spec.html#feature-objects} out of a GeoJSON feature.\n     * @return {Object} GeoJSON Geometry\n     */\n    toGeoJSONGeometry(): {\n        [key: string]: any;\n    };\n    /**\n     * 导出geojson对象中的一个feature\n     * @english\n     * Exports a GeoJSON feature.\n     * @param {Object} [opts=null]              - export options\n     * @param {Boolean} [opts.geometry=true]    - whether export geometry\n     * @param {Boolean} [opts.properties=true]  - whether export properties\n     * @returns {Object} GeoJSON Feature\n     */\n    toGeoJSON(opts?: {\n        [key: string]: any;\n    }): {\n        [key: string]: any;\n    };\n    /**\n     * 从几何体中导出一个配置文件json。\n     * 除了导出特性对象，概要文件json还包含符号、构造选项和信息窗口信息。\n     * 配置文件json可以存储在其他地方，稍后用于重现几何图形\n     * 由于函数的序列化问题，概要文件json中不包括事件侦听器和上下文菜单\n     * @english\n     * Export a profile json out of the geometry. <br>\n     * Besides exporting the feature object, a profile json also contains symbol, construct options and infowindow info.<br>\n     * The profile json can be stored somewhere else and be used to reproduce the geometry later.<br>\n     * Due to the problem of serialization for functions, event listeners and contextmenu are not included in profile json.\n     * @example\n     *     // an example of a profile json.\n     * var profile = {\n            \"feature\": {\n                  \"type\": \"Feature\",\n                  \"id\" : \"point1\",\n                  \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.0, 0.5]},\n                  \"properties\": {\"prop0\": \"value0\"}\n            },\n            //construct options.\n            \"options\":{\n                \"draggable\" : true\n            },\n            //symbol\n            \"symbol\":{\n                \"markerFile\"  : \"http://foo.com/icon.png\",\n                \"markerWidth\" : 20,\n                \"markerHeight\": 20\n            },\n            //infowindow info\n            \"infowindow\" : {\n                \"options\" : {\n                    \"style\" : \"black\"\n                },\n                \"title\" : \"this is a infowindow title\",\n                \"content\" : \"this is a infowindow content\"\n            }\n        };\n     * @param {Object}  [options=null]          - export options\n     * @param {Boolean} [opts.geometry=true]    - whether export feature's geometry\n     * @param {Boolean} [opts.properties=true]  - whether export feature's properties\n     * @param {Boolean} [opts.options=true]     - whether export construct options\n     * @param {Boolean} [opts.symbol=true]      - whether export symbol\n     * @param {Boolean} [opts.infoWindow=true]  - whether export infowindow\n     * @return {Object} profile json object\n     */\n    toJSON(options?: {\n        [key: string]: any;\n    }): {\n        [key: string]: any;\n    };\n    /**\n     * 获取几何图形的地理长度\n     * @english\n     * Get the geographic length of the geometry.\n     * @returns {Number} geographic length, unit is meter\n     */\n    getLength(): number;\n    /**\n     * 获取几何图形的面积\n     * @english\n     * Get the geographic area of the geometry.\n     * @returns {Number} geographic area, unit is sq.meter\n     */\n    getArea(): number;\n    /**\n     * 按给定角度围绕轴心点旋转几何体\n     * @english\n     * Rotate the geometry of given angle around a pivot point\n     * @param {Number} angle - angle to rotate in degree\n     * @param {Coordinate} [pivot=null]  - optional, will be the geometry's center by default\n     * @returns {Geometry} this\n     */\n    rotate(angle: number, pivot?: Coordinate): this;\n    _rotatePrjCoordinates(coordinates: Coordinate | Array<Coordinate>): Coordinate | Coordinate[];\n    isRotated(): boolean;\n    /**\n     * 获取连线的连接点\n     * @english\n     * Get the connect points for [ConnectorLine]{@link ConnectorLine}\n     * @return {Coordinate[]} connect points\n     * @private\n     */\n    _getConnectPoints(): Coordinate[];\n    _initOptions(options: GeometryOptionsType): void;\n    _bindLayer(layer: OverlayLayer): void;\n    _prepareSymbol(symbol: any): any;\n    _checkAndCopySymbol(symbol: any): any;\n    _getSymbol(): any;\n    /**\n     * 将外部符号设置为几何体，例如VectorLayer的setStyle中的样式\n     * @english\n     * Sets a external symbol to the geometry, e.g. style from VectorLayer's setStyle\n     * @private\n     * @param {Object} symbol - external symbol\n     */\n    _setExternSymbol(symbol: any): this;\n    _getInternalSymbol(): any;\n    _getPrjExtent(): Extent;\n    _unbind(): void;\n    _getInternalId(): number;\n    _setInternalId(id: number): void;\n    _getMeasurer(): any;\n    _getProjection(): WithNull<ProjectionType>;\n    _verifyProjection(): void;\n    _getExternalResources(): string[];\n    _getPainter(): any;\n    _getMaskPainter(): CollectionPainter | Painter;\n    _removePainter(): void;\n    _paint(extent?: Extent): void;\n    _clearCache(): void;\n    _clearProjection(): void;\n    _repaint(): void;\n    onHide(): void;\n    onShapeChanged(): void;\n    onPositionChanged(): void;\n    onSymbolChanged(): void;\n    _genSizeSymbol(): void;\n    _getSizeSymbol(symbol: any): any;\n    _getCompiledSymbol(): any;\n    onConfig(conf: any): void;\n    /**\n     * 将父对象设置为几何体，通常是“多重多边形”、“几何集合”等\n     * @english\n     * Set a parent to the geometry, which is usually a MultiPolygon, GeometryCollection, etc\n     * @param {GeometryCollection} geometry - parent geometry\n     * @private\n     */\n    _setParent(geometry?: Geometry | GeometryCollection): void;\n    _getParent(): any;\n    _fireEvent(eventName: string, param?: BaseEventParamsType): void;\n    _toJSON(options?: any): any;\n    _exportGraphicOptions(options: any): any;\n    _exportGeoJSONGeometry(): any;\n    _exportProperties(): any;\n    _hitTestTolerance(): number;\n    _getAltitude(): number | number[] | number[][];\n    getAltitude(): number | number[] | number[][];\n    hasAltitude(): boolean;\n    setAltitude(alt: number): this;\n    _genMinMaxAlt(): void;\n    getMinAltitude(): number;\n    getMaxAltitude(): number;\n    _clearAltitudeCache(): Geometry;\n}\nexport type GeometryOptionsType = {\n    id?: string;\n    visible?: boolean;\n    interactive?: boolean;\n    editable?: boolean;\n    cursor?: string;\n    antiMeridian?: boolean;\n    defaultProjection?: string;\n    measure?: string;\n    draggable?: boolean;\n    dragShadow?: boolean;\n    dragOnAxis?: string;\n    dragOnScreenAxis?: boolean;\n    zIndex?: number;\n    symbol?: any;\n    properties?: {\n        [key: string]: any;\n    };\n};\nexport default Geometry;\n"},{"path":"geometry/GeometryCollection.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport PointExtent from '../geo/PointExtent';\nimport Extent from '../geo/Extent';\nimport Geometry, { GeometryOptionsType } from './Geometry';\nimport * as projections from '../geo/projection';\nimport Point from '../geo/Point';\nimport { GeometryEditOptionsType } from './ext/Geometry.Edit';\ntype ProjectionCommon = typeof projections.Common;\n/**\n * @classdesc\n * Represents a GeometryCollection.\n * @category geometry\n * @extends Geometry\n * @example\n * var marker = new Marker([0, 0]),\n *     line = new LineString([[0, 0], [0, 1]]),\n *     polygon = new Polygon([[0, 0], [0, 1], [1, 3]]);\n * var collection = new GeometryCollection([marker, line, polygon])\n *     .addTo(layer);\n */\ndeclare class GeometryCollection extends Geometry {\n    _geometries: Geometry[];\n    _pickGeometryIndex: number;\n    _originalSymbol: any;\n    _draggbleBeforeEdit: any;\n    _editing: boolean;\n    /**\n     * @param {Geometry[]} geometries - GeometryCollection's geometries\n     * @param {Object} [options=null] - options defined in [nGeometryCollection]{@link GeometryCollection#options}\n     */\n    constructor(geometries?: Geometry[], opts?: GeometryOptionsType);\n    getContainerExtent(out?: PointExtent): PointExtent;\n    /**\n     * 将多个几何图形设置到几何图形集合\n     * @english\n     * Set new geometries to the geometry collection\n     * @param {Geometry[]} geometries\n     * @return {GeometryCollection} this\n     * @fires GeometryCollection#shapechange\n     */\n    setGeometries(_geometries: Geometry[]): this;\n    /**\n     * 获取几何集合中的几何图形们\n     * @english\n     * Get geometries of the geometry collection\n     * @return {Geometry[]} geometries\n     */\n    getGeometries(): Geometry[];\n    /**\n     * 按顺序对集合中存在的每个几何体执行一次提供的回调。\n     * @english\n     * Executes the provided callback once for each geometry present in the collection in order.\n     * @param  {Function} fn             - a callback function\n     * @param  {*} [context=undefined]   - callback's context\n     * @return {GeometryCollection} this\n     */\n    forEach(fn: (geo: Geometry, index: number) => void, context?: any): this;\n    /**\n     * 创建一个几何集合类，这个集合类的所有元素都通过所提供的函数实现的测试\n     * @english\n     * Creates a GeometryCollection with all elements that pass the test implemented by the provided function.\n     * @param  {Function} fn      - Function to test each geometry\n     * @param  {*} [context=undefined]    - Function's context\n     * @return {GeometryCollection} A GeometryCollection with all elements that pass the test\n     * @example\n     * var filtered = collection.filter(['==', 'foo', 'bar]);\n     * @example\n     * var filtered = collection.filter(geometry => geometry.getProperties().foo === 'bar');\n     */\n    filter(fn?: (geo: Geometry) => boolean, context?: any): GeometryCollection;\n    /**\n     * 按给定偏移平移或移动几何体集合。\n     * @english\n     * Translate or move the geometry collection by the given offset.\n     * @param  {Coordinate} offset - translate offset\n     * @return {GeometryCollection} this\n     */\n    translate(offset: Coordinate): this;\n    /**\n     * 几何图形集合是否为空\n     * @english\n     * Whether the geometry collection is empty\n     * @return {Boolean}\n     */\n    isEmpty(): boolean;\n    /**\n     * 移除本身，如果图层含有的话\n     * @english\n     * remove itself from the layer if any.\n     * @returns {Geometry} this\n     * @fires GeometryCollection#removestart\n     * @fires GeometryCollection#remove\n     * @fires GeometryCollection#removeend\n     */\n    remove(): any;\n    /**\n     * 显示几何集合\n     * @english\n     * Show the geometry collection.\n     * @return {GeometryCollection} this\n     * @fires GeometryCollection#show\n     */\n    show(): this;\n    /**\n     * 隐藏几何集合\n     * @english\n     * Hide the geometry collection.\n     * @return {GeometryCollection} this\n     * @fires GeometryCollection#hide\n     */\n    hide(): this;\n    onConfig(config?: string | Record<string, any>): void;\n    getSymbol(): any;\n    setSymbol(s?: any): this;\n    _setExternSymbol(symbol: any): this;\n    /**\n     * 绑定几何几何到一个图层\n     * @english\n     * bind this geometry collection to a layer\n     * @param  {Layer} layer\n     * @private\n     */\n    _bindLayer(): void;\n    _bindGeometriesToLayer(): void;\n    /**\n     * 检查几何图形的类型是否有效\n     * @english\n     * Check whether the type of geometries is valid\n     * @param  {Geometry[]} geometries - geometries to check\n     * @private\n     */\n    _checkGeometries(geometries: Geometry[]): Geometry[];\n    _checkGeo(geo: Geometry): boolean;\n    _updateCache(): void;\n    _removePainter(): void;\n    _computeCenter(projection: null | ProjectionCommon): Coordinate;\n    _containsPoint(point: Point, t?: number): boolean;\n    _hitTestTolerance(): number;\n    _computeExtent(projection: null | ProjectionCommon): Extent;\n    _computePrjExtent(projection: null | ProjectionCommon): Extent;\n    _computeGeodesicLength(projection: null | ProjectionCommon): number;\n    _computeGeodesicArea(projection: null | ProjectionCommon): number;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        geometries: any[];\n    };\n    _toJSON(options?: any): any;\n    _clearProjection(): void;\n    /**\n     * 如果通过[ConnectorLine]连接，则获取连接点\n     * @english\n     * Get connect points if being connected by [ConnectorLine]{@link ConnectorLine}\n     * @private\n     * @return {Coordinate[]}\n     */\n    _getConnectPoints(): Coordinate[];\n    _getExternalResources(): any;\n    startEdit(opts?: GeometryEditOptionsType): this;\n    endEdit(): this;\n    isEditing(): boolean;\n}\nexport default GeometryCollection;\n"},{"path":"geometry/index.d.ts","content":"import Geometry from './Geometry';\nimport Marker from './Marker';\nimport LineString from './LineString';\nimport Polygon from './Polygon';\nimport MultiPoint from './MultiPoint';\nimport MultiLineString from './MultiLineString';\nimport MultiPolygon from './MultiPolygon';\nimport GeometryCollection from './GeometryCollection';\nimport GeoJSON from './GeoJSON';\nimport Circle from './Circle';\nimport Ellipse from './Ellipse';\nimport Rectangle from './Rectangle';\nimport Sector from './Sector';\nimport Curve from './Curve';\nimport ArcCurve from './ArcCurve';\nimport CubicBezierCurve from './CubicBezierCurve';\nimport QuadBezierCurve from './QuadBezierCurve';\nimport TextMarker from './TextMarker';\nimport TextBox from './TextBox';\nimport Label from './Label';\nimport { ConnectorLine, ArcConnectorLine } from './ConnectorLine';\nexport type Geometries = ArcCurve | Circle | ConnectorLine | ArcConnectorLine | CubicBezierCurve | Curve | Ellipse | Geometry | GeometryCollection | Label | LineString | Marker | MultiLineString | MultiPoint | MultiPolygon | Polygon | QuadBezierCurve | Rectangle | Sector | TextBox | TextMarker;\nexport type PathLikeGeometries = Curve | ArcCurve | CubicBezierCurve | QuadBezierCurve | LineString | MultiLineString | ConnectorLine | Rectangle | Polygon | MultiPolygon | Circle | Sector | Ellipse;\nexport { ArcCurve, Circle, ConnectorLine, ArcConnectorLine, CubicBezierCurve, Curve, Ellipse, GeoJSON, Geometry, GeometryCollection, Label, LineString, Marker, MultiLineString, MultiPoint, MultiPolygon, Polygon, QuadBezierCurve, Rectangle, Sector, TextBox, TextMarker };\n"},{"path":"geometry/Label.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport { TextSymbol, VectorMarkerSymbol } from '../symbol';\nimport TextMarker, { TextMarkerOptionsType } from './TextMarker';\n/**\n * @classdesc\n * Represents point type geometry for text labels.<br>\n * A label is used to draw text (with a box background if specified) on a particular coordinate.\n * @category geometry\n * @extends TextMarker\n * @mixes TextEditable\n * @example\n * var label = new maptalks.Label('label with a box',\n    [0, 0],\n    {\n      'draggable' : true,\n      'boxStyle' : {\n        'padding' : [12, 8],\n        'verticalAlignment' : 'top',\n        'horizontalAlignment' : 'right',\n        'minWidth' : 300,\n        'minHeight' : 200,\n        'symbol' : {\n          'markerType' : 'square',\n          'markerFill' : 'rgb(135,196,240)',\n          'markerFillOpacity' : 0.9,\n          'markerLineColor' : '#34495e',\n          'markerLineWidth' : 1\n        }\n      },\n      'textSymbol': {\n        'textFaceName' : 'monospace',\n        'textFill' : '#34495e',\n        'textHaloFill' : '#fff',\n        'textHaloRadius' : 4,\n        'textSize' : 18,\n        'textWeight' : 'bold',\n        'textVerticalAlignment' : 'top'\n      }\n    });\n */\ndeclare class Label extends TextMarker {\n    options: any;\n    /**\n     * @param {String} content                 - Label's text content\n     * @param {Coordinate} coordinates         - coordinates\n     * @param {Object} [options=null]          - construct options defined in [Label]{@link Label#options}\n     */\n    constructor(content: string, coordinates: Coordinate | Array<number>, options?: LabelOptionsType);\n    /**\n     * 获取标注的边框样式\n     * @english\n     * Get label's box style\n     * @return {Object}\n     */\n    getBoxStyle(): BoxStyle;\n    /**\n     * 设置标注的边框样式\n     * @english\n     * Set a new box style to the label\n     * @param {Object}\n     * @returns {Label} this\n     */\n    setBoxStyle(style: BoxStyle): this;\n    /**\n     * 获取标注的文本样式\n     * Get label's text symbol\n     * @return {Object}\n     */\n    getTextSymbol(): TextSymbol;\n    /**\n     * 给标注设置新的文本样式\n     * @english\n     * Set a new text symbol to the label\n     * @param {Object} symbol\n     * @returns {Label} this\n     */\n    setTextSymbol(symbol: TextSymbol): this;\n    static fromJSON(json: {\n        [key: string]: any;\n    }): Label;\n    _canEdit(): boolean;\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        content: string;\n    };\n    _refresh(): void;\n    _getBoxSize(symbol: any): any;\n}\nexport default Label;\ntype BoxStyle = {\n    padding?: [number, number];\n    verticalAlignment?: 'top' | 'middle' | 'bottom';\n    horizontalAlignment?: 'left' | 'middle' | 'right';\n    minWidth?: number;\n    minHeight?: number;\n    symbol?: VectorMarkerSymbol;\n};\nexport type LabelOptionsType = TextMarkerOptionsType & {\n    textSymbol?: TextSymbol;\n    boxStyle?: BoxStyle;\n};\n"},{"path":"geometry/LineString.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Path, { PathOptionsType } from './Path';\nimport Extent from '../geo/Extent';\nimport { AnySymbol, LineSymbol } from '../symbol';\n/**\n * 表示LineString类型的Geometry。\n * @english\n * Represents a LineString type Geometry.\n * @category geometry\n * @extends Path\n * @example\n * var line = new LineString(\n *     [\n *         [121.45942, 31.24123],\n *         [121.46371, 31.24226],\n *         [121.46727, 31.23870],\n *         [121.47019, 31.24145]\n *     ]\n * ).addTo(layer);\n */\nexport declare class LineString extends Path {\n    /**\n     * @param {Coordinate[]|Number[][]} coordinates - coordinates of the line string\n     * @param {Object} [options=null] - construct options defined in [LineString]{@link LineString#options}\n     */\n    constructor(coordinates: LineStringCoordinatesType, options?: LineStringOptionsType);\n    getOutline(): any;\n    /**\n     * 给线段设置坐标\n     * @english\n     * Set new coordinates to the line string\n     * @param {Coordinate[]|Number[][]} coordinates - new coordinates\n     * @fires LineString#shapechange\n     * @return {LineString} this\n     */\n    setCoordinates(coordinates: Array<Coordinate> | Array<Array<number>>): this;\n    /**\n     * 获取线段的坐标\n     * @english\n     * Get coordinates of the line string\n     * @return {Coordinate[]|Number[][]} coordinates\n     */\n    getCoordinates(): Coordinate[];\n    /**\n     * 获取具有给定范围的线串的交点的中心\n     * @english\n     * Get center of linestring's intersection with give extent\n     * @example\n     *  const extent = map.getExtent();\n     *  const center = line.getCenterInExtent(extent);\n     * @param {Extent} extent\n     * @return {Coordinate} center, null if line doesn't intersect with extent\n     */\n    getCenterInExtent(extent: Extent): Coordinate;\n    _computeGeodesicLength(measurer: any): number;\n    _computeGeodesicArea(): number;\n}\nexport default LineString;\nexport type LineStringCoordinatesType = Array<Coordinate> | Array<Array<number>>;\nexport type LineStringOptionsType = PathOptionsType & {\n    arrowStyle?: 'classic' | [number, number];\n    arrowPlacement?: 'vertex-first' | 'vertex-last' | 'vertex-firstlast' | 'point';\n    symbol?: LineSymbol | Array<AnySymbol>;\n};\n"},{"path":"geometry/Marker.d.ts","content":"import Extent from '../geo/Extent';\nimport PointExtent from '../geo/PointExtent';\nimport Geometry, { GeometryOptionsType } from './Geometry';\nimport { AnyMarkerSymbol } from '../symbol';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\ndeclare const Marker_base: {\n    new (...args: any[]): {\n        _coordinates: Coordinate;\n        _pcenter: Coordinate;\n        _dirtyCoords: boolean;\n        getMap?(): import(\"src\").Map;\n        _getProjection?(): {\n            code: string;\n            is(code: string): boolean;\n            project(p: Coordinate): Coordinate;\n            unproject(p: Coordinate): Coordinate;\n            projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            isSphere(): boolean;\n            isOutSphere(pcoord: Coordinate): boolean;\n            wrapCoord(pcoord: Coordinate): Coordinate;\n            getCircum(): Record<string, number>;\n            getSphereExtent(): Extent;\n        };\n        onPositionChanged?(): void;\n        _verifyProjection?(): void;\n        _clearCache?(): void;\n        getCoordinates(): Coordinate;\n        setCoordinates(coordinates: number[] | Coordinate): any;\n        _getCenter2DPoint(res?: number): Point;\n        _getPrjCoordinates(): Coordinate;\n        _setPrjCoordinates(pcenter: Coordinate): void;\n        _updateCache(): void;\n        _clearProjection(): void;\n        _computeCenter(): Coordinate;\n    };\n} & typeof Geometry;\n/**\n * @classdesc\n * Represents a Point type Geometry.\n * @category geometry\n * @extends Geometry\n * @mixes CenterMixin\n * @example\n * var marker = new Marker([100, 0], {\n *     'id' : 'marker0',\n *     'symbol' : {\n *         'markerFile'  : 'foo.png',\n *         'markerWidth' : 20,\n *         'markerHeight': 20,\n *     },\n *     'properties' : {\n *         'foo' : 'value'\n *     }\n * });\n */\nexport declare class Marker extends Marker_base {\n    isPoint: boolean;\n    /**\n     * @param {Coordinate} coordinates      - coordinates of the marker\n     * @param {Object} [options=null]       - construct options defined in [Marker]{@link Marker#options}\n     */\n    constructor(coordinates: MarkerCoordinatesType, options?: MarkerOptionsType);\n    getOutline(): Marker;\n    setSymbol(symbol: AnyMarkerSymbol): this;\n    _getSizeSymbol(symbol: any): any;\n    _setExternSymbol(symbol: any): this;\n    _isDynamicSize(): boolean;\n    _getFixedExtent(): PointExtent;\n    _isVectorMarker(): boolean;\n    /**\n     * 可以编辑，只能编辑带有矢量符号、矢量路径符号或图像符号的标记。\n     * @english\n     * Can be edited, only marker with a vector symbol, vector path symbol or a image symbol can be edited.\n     * @return {Boolean}\n     * @private\n     */\n    _canEdit(): boolean;\n    _containsPoint(point: Point, t?: number): boolean;\n    _computeExtent(): Extent;\n    _computePrjExtent(): Extent;\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _getSprite(resources: any, canvasClass: any): any;\n}\nexport default Marker;\nexport type MarkerCoordinatesType = Coordinate | Array<number>;\nexport type MarkerOptionsType = GeometryOptionsType & {\n    hitTestForEvent?: boolean;\n    collision?: boolean;\n    symbol?: AnyMarkerSymbol | Array<AnyMarkerSymbol>;\n};\n"},{"path":"geometry/MultiGeometry.d.ts","content":"import GeometryCollection from './GeometryCollection';\nimport { GeometryOptionsType, type Geometry } from './Geometry';\nimport { MultiPathsCoordinates, PathCoordinates, PathsCoordinates } from './Path';\nimport { MarkerCoordinatesType } from './Marker';\nimport { LineStringCoordinatesType } from './LineString';\nimport { PolygonCoordinatesType } from './Polygon';\n/**\n * MultiPoint、MultiLineString和MultiPolygon的父类\n * @english\n * The parent class for MultiPoint, MultiLineString and MultiPolygon\n * @category geometry\n * @abstract\n * @extends {GeometryCollection}\n */\ntype MultiGeometryCoordinates = PathCoordinates | PathsCoordinates | MultiPathsCoordinates;\ntype SingleGeometryCreateCoordinates = MarkerCoordinatesType | LineStringCoordinatesType | PolygonCoordinatesType;\nexport type MultiGeometryCreateCoordinates = Array<SingleGeometryCreateCoordinates>;\ntype MultiGeometryData = Array<SingleGeometryCreateCoordinates | Geometry>;\ntype GeometryClass<T> = (new (coordinates: SingleGeometryCreateCoordinates, options: Record<string, any>) => T);\ndeclare class MultiGeometry extends GeometryCollection {\n    GeometryType: GeometryClass<Geometry>;\n    /**\n     * @param  {Class} geoType      Type of the geometry\n     * @param  {String} type        type in String, e.g. \"MultiPoint\", \"MultiLineString\"\n     * @param  {Geometry[]} data    data\n     * @param  {Object} [options=null] configuration options\n     */\n    constructor(geoType: GeometryClass<Geometry>, type: string, data: MultiGeometryData, options?: GeometryOptionsType);\n    /**\n     * 获取集合中得坐标\n     * @english\n     * Get coordinates of the collection\n     * @return {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates\n     */\n    getCoordinates(): MultiGeometryCoordinates;\n    /**\n     * 设置集合得坐标\n     * @english\n     * Set new coordinates to the collection\n     * @param {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates\n     * @returns {Geometry} this\n     * @fires maptalk.Geometry#shapechange\n     */\n    setCoordinates(coordinates: MultiGeometryCreateCoordinates): this;\n    _initData(data: MultiGeometryData): void;\n    _checkGeo(geo: Geometry): boolean;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        coordinates: any;\n    };\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n    };\n}\nexport default MultiGeometry;\n"},{"path":"geometry/MultiLineString.d.ts","content":"import MultiPath from './MultiPath';\nimport { LineStringCoordinatesType, LineStringOptionsType } from './LineString';\n/**\n * @classdesc\n * Represents a Geometry type of MultiLineString\n * @category geometry\n * @extends MultiGeometry\n * @example\n * var multiLineString = new MultiLineString(\n *      [\n *          [\n *              [121.5289450479131, 31.2420083925986],\n *              [121.52860172515919, 31.238926401171824]\n *          ],\n *          [\n *              [121.53091915374796, 31.241898323208233],\n *              [121.53104789978069, 31.23859618183896]\n *          ],\n *          [\n *               [121.5324641061405, 31.241898323208233],\n *               [121.53242119079626, 31.239146546752256]\n *           ]\n *       ],\n *       {\n *           symbol:{\n *               'lineColor' : '#000000',\n *               'lineWidth' : 5,\n *               'lineOpacity' : 1\n *           },\n *          draggable:true\n *      }\n * ).addTo(layer);\n */\ndeclare class MultiLineString extends MultiPath {\n    /**\n     * @param {Number[][][]|Coordinate[][]|LineString[]} data - construct data, coordinates or an array of linestrings\n     * @param {Object} [options=null]           - options defined in [MultiLineString]{@link MultiLineString#options}\n     */\n    constructor(data: Array<LineStringCoordinatesType>, options?: LineStringOptionsType);\n}\nexport default MultiLineString;\n"},{"path":"geometry/MultiPath.d.ts","content":"import MultiGeometry from './MultiGeometry';\nimport Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\n/**\n * @classdesc\n * An abstract class for MultiPolygon and MultiLineString\n * @category geometry\n * @extends MultiGeometry\n */\ndeclare class MultiPath extends MultiGeometry {\n    /**\n     * 获取（MultiLineString或MultiPolygon）与给定范围的交点的中心\n     * @english\n     * Get center of (MultiLineString or MultiPolygon)'s intersection with give extent\n     * @example\n     *  const extent = map.getExtent();\n     *  const center = geometry.getCenterInExtent(extent);\n     * @param {Extent} extent\n     * @return {Coordinate} center, null if line doesn't intersect with extent\n     */\n    getCenterInExtent(extent: Extent): null | Coordinate;\n}\nexport default MultiPath;\n"},{"path":"geometry/MultiPoint.d.ts","content":"import MultiGeometry from './MultiGeometry';\nimport { MarkerCoordinatesType, MarkerOptionsType } from './Marker';\nimport Coordinate from '../geo/Coordinate';\n/**\n * @classdesc\n * Represents a Geometry type of MultiPoint.\n * @category geometry\n * @extends MultiGeometry\n * @example\n * var multiPoint = new MultiPoint(\n *     [\n *         [121.5080881906138, 31.241128104458117],\n *         [121.50804527526954, 31.237238340103413],\n *         [121.5103728890997, 31.23888972560888]\n *     ]\n * ).addTo(layer);\n */\ndeclare class MultiPoint extends MultiGeometry {\n    /**\n     * @param {Number[][]|Coordinate[]|Marker[]} data - construct data, coordinates or an array of markers\n     * @param {Object} [options=null] - options defined in [nMultiPoint]{@link MultiPoint#options}\n     */\n    constructor(data: Array<MarkerCoordinatesType>, opts?: MarkerOptionsType);\n    /**\n     * 找到给定坐标的最近点\n     * @english\n     * Find the closet point to the give coordinate\n     * @param {Coordinate} coordinate coordinate\n     * @returns {Coordinate} coordinate\n     */\n    findClosest(coordinate: Coordinate): Coordinate;\n}\nexport default MultiPoint;\n"},{"path":"geometry/MultiPolygon.d.ts","content":"import MultiPath from './MultiPath';\nimport { PolygonCoordinatesType, PolygonOptionsType } from './Polygon';\n/**\n * @classdesc\n * Represents a Geometry type of MultiPolygon\n * @category geometry\n * @extends MultiGeometry\n * @example\n * var multiPolygon = new MultiPolygon(\n *       [\n *           [\n *               [\n *                   [121.55074604278596, 31.242008515751614],\n *                   [121.55074604278596, 31.23914637638951],\n *                   [121.55349262481711, 31.23914637638951],\n *                   [121.55349262481711, 31.24134802974913],\n *                   [121.5518618417361, 31.241384723537074],\n *                   [121.55074604278596, 31.242008515751614]\n *               ]\n *           ],\n *           [\n *               [\n *                   [121.5543080163576, 31.241054478932387],\n *                   [121.5543938470461, 31.240100432478293],\n *                   [121.55555256134048, 31.240173821009137],\n *                   [121.55542381530773, 31.240981091085693],\n *                   [121.5543080163576, 31.241054478932387]\n *               ]\n *           ]\n *\n *       ],\n *       {\n *           symbol:{\n *               'lineColor' : '#000000',\n *               'lineWidth' : 2,\n *               'lineDasharray' : null,//线形\n *               'lineOpacity' : 1,\n *               'polygonFill' : 'rgb(255, 0, 0)',\n *               'polygonOpacity' : 0.8\n *           },\n *           draggable:true\n * }).addTo(layer);\n */\ndeclare class MultiPolygon extends MultiPath {\n    /**\n     * @param {Number[][][][]|Coordinate[][][]|Polygon[]} data - construct data, coordinates or an array of polygons\n     * @param {Object} [options=null]           - options defined in [MultiPolygon]{@link MultiPolygon#options}\n     */\n    constructor(data: Array<PolygonCoordinatesType>, opts?: PolygonOptionsType);\n}\nexport default MultiPolygon;\n"},{"path":"geometry/Path.d.ts","content":"import { AnimationOptionsType, Frame, Player } from '../core/Animation';\nimport Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\nimport Geometry, { GeometryOptionsType } from './Geometry';\nimport Point from '../geo/Point';\nimport { CommonProjectionType } from '../geo/projection';\nimport { FillSymbol, LineSymbol } from '../symbol';\ntype animateShowCallback = (frame: Frame, currentCoord: Coordinate) => void;\nexport type PathCoordinates = Array<Coordinate>;\nexport type PathsCoordinates = Array<PathCoordinates>;\nexport type MultiPathsCoordinates = Array<PathsCoordinates>;\n/**\n * 一个抽象类Path，包含Path几何类的常用方法，例如LineString、Polygon\n * @english\n * An abstract class Path containing common methods for Path geometry classes, e.g. LineString, Polygon\n * @abstract\n * @category geometry\n * @extends Geometry\n */\nexport declare class Path extends Geometry {\n    _coordinates: Coordinate[];\n    _showPlayer: Player;\n    _animIdx: number;\n    _animLenSoFar: number;\n    _animTailRatio: number;\n    _prjAniShowCenter: Coordinate;\n    _aniShowCenter: Coordinate;\n    _tempCoord: Coordinate;\n    _tempPrjCoord: Point;\n    _simplified: boolean;\n    _prjCoords: Array<Coordinate>;\n    hasHoles?(): boolean;\n    _getPrjHoles?(): Array<Array<Coordinate>>;\n    /**\n     * 动画展示线条\n     * @english\n     * Show the linestring with animation\n     * @param  {Object} [options=null] animation options\n     * @param  {Number} [options.duration=1000] duration\n     * @param  {String} [options.easing=out] animation easing\n     * @param  {Function} [cb=null] callback function in animation, function parameters: frame, currentCoord\n     * @example\n     *  line.animateShow({\n     *    duration : 2000,\n     *    easing : 'linear'\n     *  }, function (frame, currentCoord) {\n     *    //frame is the animation frame\n     *    //currentCoord is current coordinate of animation\n     *  });\n     * @return {LineString}         this\n     */\n    animateShow(options?: (AnimationOptionsType | animateShowCallback), cb?: animateShowCallback): Player | undefined;\n    _drawAnimShowFrame(t: number, duration: number, length: number, coordinates: Coordinate[], prjCoords: Array<Coordinate>): Coordinate;\n    _getCenterInExtent(extent: Extent, coordinates: Coordinate[], clipFn: any): Coordinate;\n    /**\n     * 将投影坐标转换为视点\n     * @english\n     * Transform projected coordinates to view points\n     * @param  {Coordinate[]} prjCoords           - projected coordinates\n     * @param  {Boolean} disableSimplify          - whether to disable simplify\\\n     * @param  {Number} zoom                      - 2d points' zoom level\n     * @returns {Point[]}\n     * @private\n     */\n    _getPath2DPoints(prjCoords: PathCoordinates | PathsCoordinates, disableSimplify: boolean, res?: number): Point | Array<Point> | Array<Array<Point>>;\n    _shouldSimplify(): boolean;\n    _setPrjCoordinates(prjPoints: PathCoordinates): void;\n    _getPrjCoordinates(): PathCoordinates;\n    _updateCache(): void;\n    _clearProjection(): void;\n    _projectCoords(points: PathCoordinates | PathsCoordinates): PathCoordinates | PathsCoordinates;\n    _unprojectCoords(prjPoints: PathCoordinates | PathsCoordinates): PathCoordinates | PathsCoordinates;\n    _computeCenter(): null | Coordinate;\n    _computeExtent(_?: any): Extent;\n    _computePrjExtent(_?: any): Extent;\n    _get2DLength(): number;\n    _hitTestTolerance(): number;\n    _coords2Extent(coords: PathsCoordinates, proj?: CommonProjectionType): Extent;\n}\nexport default Path;\nexport type PathOptionsType = GeometryOptionsType & {\n    'smoothness'?: boolean;\n    'enableClip'?: boolean;\n    'enableSimplify'?: boolean;\n    'simplifyTolerance'?: number;\n    'symbol'?: FillSymbol | LineSymbol;\n};\n"},{"path":"geometry/Polygon.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Path, { PathCoordinates, PathOptionsType, PathsCoordinates } from './Path';\nimport Extent from '../geo/Extent';\nimport { AnySymbol, FillSymbol } from '../symbol';\nimport { LineStringCoordinatesType } from './LineString';\n/**\n * @classdesc\n * Geometry class for polygon type\n * @category geometry\n * @extends Path\n * @example\n * var polygon = new Polygon(\n *      [\n *          [\n *              [121.48053653961283, 31.24244899384889],\n *              [121.48049362426856, 31.238559229494186],\n *              [121.49032123809872, 31.236210614999653],\n *              [121.49366863494917, 31.242926029397037],\n *              [121.48577221160967, 31.243880093267567],\n *              [121.48053653961283, 31.24244899384889]\n *          ]\n *      ]\n *  ).addTo(layer);\n */\nexport type PolygonCoordinatesType = Array<Array<Coordinate>> | Array<Array<number>>;\nexport type RingCoordinates = PathCoordinates;\nexport type RingsCoordinates = PathsCoordinates;\nexport declare class Polygon extends Path {\n    _holes: RingsCoordinates;\n    _prjHoles: RingsCoordinates;\n    _prjShell: RingCoordinates;\n    _getShell?(): RingCoordinates;\n    /**\n     * @param {Number[][]|Number[][][]|Coordinate[]|Coordinate[][]} coordinates - coordinates, shell coordinates or all the rings.\n     * @param {Object} [options=null] - construct options defined in [Polygon]{@link Polygon#options}\n     */\n    constructor(coordinates: PolygonCoordinatesType | LineStringCoordinatesType, options?: PolygonOptionsType);\n    getOutline(): null | Polygon;\n    /**\n     * 设置多边形坐标\n     * @english\n     * Set coordinates to the polygon\n     *\n     * @param {Number[][]|Number[][][]|Coordinate[]|Coordinate[][]} coordinates - new coordinates\n     * @return {Polygon} this\n     * @fires Polygon#shapechange\n     */\n    setCoordinates(coordinates: PolygonCoordinatesType | LineStringCoordinatesType): this;\n    /**\n     * 获取多边形坐标\n     * @english\n     * Gets polygons's coordinates\n     *\n     * @returns {Coordinate[][]}\n     */\n    getCoordinates(): RingsCoordinates;\n    /**\n     * 获取具有给定范围的线串的交点的中心\n     * @english\n     * Get center of linestring's intersection with give extent\n     * @example\n     *  const extent = map.getExtent();\n     *  const center = line.getCenterInExtent(extent);\n     * @param {Extent} extent\n     * @return {Coordinate} center, null if line doesn't intersect with extent\n     */\n    getCenterInExtent(extent: Extent): Coordinate;\n    /**\n     * 获取多边形的外壳坐标\n     * @english\n     * Gets shell's coordinates of the polygon\n     *\n     * @returns {Coordinate[]}\n     */\n    getShell(): RingCoordinates;\n    /**\n     * 获取多边形的洞的坐标（如果有）。\n     * @english\n     * Gets holes' coordinates of the polygon if it has.\n     * @returns {Coordinate[][]}\n     */\n    getHoles(): RingsCoordinates;\n    /**\n     * 判断多边形是否带有洞\n     * @english\n     * Whether the polygon has any holes inside.\n     *\n     * @returns {Boolean}\n     */\n    hasHoles(): boolean;\n    _projectRings(): void;\n    _setPrjCoordinates(prjCoords: RingCoordinates): void;\n    _cleanRing(ring: RingCoordinates): void;\n    /**\n     * 检查环是否有效\n     * @english\n     * Check if ring is valid\n     * @param  {*} ring ring to check\n     * @return {Boolean} is ring a closed one\n     * @private\n     */\n    _checkRing(ring: RingCoordinates): boolean;\n    /**\n     * 如果第一个坐标与最后一个坐标相等，则删除最后一个座标。\n     * @english\n     * If the first coordinate is equal with the last one, then remove the last coordinates.\n     * @private\n     */\n    _trimRing(ring: RingCoordinates): RingCoordinates;\n    /**\n     * 如果第一个坐标与最后一个不同，则复制第一个坐标并添加到环中。\n     * @english\n     * If the first coordinate is different with the last one, then copy the first coordinates and add to the ring.\n     * @private\n     */\n    _copyAndCloseRing(ring: RingCoordinates): RingCoordinates;\n    _getPrjShell(): RingCoordinates;\n    _getPrjHoles(): RingsCoordinates;\n    _computeGeodesicLength(measurer: any): number;\n    _computeGeodesicArea(measurer: any): number;\n    _updateCache(): void;\n    _clearCache(): any;\n    _clearProjection(): void;\n}\nexport default Polygon;\nexport type PolygonOptionsType = PathOptionsType & {\n    'symbol'?: FillSymbol | Array<AnySymbol>;\n};\n"},{"path":"geometry/QuadBezierCurve.d.ts","content":"import Curve, { CurveOptionsType } from './Curve';\n/**\n * @classdesc\n * Quadratic Bezier Curve\n * @category geometry\n * @extends Curve\n * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve\n * @example\n * var curve = new QuadBezierCurve(\n *     [\n *         [121.47083767181408,31.214448123476995],\n *         [121.4751292062378,31.215475523000404],\n *         [121.47869117980943,31.211916269810335]\n *     ],\n *     {\n *         symbol : {\n *             'lineWidth' : 5\n *         }\n *     }\n * ).addTo(layer);\n */\ndeclare class QuadBezierCurve extends Curve {\n    static fromJSON(json: any): QuadBezierCurve;\n    _toJSON(options: any): any;\n    _paintOn(ctx: CanvasRenderingContext2D, points: any, lineOpacity: number): void;\n    _getArrowPoints(arrows: any[], segments: [], lineWidth: number, arrowStyle: any, tolerance: any): void;\n}\nexport default QuadBezierCurve;\nexport type QuadBezierCurveOptionsType = CurveOptionsType;\n"},{"path":"geometry/Rectangle.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\nimport Point from '../geo/Point';\nimport { CommonProjectionType } from '../geo/projection';\nimport Polygon, { PolygonOptionsType, RingCoordinates, RingsCoordinates } from './Polygon';\n/**\n * @classdesc\n * Represents a Rectangle geometry.\n * @category geometry\n * @extends Polygon\n * @example\n * var rectangle = new Rectangle([100, 0], 1000, 500, {\n *     id : 'rectangle0'\n * });\n */\nexport declare class Rectangle extends Polygon {\n    _coordinates: Coordinate;\n    _width: number;\n    _height: number;\n    _pnw: any;\n    static fromJSON(json: any): Rectangle;\n    /**\n     * @param {Coordinate} coordinates  - northwest of the rectangle\n     * @param {Number} width                     - width of the rectangle, in meter\n     * @param {Number} height                    - height of the rectangle, in meter\n     * @param {Object} [options=null]            - options defined in [Rectangle]{@link Rectangle#options}\n     */\n    constructor(coordinates: Coordinate | Array<number>, width: number, height: number, opts?: RectangleOptionsType);\n    /**\n     * Get coordinates of rectangle's northwest\n     * @return {Coordinate}\n     */\n    getCoordinates(): Coordinate;\n    /**\n     * Set a new coordinate for northwest of the rectangle\n     * @param {Coordinate} nw - coordinates of new northwest\n     * @return {Rectangle} this\n     * @fires Rectangle#positionchange\n     */\n    setCoordinates(nw: Coordinate | Array<number>): this;\n    /**\n     * Get rectangle's width\n     * @return {Number}\n     */\n    getWidth(): number;\n    /**\n     * Set new width to the rectangle\n     * @param {Number} width - new width\n     * @fires Rectangle#shapechange\n     * @return {Rectangle} this\n     */\n    setWidth(width: number): this;\n    /**\n     * Get rectangle's height\n     * @return {Number}\n     */\n    getHeight(): number;\n    /**\n     * Set new height to rectangle\n     * @param {Number} height - new height\n     * @fires Rectangle#shapechange\n     * @return {Rectangle} this\n     */\n    setHeight(height: number): this;\n    /**\n     * Gets the shell of the rectangle as a polygon\n     * @return {Coordinate[]} - shell coordinates\n     */\n    getShell(): Coordinate[];\n    _getShell(): RingCoordinates;\n    /**\n     * Rectangle won't have any holes, always returns null\n     * @return {Object[]} an empty array\n     */\n    getHoles(): RingsCoordinates;\n    animateShow(): this;\n    _getPrjCoordinates(): Coordinate;\n    _setPrjCoordinates(pnw: any): void;\n    _getPrjShell(): RingCoordinates;\n    _updateCache(): void;\n    _clearProjection(): void;\n    _computeCenter(measurer?: any): Coordinate;\n    _containsPoint(point: Point, tolerance?: number): boolean;\n    _computePrjExtent(projection: CommonProjectionType): Extent;\n    _computeExtent(measurer?: any): Extent;\n    _getSouthEast(measurer: any): Coordinate;\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        coordinates: any;\n    };\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        coordinates: number[];\n        width: number;\n        height: number;\n    };\n}\nexport default Rectangle;\nexport type RectangleOptionsType = PolygonOptionsType;\n"},{"path":"geometry/Sector.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\nimport Point from '../geo/Point';\nimport Circle, { CircleOptionsType } from './Circle';\nimport { RingCoordinates } from './Polygon';\n/**\n * @classdesc\n * Represents a sector Geometry.\n * @category geometry\n * @extends Circle\n * @example\n * var sector = new Sector([100, 0], 1000, 30, 120, {\n *     id : 'sector0'\n * });\n */\nexport declare class Sector extends Circle {\n    startAngle: number;\n    endAngle: number;\n    static fromJSON(json: Record<string, any>): Sector;\n    /**\n     * @param {Coordinate} center - center of the sector\n     * @param {Number} radius           - radius of the sector, in meter\n     * @param {Number} startAngle       - start angle of the sector, in degree\n     * @param {Number} endAngle         - end angle of the sector, in degree\n     * @param {Object} [options=null]   - construct options defined in [Sector]{@link Sector#options}\n     */\n    constructor(coordinates: Coordinate | Array<number>, radius: number, startAngle: number, endAngle: number, opts?: SectorOptionsType);\n    /**\n     * Get the sector's start angle\n     * @return {Number}\n     */\n    getStartAngle(): number;\n    /**\n     * Set a new start angle to the sector\n     * @param {Number} startAngle\n     * @return {Sector} this\n     * @fires Sector#shapechange\n     */\n    setStartAngle(startAngle: number): this;\n    /**\n     * Get the sector's end angle\n     * @return {Number}\n     */\n    getEndAngle(): number;\n    /**\n     * Set a new end angle to the sector\n     * @param {Number} endAngle\n     * @return {Sector} this\n     * @fires Sector#shapechange\n     */\n    setEndAngle(endAngle: number): this;\n    _correctAngles(): [number, number];\n    /**\n     * Gets the shell of the sector as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Sector#options}\n     * @return {Coordinate[]} - shell coordinates\n     */\n    getShell(): RingCoordinates;\n    _getShell(): RingCoordinates;\n    getRotateOffsetAngle(): number;\n    _getPrjShell(): RingCoordinates;\n    _computePrjExtent(): Extent;\n    _containsPoint(point: Point, tolerance?: number): boolean;\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        coordinates: number[];\n        radius: number;\n        startAngle: number;\n        endAngle: number;\n    };\n}\nexport default Sector;\nexport type SectorOptionsType = CircleOptionsType & {\n    numberOfShellPoints?: number;\n};\n"},{"path":"geometry/TextBox.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport TextMarker, { TextMarkerOptionsType } from './TextMarker';\nimport { TextSymbol, VectorMarkerSymbol } from '../symbol';\nimport { GeometryEditOptionsType } from './ext/Geometry.Edit';\n/**\n * @classdesc\n * Represents point type geometry for text boxes.<br>\n * A TextBox is used to draw a box with text inside on a particular coordinate.\n * @category geometry\n * @extends TextMarker\n * @mixes TextEditable\n * @example\n * var textbox = new maptalks.TextBox('This is a textbox',\n    [0, 0], 200, 90,\n    {\n      'draggable' : true,\n      'textStyle' : {\n        'wrap' : true,\n        'padding' : [12, 8],\n        'verticalAlignment' : 'top',\n        'horizontalAlignment' : 'right',\n        'symbol' : {\n          'textFaceName' : 'monospace',\n          'textFill' : '#34495e',\n          'textHaloFill' : '#fff',\n          'textHaloRadius' : 4,\n          'textSize' : 18,\n          'textWeight' : 'bold'\n        }\n      },\n      'boxSymbol': {\n        // box's symbol\n        'markerType' : 'square',\n        'markerFill' : 'rgb(135,196,240)',\n        'markerFillOpacity' : 0.9,\n        'markerLineColor' : '#34495e',\n        'markerLineWidth' : 1\n      }\n    });\n */\ndeclare class TextBox extends TextMarker {\n    options: TextBoxOptionsType;\n    _width: number;\n    _height: number;\n    _oldWidth: any;\n    _oldHeight: any;\n    /**\n     * @param {String} content                 - TextBox's text content\n     * @param {Coordinate} coordinates         - coordinates\n     * @param {Number} width                   - width in pixel\n     * @param {Number} height                  - height in pixel\n     * @param {Object} [options=null]          - construct options defined in [TextBox]{@link TextBox#options}\n     */\n    constructor(content: string, coordinates: Coordinate | Array<number>, width: number, height: number, options?: TextBoxOptionsType);\n    /**\n     * 获取文本框得宽度\n     * @english\n     * Get textbox's width\n     * @return {Number}\n     */\n    getWidth(): number;\n    /**\n     * 设置文本框得宽度\n     * @english\n     * Set new width to textbox\n     * @param {Number} width\n     * returns {TextBox} this\n     */\n    setWidth(width: number): this;\n    /**\n     * 获取文本框高度\n     * @english\n     * Get textbox's height\n     * @return {Number}\n     */\n    getHeight(): number;\n    /**\n     * 设置文本框高度\n     * @english\n     * Set new height to textbox\n     * @param {Number} height\n     * returns {TextBox} this\n     */\n    setHeight(height: number): this;\n    /**\n     * 获取文本框边框样式\n     * @english\n     * Get textbox's boxSymbol\n     * @return {Object} boxsymbol\n     */\n    getBoxSymbol(): VectorMarkerSymbol;\n    /**\n     * 设置文本框边框样式\n     * @english\n     * Set a new box symbol to textbox\n     * @param {Object} symbol\n     * returns {TextBox} this\n     */\n    setBoxSymbol(symbol: VectorMarkerSymbol): this;\n    /**\n     * 获取文本框文本样式\n     * @english\n     * Get textbox's text style\n     * @return {Object}\n     */\n    getTextStyle(): TextStyle | null;\n    /**\n     * 设置文本框文本样式\n     * @english\n     * Set a new text style to the textbox\n     * @param {Object} style new text style\n     * returns {TextBox} this\n     */\n    setTextStyle(style: TextStyle): this;\n    static fromJSON(json: {\n        [key: string]: any;\n    }): TextBox;\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        width: number;\n        height: number;\n        subType: string;\n        content: string;\n    };\n    _refresh(): void;\n    startEdit(opts: GeometryEditOptionsType): this;\n    endEdit(): this;\n}\nexport default TextBox;\ntype TextStyle = {\n    wrap?: boolean;\n    padding?: [number, number];\n    verticalAlignment?: 'top' | 'middle' | 'bottom';\n    horizontalAlignment?: 'left' | 'middle' | 'right';\n    symbol?: TextSymbol;\n};\nexport type TextBoxOptionsType = TextMarkerOptionsType & {\n    boxSymbol?: VectorMarkerSymbol;\n    textStyle?: TextStyle;\n};\n"},{"path":"geometry/TextMarker.d.ts","content":"/// <reference types=\"node\" />\nimport { AnyAaaaRecord } from 'dns';\nimport { TextSymbol, VectorMarkerSymbol } from '../symbol';\nimport Marker, { MarkerOptionsType } from './Marker';\n/**\n * @classdesc\n * Base class for  the Text marker classes, a marker which has text and background box. <br>\n * It is abstract and not intended to be instantiated.\n * @category geometry\n * @abstract\n * @extends Marker\n */\ndeclare class TextMarker extends Marker {\n    _content: string;\n    _refreshing: boolean;\n    _refresh?(): void;\n    getTextStyle?(): any;\n    setTextStyle?(tyle?: any): any;\n    setTextSymbol?(style?: any): any;\n    setBoxStyle?(style?: any): any;\n    getBoxStyle?(): any;\n    setBoxSymbol?(style?: any): any;\n    /**\n     * 获取标签的文本内容\n     * @english\n     * Get text content of the label\n     * @returns {String}\n     */\n    getContent(): string;\n    /**\n     * 给标签设置文本内容\n     * @english\n     * Set a new text content to the label\n     * @return {Label} this\n     * @fires Label#contentchange\n     */\n    setContent(content: string): this;\n    onAdd(): void;\n    toJSON(): {\n        [key: string]: any;\n    };\n    setSymbol(symbol: any): this;\n    _parseSymbol(symbol: any): any;\n    _getTextSize(symbol: any): any;\n    _getInternalSymbol(): AnyAaaaRecord;\n    _getDefaultTextSymbol(): TextSymbol;\n    _getDefaultBoxSymbol(): VectorMarkerSymbol;\n    _getDefaultPadding(): [number, number];\n}\nexport default TextMarker;\nexport type TextMarkerOptionsType = MarkerOptionsType;\n"},{"path":"GlobalConfig.d.ts","content":"/**\n * global config\n * idle/worker etc\n */\ndeclare const GlobalConfig: {\n    isTest: boolean;\n    idleLog: boolean;\n    idleTimeRemaining: number;\n    idleForceTimeThreshold: number;\n    idleTimeout: number;\n    workerCount: number;\n    taskCountPerWorkerMessage: number;\n    maxFPS: number;\n};\nexport default GlobalConfig;\n"},{"path":"handler/Drag.d.ts","content":"import Handler from './Handler';\nimport Point from '../geo/Point';\n/**\n * Drag handler\n * @category handler\n * @protected\n * @extends Handler\n */\ndeclare class DragHandler extends Handler {\n    options: DragOptionsType;\n    _onMouseDown: (e: any) => any;\n    moved: boolean;\n    startPos: Point;\n    interupted: boolean;\n    addHooks(): void;\n    removeHooks(): void;\n    constructor(dom: HTMLElement, options?: DragOptionsType);\n    enable(): this;\n    disable(): this;\n    onMouseDown(event: DragEventType): void;\n    onMouseMove(event: DragEventType): void;\n    onMouseUp(event: DragEventType): void;\n    _offEvents(): void;\n}\nexport default DragHandler;\ntype DragOptionsType = {\n    rightclick?: boolean;\n    cancelOn?: (e: DragEventType) => boolean;\n    ignoreMouseleave?: boolean;\n};\ntype DragEventType = MouseEvent | TouchEvent;\n"},{"path":"handler/Handler.d.ts","content":"declare class Base {\n}\ndeclare const Handler_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any; /**\n             * 启用Handler\n             *\n             * @english\n             * Enables the handler\n             */\n        }[]>; /**\n         * 检查Handler是否启用\n         *\n         * @english\n         * Returns true if the handler is enabled.\n         */\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Base;\n/**\n * 所有交互Handler类的基类\n *\n * @english\n * Base class for all the interaction handlers\n * @category handler\n * @abstract\n * @protected\n */\ndeclare abstract class Handler extends Handler_base {\n    target: any;\n    dom?: HTMLElement;\n    _enabled: boolean;\n    constructor(target: any);\n    abstract addHooks(): void;\n    abstract removeHooks(): void;\n    /**\n     * 启用Handler\n     *\n     * @english\n     * Enables the handler\n     */\n    enable(): this;\n    /**\n     * 停用Handler\n     *\n     * @english\n     * Disables the handler\n     */\n    disable(): this;\n    /**\n     * 检查Handler是否启用\n     *\n     * @english\n     * Returns true if the handler is enabled.\n     */\n    enabled(): boolean;\n    /**\n     * 从target上移除Handler\n     *\n     * @english\n     * remove handler from target\n     */\n    remove(): void;\n}\nexport default Handler;\n"},{"path":"handler/Handlerable.d.ts","content":"import { MixinConstructor } from \"../core/Mixin\";\nimport Handler from \"./Handler\";\n/**\n * A mixin, to enable a class with [interaction handlers]{@link Handler}\n * @protected\n * @category handler\n * @mixin Handlerable\n */\nexport default function <T extends MixinConstructor>(Base: T): {\n    new (...args: any[]): {\n        _handlers?: Handler[];\n        /**\n         * Register a handler\n         * @param {String} name       - name of the handler\n         * @param {Handler}           - handler class\n         * @return {*} this\n         * @protected\n         * @function Handerable.addHandler\n         */\n        addHandler(name: any, handlerClass: any): any;\n        /**\n         * Removes a handler\n         * @param {String} name       - name of the handler\n         * @return {*} this\n         * @protected\n         * @function Handerable.removeHandler\n         */\n        removeHandler(name: any): any;\n        _clearHandlers(): void;\n    };\n} & T;\n"},{"path":"index.d.ts","content":"export { default as GlobalConfig } from './GlobalConfig';\nexport * from './core/ResourceProxy';\nexport * from './core/Constants';\nexport { default as Browser } from './core/Browser';\nimport * as Util from './core/util';\nimport * as DomUtil from './core/util/dom';\nimport * as StringUtil from './core/util/strings';\nimport * as MapboxUtil from './core/mapbox';\nimport * as MicroTask from './core/MicroTask';\nexport { Util, DomUtil, StringUtil, MapboxUtil, MicroTask };\nexport { default as LRUCache } from './core/util/LRUCache';\nexport { default as Ajax } from './core/Ajax';\nexport { default as Canvas } from './core/Canvas';\nexport { default as Class } from './core/Class';\nexport { default as Eventable } from './core/Eventable';\nexport { GlobalEvent } from './core/GlobalEvent';\nexport { default as JSONAble } from './core/JSONAble';\nexport { default as CollisionIndex } from './core/CollisionIndex';\nexport { default as Handlerable } from './handler/Handlerable';\nexport { default as Handler } from './handler/Handler';\nexport { default as DragHandler } from './handler/Drag';\nexport * from './geo';\nimport { Map } from './map';\nexport { Map };\nexport { MapTool, DrawTool, AreaTool, DistanceTool } from './map/tool';\nexport { default as SpatialReference } from './map/spatial-reference/SpatialReference';\n/** @namespace ui */\nimport * as ui from './ui';\n/** @namespace control */\nimport * as control from './control';\nexport { ui, control };\nexport * from './layer';\nexport * from './geometry';\nimport './geometry/editor/GeometryEditor';\nimport './geometry/editor/TextEditable';\nimport './geometry/ext/Geometry.Animation';\nimport './geometry/ext/Geometry.Drag';\nimport './geometry/ext/Geometry.Edit';\nimport './geometry/ext/Geometry.Events';\nimport './geometry/ext/Geometry.InfoWindow';\nimport './geometry/ext/Geometry.JSON';\n/**\n * @namespace renderer\n */\nimport * as renderer from './renderer';\nexport { renderer };\nimport './renderer/geometry';\nimport * as symbolizer from './renderer/geometry/symbolizers';\n/** @namespace animation */\nimport * as animation from './core/Animation';\nexport { symbolizer, animation };\nexport { animate } from './core/Animation';\nexport { registerWorkerAdapter } from './core/worker/Worker';\nimport Actor from './core/worker/Actor';\n/**\n * @namespace worker\n */\ndeclare const worker: {\n    Actor: typeof Actor;\n};\nexport { worker };\n"},{"path":"lang/translator.d.ts","content":"import Class from '../core/Class';\nexport interface ILanguage {\n    distancetool: Distancetool;\n    areatool: Areatool;\n}\ninterface Distancetool {\n    start: string;\n    units: Units;\n}\ninterface Areatool {\n    units: Units;\n}\ninterface Units {\n    mile: string;\n    feet: string;\n    kilometer: string;\n    meter: string;\n}\nexport type Lang = 'zh-CN' | 'es-MX' | 'en-US';\n/**\n *  Maptalks text's language\n*/\nexport declare class TranslatorError extends Error {\n    constructor(msg: string);\n}\ndeclare class Translator extends Class {\n    languages: {\n        [key: string]: ILanguage;\n    };\n    nodes: ILanguage;\n    constructor(lang: Lang);\n    /**\n     *  Method to update the language of maptalks\n     *  @param {string} lang - Available Langs (zh-CN, en-US, es-MX)\n     *  @example setLang('zh-CN')\n    */\n    setLang(lang: Lang): void;\n    _validateNestedProps(nestedProps: string[]): void;\n    /**\n     *  method to return the text of the current language available on lang json's\n     *  @param {string} textNode - Accesible property with the current language text.\n     *  @return {string} Text to show in screen\n     *  @example document.write(translate('areatool.units.kilometer'))\n    */\n    translate(textNode?: string | null): string;\n}\nexport default Translator;\n"},{"path":"layer/CanvasLayer.d.ts","content":"import CanvasLayerRenderer from '../renderer/layer/canvaslayer/CanvasLayerRenderer';\nimport Layer, { LayerOptionsType } from './Layer';\n/**\n * 一个带有HTML5 2D canvas的layer\n * CanvasLayer为canvas操作提供了一些接口方法\n * 你可以直接使用CanvasLayer,但不能通过JSON序列化/反序列化实现CanvasLayer\n * 更推荐使用子类扩展CanvasLayer，并在子类中实现canvas绘画\n *\n * @english\n * A layer with a HTML5 2D canvas context.<br>\n * CanvasLayer provides some interface methods for canvas context operations. <br>\n * You can use it directly, but can't serialize/deserialize a CanvasLayer with JSON in this way. <br>\n * It is more recommended to extend it with a subclass and implement canvas paintings inside the subclass.\n * @example\n *  var layer = new CanvasLayer('canvas');\n *\n *  layer.prepareToDraw = function (context) {\n *      var size = map.getSize();\n *      return [size.width, size.height]\n *  };\n *\n *  layer.draw = function (context, width, height) {\n *      context.fillStyle = \"#f00\";\n *      context.fillRect(0, 0, w, h);\n *  };\n *  layer.addTo(map);\n * @category layer\n * @extends Layer\n * @param {String|Number} id - layer's id\n * @param {Object} options - options defined in [options]{@link CanvasLayer#options}\n */\ndeclare class CanvasLayer extends Layer {\n    isCanvasRender(): boolean;\n    /**\n     * 准备画布的接口函数\n     *\n     * @engilsh\n     * An optional interface function called only once before the first draw, useful for preparing your canvas operations.\n     * @param  {CanvasRenderingContext2D } context - CanvasRenderingContext2D of the layer canvas.\n     * @return {Object[]} objects that will be passed to function draw(context, ..) as parameters.\n     */\n    prepareToDraw(): void;\n    /**\n     * 绘制something的接口函数\n     *\n     * @engilsh\n     * The required interface function to draw things on the layer canvas.\n     * @param  {CanvasRenderingContext2D} context - CanvasRenderingContext2D of the layer canvas.\n     * @param  {*} params.. - parameters returned by function prepareToDraw(context).\n     */\n    draw(...params: any[]): void;\n    /**\n     * map交互绘制接口\n     * 默认情况调用draw()\n     * 如果你知道如何提升绘制性能可以重新此方法\n     *\n     * @english\n     * An optional interface function to draw while map is interacting.\n     * By default, it will call draw method instead.\n     * You can override this method if you are clear with what to draw when interacting to improve performance.\n     * @param  {CanvasRenderingContext2D} context - CanvasRenderingContext2D of the layer canvas.\n     * @param  {*} params.. - parameters returned by function prepareToDraw(context).\n     */\n    /**\n     * 重绘\n     *\n     * @english\n     * Redraw the layer\n     * @return this\n     */\n    redraw(): this;\n    /**\n     * 播放\n     *\n     * @english\n     * Start animation\n     * @return this\n     */\n    play(): this;\n    /**\n     * 暂停\n     *\n     * @english\n     * Pause the animation\n     * @return this\n     */\n    pause(): this;\n    /**\n     * 是否正在播放\n     *\n     * @english\n     * If the animation is playing\n     * @return\n     */\n    isPlaying(): boolean;\n    /**\n     * 清空画布\n     *\n     * @engilsh\n     * Clear layer's canvas\n     * @return this\n     */\n    clearCanvas(): this;\n    /**\n     * 要求map不触发任何事件下重绘canvas\n     *\n     * @engilsh\n     * Ask the map to redraw the layer canvas without firing any event.\n     * @return this\n     */\n    requestMapToRender(): this;\n    /**\n     * 要求map触发layerload事件重绘canvas\n     *\n     * @engilsh\n     * Ask the map to redraw the layer canvas and fire layerload event\n     * @return this\n     */\n    completeRender(): this;\n    /**\n     * canvas创建完成后的回调函数\n     *\n     * @english\n     * Callback function when layer's canvas is created. <br>\n     * Override it to do anything needed.\n     */\n    onCanvasCreate(): this;\n    /**\n     * map zoomstart事件回调\n     *\n     * @engilsh\n     * The event callback for map's zoomstart event.\n     * @param  {Object} param - event parameter\n     */\n    onZoomStart(): void;\n    /**\n     * map zooming事件回调\n     *\n     * @engilsh\n     * The event callback for map's zooming event.\n     * @param  {Object} param - event parameter\n     */\n    onZooming(): void;\n    /**\n     * map zoomend事件回调\n     *\n     * @engilsh\n     * The event callback for map's zoomend event.\n     * @param  {Object} param - event parameter\n     */\n    onZoomEnd(): void;\n    /**\n     * map movestart事件回调\n     *\n     * @engilsh\n     * The event callback for map's movestart event.\n     * @param  {Object} param - event parameter\n     */\n    onMoveStart(): void;\n    /**\n     * map moving事件回调\n     *\n     * @engilsh\n     * The event callback for map's moving event.\n     * @param  {Object} param - event parameter\n     */\n    onMoving(): void;\n    /**\n     * map moveend事件回调\n     *\n     * @engilsh\n     * The event callback for map's moveend event.\n     * @param  {Object} param - event parameter\n     */\n    onMoveEnd(): void;\n    /**\n     * map resize事件回调\n     *\n     * @engilsh\n     * The event callback for map's resize event.\n     * @param  {Object} param - event parameter\n     */\n    onResize(): void;\n    /**\n     * double buffer的回调函数\n     * 默认情况下just draws and return，如果你需要在绘制之前处理canvas，可以重写改函数\n     *\n     * @engilsh\n     * The callback function to double buffer. <br>\n     * In default, it just draws and return, and you can override it if you need to process the canvas image before drawn.\n     * @param  {CanvasRenderingContext2D} bufferContext CanvasRenderingContext2D of double buffer of the layer canvas.\n     * @param  {CanvasRenderingContext2D} context CanvasRenderingContext2D of the layer canvas.\n     */\n    doubleBuffer(bufferContext: CanvasRenderingContext2D): CanvasLayer;\n    _getRenderer(): CanvasLayerRenderer;\n}\nexport default CanvasLayer;\nexport type CanvasLayerOptionsType = LayerOptionsType & {\n    doubleBuffer?: boolean;\n    animation?: boolean;\n    fps?: number | string;\n};\n"},{"path":"layer/ImageLayer.d.ts","content":"import CanvasRenderer from '../renderer/layer/CanvasRenderer';\nimport Extent from '../geo/Extent';\nimport Layer, { LayerOptionsType } from './Layer';\nimport { PointExtent } from '../geo';\n/**\n * images layer,可指定图像地理位置及透明的\n *\n * @english\n * @classdesc\n * A layer used to display images, you can specify each image's geographic extent and opacity\n * @category layer\n * @extends Layer\n * @param id - tile layer's id\n * @param images=null - images\n * @param options=null - options defined in [ImageLayer]{@link ImageLayer#options}\n * @example\n * new ImageLayer(\"images\", [{\n        url : 'http://example.com/foo.png',\n        extent: [xmin, ymin, xmax, ymax],\n        opacity : 1\n    }])\n */\ndeclare class ImageLayer extends Layer {\n    _images: Array<ImageItem>;\n    _imageData: Array<ImageDataItem>;\n    constructor(id: string, images?: ImageLayerOptionsType | Array<ImageItem>, options?: ImageLayerOptionsType);\n    onAdd(): void;\n    /**\n     * 设置图像并重新绘制\n     *\n     * @english\n     * Set images and redraw\n     * @param images - new images\n     * @return this\n     */\n    setImages(images: Array<ImageItem>): this;\n    /**\n     * 获取图像\n     *\n     * @english\n     * Get images\n     * @return\n     */\n    getImages(): Array<ImageItem>;\n    _prepareImages(images: Array<ImageItem>): void;\n    getRenderer(): ImageLayerCanvasRenderer;\n}\nexport declare class ImageLayerCanvasRenderer extends CanvasRenderer {\n    _imageLoaded: boolean;\n    isDrawable(): boolean;\n    checkResources(): any;\n    retireImage(image: ImageType): void;\n    refreshImages(): void;\n    draw(timestamp?: number, context?: any): void;\n    _drawImages(timestamp?: number, context?: any): void;\n    _drawImage(image: ImageType, extent: PointExtent, opacity: number): void;\n    drawOnInteracting(event?: any, timestamp?: number, context?: any): void;\n}\ndeclare const ImageLayerGLRenderer_base: {\n    new (...args: any[]): {\n        gl: import(\"src/renderer/types\").TileRenderingContext;\n        canvas: import(\"src/renderer/types\").TileRenderingCanvas;\n        canvas2?: import(\"src/renderer/types\").TileRenderingCanvas;\n        _debugInfoCanvas?: import(\"src/renderer/types\").TileRenderingCanvas;\n        program?: import(\"src/renderer/types\").TileRenderingProgram; /**\n         * 设置图像并重新绘制\n         *\n         * @english\n         * Set images and redraw\n         * @param images - new images\n         * @return this\n         */\n        _layerAlt: number;\n        _layerAltitude: number;\n        layer?: any;\n        texBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        _debugBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        posBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        _imageBuffers?: import(\"src/renderer/types\").TileImageBuffer[];\n        _buffers?: import(\"src/renderer/types\").TileImageBuffer[];\n        _textures?: WebGLTexture[];\n        getMap?(): import(\"src\").Map;\n        drawGLImage(image: import(\"src/renderer/types\").TileImageType, x: number, y: number, w: number, h: number, scale: number, opacity: number, debugInfo?: string, baseColor?: number[]): void;\n        drawDebug(uMatrix: import(\"src/core/util/mat4\").Matrix4InOut, x: number, y: number, w: number, h: number, debugInfo: string): void;\n        bufferTileData(x: number, y: number, w: number, h: number, buffer?: import(\"src/renderer/types\").TileImageBuffer): import(\"src/renderer/types\").TileImageBuffer;\n        createCanvas2(): void;\n        createGLContext(): void;\n        resizeGLCanvas(): void;\n        clearGLCanvas(): void;\n        disposeImage(image: import(\"src/renderer/types\").TileImageType): void;\n        _createTexture(image: import(\"src/renderer/types\").TileImageType): WebGLTexture;\n        getTexture(): WebGLTexture;\n        saveTexture(texture: WebGLTexture): void;\n        loadTexture(image: import(\"src/renderer/types\").TileImageType): WebGLTexture;\n        getImageBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        saveImageBuffer(buffer: import(\"src/renderer/types\").TileImageBuffer): void;\n        loadImageBuffer(data: Int16Array | Float32Array, glBuffer: import(\"src/renderer/types\").TileImageBuffer): import(\"src/renderer/types\").TileImageBuffer;\n        createImageBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        removeGLCanvas(): void;\n        createBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        enableVertexAttrib(attributes: import(\"src/renderer/types\").VertexAttrib): void;\n        createProgram(vert: string, frag: string): import(\"src/renderer/types\").TileRenderingProgram;\n        useProgram(program: import(\"src/renderer/types\").TileRenderingProgram): any;\n        enableSampler(sampler: string, texIdx?: number): WebGLUniformLocation;\n        _initUniforms(program: import(\"src/renderer/types\").TileRenderingProgram, uniforms: string[]): void;\n        _getUniform(program: import(\"src/renderer/types\").TileRenderingProgram, uniformName: string): WebGLUniformLocation;\n        set8(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Float32Array;\n        set8Int(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Int16Array;\n    };\n} & typeof ImageLayerCanvasRenderer;\nexport declare class ImageLayerGLRenderer extends ImageLayerGLRenderer_base {\n    drawOnInteracting(event: any, timestamp: number, context: any): void;\n    _prepareGLContext(): void;\n    _drawImages(timestamp?: number, parentContext?: any): void;\n    isDrawable(): boolean;\n    _drawImage(image: ImageType, extent: PointExtent, opacity: number): void;\n    createContext(): void;\n    resizeCanvas(canvasSize: any): void;\n    clearCanvas(): void;\n    retireImage(image: ImageType): void;\n    onRemove(): void;\n}\nexport default ImageLayer;\nexport type ImageItem = {\n    url: string;\n    extent: Extent | [number, number, number, number];\n    opacity?: number;\n};\nexport type ImageDataItem = ImageItem & {\n    extent2d: PointExtent;\n};\nexport type ImageType = HTMLImageElement | ImageBitmap;\ndeclare enum depthFuncEnum {\n    'never' = 0,\n    '<' = 1,\n    '=' = 2,\n    '<=' = 3,\n    ' >' = 4,\n    '!=' = 5,\n    '>=' = 6,\n    'always' = 7\n}\nexport type ImageLayerOptionsType = LayerOptionsType & {\n    crossOrigin?: string;\n    renderer?: 'canvas' | 'gl' | 'dom';\n    alphaTest?: boolean;\n    depthMask?: boolean;\n    depthFunc?: keyof typeof depthFuncEnum;\n};\n"},{"path":"layer/index.d.ts","content":"import Layer from './Layer';\nimport TileLayer from './tile/TileLayer';\nimport GroupTileLayer from './tile/GroupTileLayer';\nimport WMSTileLayer from './tile/WMSTileLayer';\nimport CanvasTileLayer from './tile/CanvasTileLayer';\nimport ImageLayer from './ImageLayer';\nimport OverlayLayer from './OverlayLayer';\nimport VectorLayer from './VectorLayer';\nimport CanvasLayer from './CanvasLayer';\nimport ParticleLayer from './ParticleLayer';\nimport TileSystem from './tile/tileinfo/TileSystem';\nimport TileConfig from './tile/tileinfo/TileConfig';\nexport { Layer, TileLayer, GroupTileLayer, WMSTileLayer, CanvasTileLayer, ImageLayer, OverlayLayer, VectorLayer, CanvasLayer, ParticleLayer, TileSystem, TileConfig };\n"},{"path":"layer/Layer.d.ts","content":"import Class from '../core/Class';\nimport CanvasRenderer from '../renderer/layer/CanvasRenderer';\nimport CollisionIndex from '../core/CollisionIndex';\nimport type { Map } from '../map';\nimport type { Marker, MultiPolygon, Polygon } from '../geometry';\nimport { CommonProjectionType } from '../geo/projection';\ndeclare const Layer_base: {\n    new (...args: any[]): {\n        _jsonType?: string;\n        getJSONType(): string;\n    };\n    registerJSONType(type: string): void;\n    getJSONClass(type: string): {\n        new (...args: any[]): {\n            _eventMap?: Record<string, {\n                handler: import(\"../core/Eventable\").HandlerFn;\n                context: any;\n            }[]>;\n            _eventParent?: any;\n            _eventTarget?: any;\n            on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            addEventListener(...args: any[]): any;\n            once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            removeEventListener(...args: any[]): any;\n            listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n            getListeningEvents(): string[];\n            copyEventListeners(target: any): any;\n            fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n            _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n            _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n            _clearListeners(eventType: string): void;\n            _clearAllListeners(): void;\n            _setEventParent(parent: any): any;\n            _setEventTarget(target: any): any;\n            _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n        };\n    } & {\n        new (...args: any[]): {};\n        registerRenderer<T extends typeof Class>(name: string, clazz: T): any & typeof Class;\n        getRendererClass(name: string): Class;\n    } & typeof Class;\n} & {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & {\n    new (...args: any[]): {};\n    registerRenderer<T extends typeof Class>(name: string, clazz: T): any & typeof Class;\n    getRendererClass(name: string): Class;\n} & typeof Class;\n/**\n * layers的基础类，定义了所有layers公共方法。\n * 抽象类，不做实例化打算\n *\n * @english\n * @classdesc\n * Base class for all the layers, defines common methods that all the layer classes share. <br>\n * It is abstract and not intended to be instantiated.\n *\n * @category layer\n * @abstract\n * @extends Class\n * @mixes Eventable\n * @mixes JSONAble\n * @mixes Renderable\n */\ndeclare class Layer extends Layer_base {\n    _canvas: HTMLCanvasElement;\n    _renderer: CanvasRenderer;\n    _id: string;\n    _zIndex: number;\n    _drawTime: number;\n    map: Map;\n    _mask: Polygon | MultiPolygon | Marker;\n    _loaded: boolean;\n    _collisionIndex: CollisionIndex;\n    _optionsHook?(conf?: any): void;\n    _silentConfig: boolean | undefined | any;\n    options: LayerOptionsType;\n    constructor(id: string, options?: LayerOptionsType);\n    /**\n     * 加载tile layer,不能被子类重写\n     *\n     * @english\n     * load the tile layer, can't be overrided by sub-classes\n     */\n    load(): this;\n    /**\n     * 获取layer Id\n     *\n     * @english\n     * Get the layer id\n     * @returns id\n     */\n    getId(): string;\n    /**\n     * 为layer新设一个 Id\n     *\n     * @english\n     * Set a new id to the layer\n     * @param id - new layer id\n     * @return this\n     * @fires Layer#idchange\n     */\n    setId(id: string): this;\n    /**\n     * 将图层添加至 map\n     *\n     * @english\n     * Adds itself to a map.\n     * @param map - map added to\n     * @return this\n     */\n    addTo(map: Map): this;\n    /**\n     * 为layer 设置zIndex\n     *\n     * @engilsh\n     * Set a z-index to the layer\n     * @param zIndex - layer's z-index\n     * @return this\n     */\n    setZIndex(zIndex: number): this;\n    /**\n     * 获取layer 的 zIndex\n     *\n     * @english\n     * Get the layer's z-index\n     * @return\n     */\n    getZIndex(): number;\n    /**\n     * 获取 layer 的 minZoom\n     *\n     * @english\n     * Get Layer's minZoom to display\n     * @return\n     */\n    getMinZoom(): number;\n    /**\n     * 获取layer 的 maxZoom\n     *\n     * @english\n     * Get Layer's maxZoom to display\n     * @return\n     */\n    getMaxZoom(): number;\n    /**\n     * 获取 layer 的 opacity\n     *\n     * @english\n     * Get layer's opacity\n     * @returns {Number}\n     */\n    getOpacity(): number;\n    /**\n     * 设置 layer 的 opacity\n     *\n     * @english\n     * Set opacity to the layer\n     * @param opacity - layer's opacity\n     * @return this\n     */\n    setOpacity(op: number): this;\n    /**\n     * layer 是否为 HTML5 Canvas 渲染\n     *\n     * @english\n     * If the layer is rendered by HTML5 Canvas.\n     * @return\n     * @protected\n     */\n    isCanvasRender(): boolean;\n    /**\n     * 获取图层所在 map\n     *\n     * @english\n     * Get the map that the layer added to\n     * @returns {Map}\n     */\n    getMap(): Map;\n    /**\n     * 获取 layer 所在map 的 projection\n     *\n     * @english\n     * Get projection of layer's map\n     * @returns\n     */\n    getProjection(): CommonProjectionType;\n    /**\n     * 将图层置顶\n     *\n     * @english\n     * Brings the layer to the top of all the layers\n     * @returns this\n     */\n    bringToFront(): this;\n    /**\n     * 将图层置底\n     *\n     * @english\n     * Brings the layer under the bottom of all the layers\n     * @returns {Layer} this\n     */\n    bringToBack(): this;\n    /**\n     * 显示图层\n     *\n     * @english\n     * Show the layer\n     * @returns this\n     */\n    show(): this;\n    /**\n     * 隐藏图层\n     *\n     * @english\n     * Hide the layer\n     * @returns this\n     */\n    hide(): this;\n    /**\n     * layer 的当前 visible 状态\n     *\n     * @english\n     * Whether the layer is visible now.\n     * @return\n     */\n    isVisible(): boolean;\n    /**\n     * 移除图层\n     *\n     * @english\n     * Remove itself from the map added to.\n     * @returns this\n     */\n    remove(): this;\n    /**\n     * 获取 mask geometry\n     *\n     * @english\n     * Get the mask geometry of the layer\n     * @return {Geometry}\n     */\n    getMask(): Marker | MultiPolygon | Polygon;\n    /**\n     * 设置mask geometry, 只显示掩码的区域\n     *\n     * @english\n     * Set a mask geometry on the layer, only the area in the mask will be displayed.\n     * @param {Geometry} mask - mask geometry, can only be a Marker with vector symbol, a Polygon or a MultiPolygon\n     * @returns {Layer} this\n     */\n    setMask(mask: Polygon | MultiPolygon | Marker): this;\n    /**\n     * 移除mask\n     *\n     * @engilsh\n     * Remove the mask\n     * @returns {Layer} this\n     */\n    removeMask(): this;\n    /**\n     * 准备层的加载，是一个由子类重写的方法。\n     *\n     * @english\n     * Prepare Layer's loading, this is a method intended to be overrided by subclasses.\n     * @return true to continue loading, false to cease.\n     * @protected\n     */\n    onLoad(): boolean;\n    onLoadEnd(): void;\n    /**\n     * 是否加载layer\n     *\n     * @english\n     * Whether the layer is loaded\n     * @return\n     */\n    isLoaded(): boolean;\n    /**\n     * 获取collision index\n     *\n     * @english\n     * Get layer's collision index\n     * @returns {CollisionIndex}\n     */\n    getCollisionIndex(): CollisionIndex;\n    /**\n     * 清除 layer 的 collision index。\n     * 如果 collisionScope !== 'layer' 将忽略\n     *\n     * @english\n     * Clear layer's collision index.\n     * Will ignore if collisionScope is not layer\n     */\n    clearCollisionIndex(): this;\n    getRenderer(): CanvasRenderer;\n    onConfig(conf: {\n        [key: string]: any;\n    }): void;\n    onAdd(): void;\n    onRendererCreate(): void;\n    onCanvasCreate(): void;\n    onRemove(): void;\n    _bindMap(map: Map, zIndex?: number): void;\n    _initRenderer(): void;\n    _doRemove(): void;\n    _switchEvents(to: any, emitter: any): void;\n    _getRenderer(): CanvasRenderer;\n    _getLayerList(): Layer[];\n    _getMask2DExtent(): import(\"src\").Extent;\n    toJSON(options?: any): LayerJSONType;\n    /**\n     * Reproduce a Layer from layer's JSON.\n     * @param  {Object} layerJSON - layer's JSON\n     * @return {Layer}\n     */\n    static fromJSON(layerJSON: {\n        [key: string]: any;\n    }): Layer | null;\n}\nexport default Layer;\nexport type LayerOptionsType = {\n    attribution?: string;\n    minZoom?: number;\n    maxZoom?: number;\n    visible?: boolean;\n    opacity?: number;\n    zIndex?: number;\n    globalCompositeOperation?: string;\n    renderer?: 'canvas' | 'gl' | 'dom';\n    debugOutline?: string;\n    cssFilter?: string;\n    forceRenderOnMoving?: boolean;\n    forceRenderOnZooming?: boolean;\n    forceRenderOnRotating?: boolean;\n    collision?: boolean;\n    collisionScope?: 'layer' | 'map';\n    hitDetect?: boolean;\n    canvas?: HTMLCanvasElement;\n    mask?: any;\n    drawImmediate?: boolean;\n    geometryEvents?: boolean;\n    geometryEventTolerance?: number;\n};\nexport type LayerJSONType = {\n    id: string;\n    type: string;\n    options: Record<string, any>;\n    geometries?: Array<any>;\n    layers?: Array<any>;\n};\n"},{"path":"layer/OverlayLayer.d.ts","content":"import Extent from '../geo/Extent';\nimport { Geometry } from '../geometry';\nimport Layer, { LayerOptionsType } from './Layer';\nimport { type OverlayLayerCanvasRenderer } from '../renderer';\nimport { HandlerFnResultType } from '../core/Eventable';\n/**\n * layers 的基础类，可用于 geometries 的添加移除\n * 抽象类,不准备实例化\n *\n * @english\n * @classdesc\n * Base class of all the layers that can add/remove geometries. <br>\n * It is abstract and not intended to be instantiated.\n * @category layer\n * @abstract\n * @extends Layer\n */\ndeclare class OverlayLayer extends Layer {\n    _maxZIndex: number;\n    _minZIndex: number;\n    _geoMap: Record<string, Geometry>;\n    _geoList: Array<Geometry>;\n    _toSort: boolean;\n    _cookedStyles: any;\n    _clearing: boolean;\n    options: OverlayLayerOptionsType;\n    _renderer: OverlayLayerCanvasRenderer;\n    constructor(id: string, geometries: OverlayLayerOptionsType | Array<Geometry>, options?: OverlayLayerOptionsType);\n    getAltitude(): number;\n    /**\n     * 通过 id 获取 geometry\n     *\n     * @english\n     * Get a geometry by its id\n     * @param id   - id of the geometry\n     * @return\n     */\n    getGeometryById(id: string | number): Geometry;\n    /**\n     * 获取所有geometries，如果提供 filter() 方法,则根据方法返回\n     *\n     * @english\n     * Get all the geometries or the ones filtered if a filter function is provided.\n     * @param filter=undefined   - a function to filter the geometries\n     * @param context=undefined  - context of the filter function, value to use as this when executing filter.\n     * @return\n     */\n    getGeometries(filter?: (geo: Geometry) => boolean, context?: any): Array<Geometry>;\n    /**\n     * 获取第一个geometry, geometry 位于底部\n     *\n     * @english\n     * Get the first geometry, the geometry at the bottom.\n     * @return first geometry\n     */\n    getFirstGeometry(): Geometry;\n    /**\n     * 获取最后一个geometry, geometry 位于上部\n     *\n     * @english\n     * Get the last geometry, the geometry on the top\n     * @return last geometry\n     */\n    getLastGeometry(): Geometry;\n    /**\n     * 获取 geometries 个数\n     *\n     * Get count of the geometries\n     * @return count\n     */\n    getCount(): number;\n    /**\n     * 获取 geometries 的 extent, 如果 layer 为空,返回 null\n     *\n     * @english\n     * Get extent of all the geometries in the layer, return null if the layer is empty.\n     * @return {Extent} - extent of the layer\n     */\n    getExtent(): Extent;\n    /**\n     * 按顺序为图层中的每个 geometry 执行一次提供的回调。\n     *\n     * @english\n     * Executes the provided callback once for each geometry present in the layer in order.\n     * @param fn - a callback function\n     * @param context=undefined   - callback's context, value to use as this when executing callback.\n     * @return this\n     */\n    forEach(fn: (geo: Geometry, index: number) => void, context?: any): this;\n    /**\n     * 创建一个包含所有通过由提供的函数实现的测试的 geometries 的 GeometryCollection。\n     *\n     * @english\n     * Creates a GeometryCollection with all the geometries that pass the test implemented by the provided function.\n     * @param fn      - Function to test each geometry\n     * @param context=undefined  - Function's context, value to use as this when executing function.\n     * @return  A GeometryCollection with all the geometries that pass the test\n     */\n    filter(fn: (geo: Geometry) => boolean, context?: any): Array<Geometry>;\n    /**\n     * layer 是否为空\n     *\n     * @english\n     * Whether the layer is empty.\n     * @return {Boolean}\n     */\n    isEmpty(): boolean;\n    /**\n     * 为 layer 添加 geometries\n     *\n     * @english\n     * Adds one or more geometries to the layer\n     * @param geometries - one or more geometries\n     * @param fitView=false                                         - automatically set the map to a fit center and zoom for the geometries\n     * @param fitView.easing=out                                    - default animation type\n     * @param fitView.duration=map.options.zoomAnimationDuration    - default animation time\n     * @param fitView.step=null                                     - step function during animation, animation frame as the parameter\n     * @return this\n     */\n    addGeometry(geometries: Geometry | Array<Geometry>, fitView?: boolean | addGeometryFitViewOptions): any;\n    /**\n     * 所有 geometries 最小的 zIndex\n     *\n     * @english\n     * Get minimum zindex of geometries\n     */\n    getGeoMinZIndex(): number;\n    /**\n     * 所有 geometries 最大的 zIndex\n     *\n     * @english\n     * Get maximum zindex of geometries\n     */\n    getGeoMaxZIndex(): number;\n    _add(geo: Geometry, extent?: Extent, i?: number): void;\n    /**\n     * 移除一个或多个geometries\n     *\n     * @english\n     * Removes one or more geometries from the layer\n     * @param  geometries - geometry ids or geometries to remove\n     * @returns this\n     */\n    removeGeometry(geometries: Geometry | Geometry[]): any;\n    /**\n     * 清除 layer\n     *\n     * @english\n     * Clear all geometries in this layer\n     * @returns this\n     */\n    clear(): this;\n    /**\n     * 移除geometry 回调函数\n     *\n     * @english\n     * Called when geometry is being removed to clear the context concerned.\n     * @param geometry - the geometry instance to remove\n     * @protected\n     */\n    onRemoveGeometry(geometry: Geometry): void;\n    /**\n     * 获取 layer 的 style\n     *\n     * @english\n     * Gets layer's style.\n     * @return layer's style\n     */\n    getStyle(): any | any[];\n    /**\n     * layer 设置 style, 用样式符号对满足条件的 geometries进行样式修改\n     * 基于[mapbox-gl-js's style specification]， {https://www.mapbox.com/mapbox-gl-js/style-spec/#types-filter}.\n     *\n     * @english\n     * Sets style to the layer, styling the geometries satisfying the condition with style's symbol. <br>\n     * Based on filter type in [mapbox-gl-js's style specification]{https://www.mapbox.com/mapbox-gl-js/style-spec/#types-filter}.\n     * @param style - layer's style\n     * @returns this\n     * @fires VectorLayer#setstyle\n     * @example\n     * layer.setStyle([\n        {\n          'filter': ['==', 'count', 100],\n          'symbol': {'markerFile' : 'foo1.png'}\n        },\n        {\n          'filter': ['==', 'count', 200],\n          'symbol': {'markerFile' : 'foo2.png'}\n        }\n      ]);\n     */\n    setStyle(style: any | any[]): this;\n    _styleGeometry(geometry: Geometry): boolean;\n    /**\n     * 移除 style\n     *\n     * @english\n     * Removes layers' style\n     * @returns this\n     * @fires VectorLayer#removestyle\n     */\n    removeStyle(): this;\n    onAddGeometry(geo: Geometry): void;\n    hide(): this;\n    _initCache(): void;\n    _updateZIndex(...zIndex: number[]): void;\n    _sortGeometries(): void;\n    _compare(a: any, b: any): number;\n    _findInList(geo: Geometry): number;\n    _onGeometryEvent(param?: HandlerFnResultType): void;\n    _onGeometryIdChange(param: HandlerFnResultType): void;\n    _onGeometryZIndexChange(param: HandlerFnResultType): void;\n    _onGeometryPositionChange(param: HandlerFnResultType): void;\n    _onGeometryShapeChange(param: HandlerFnResultType): void;\n    _onGeometrySymbolChange(param: HandlerFnResultType): void;\n    _onGeometryShow(param: HandlerFnResultType): void;\n    _onGeometryHide(param: HandlerFnResultType): void;\n    _onGeometryPropertiesChange(param: HandlerFnResultType): void;\n    _hasGeoListeners(eventTypes: string | Array<string>): boolean;\n    _getRenderer(): OverlayLayerCanvasRenderer;\n}\nexport default OverlayLayer;\nexport type OverlayLayerOptionsType = LayerOptionsType & {\n    drawImmediate?: boolean;\n    geometryEvents?: boolean;\n    geometryEventTolerance?: number;\n    style?: any;\n};\nexport type addGeometryFitViewOptions = {\n    easing?: string;\n    duration?: number;\n    step?: (frame: any) => void;\n};\nexport type LayerIdentifyOptionsType = {\n    onlyVisible?: boolean;\n    tolerance?: number;\n};\n"},{"path":"layer/ParticleLayer.d.ts","content":"import CanvasLayer, { CanvasLayerOptionsType } from './CanvasLayer';\n/**\n * 粒子图层\n * 提供了一些渲染粒子的接口方法。\n * 你可以直接使用它，但不能以这种方式用JSON序列化/反序列化一个 particelayer\n * 更建议使用子类来扩展它\n *\n * @english\n * @classdesc\n * A layer to draw particles. <br>\n * ParticleLayer provides some interface methods to render particles. <br>\n * You can use it directly, but can't serialize/deserialize a ParticleLayer with JSON in this way. <br>\n * It is more recommended to extend it with a subclass.\n * @example\n * import { ParticleLayer } from 'maptalks';\n * var layer = new ParticleLayer('particle');\n *\n * layer.getParticles = function (t) {\n *     return particles[t];\n * };\n * layer.addTo(map);\n * @category layer\n * @extends CanvasLayer\n * @param {String} id - layer's id\n * @param {Object} [options=null] - options defined in [options]{@link ParticleLayer#options}\n */\ndeclare class ParticleLayer extends CanvasLayer {\n    options: ParticleLayerOptionsType;\n    /**\n     * 获取t时刻的例子位置\n     *\n     * @english\n     * Interface method to get particles's position at time t.\n     * @param t - current time in milliseconds\n     */\n    getParticles(t?: number): void;\n    draw(context: CanvasRenderingContext2D, view: any): void;\n    _fillCanvas(context: CanvasRenderingContext2D): void;\n}\nexport default ParticleLayer;\nexport type ParticleLayerOptionsType = CanvasLayerOptionsType & {\n    animation?: boolean;\n};\n"},{"path":"layer/tile/CanvasTileLayer.d.ts","content":"import { LayerJSONType } from '../Layer';\nimport TileLayer, { TileLayerOptionsType } from './TileLayer';\n/**\n * @classdesc\n * @ignore\n * @category layer\n * @extends TileLayer\n * @param id - tile layer's id\n * @param - options defined in [CanvasTileLayer]{@link TileLayer#options}\n * @example\n * var layer = new CanvasTileLayer(\"tile\");\n * layer.drawTile = ()\n */\ndeclare class CanvasTileLayer extends TileLayer {\n    constructor(id: string, options: CanvasTileLayerOptionsType);\n    /**\n     * The interface method to draw on canvsa tile\n     * @param canvas  canvas to draw on\n     * @param options current options\n     * @param options current options\n     */\n    drawTile(): void;\n    /**\n     * Export the CanvasTileLayer's json. <br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method\n     * @return layer's JSON\n     */\n    toJSON(): LayerJSONType;\n    /**\n     * Reproduce a CanvasTileLayer from layer's JSON.\n     * @param layerJSON - layer's JSON\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(layerJSON: {\n        [x: string]: any;\n    }): CanvasTileLayer;\n}\nexport default CanvasTileLayer;\nexport type CanvasTileLayerOptionsType = TileLayerOptionsType;\n"},{"path":"layer/tile/GroupTileLayer.d.ts","content":"import { LayerJSONType } from '../Layer';\nimport TileLayer, { TileLayerOptionsType, TilesType } from './TileLayer';\nimport Size from '../../geo/Size';\n/**\n * @classdesc\n * A layer used to display a group of tile layers. <br>\n * Its performance is better than add TileLayers seperately and it can help prevent limits of active webgl contexts: <br>\n * \"WARNING: Too many active WebGL contexts. Oldest context will be lost\"\n * @category layer\n * @extends TileLayer\n * @param {String|Number} id - tile layer's id\n * @param {TileLayer[]} layers  - TileLayers to add\n * @param {Object} [options=null] - options defined in [TileLayer]{@link TileLayer#options}\n * @example\n * new GroupTileLayer(\"group-tiles\",[\n    new maptalks.WMSTileLayer('wms', {\n      'urlTemplate' : 'https://demo.boundlessgeo.com/geoserver/ows',\n      'crs' : 'EPSG:3857',\n      'layers' : 'ne:ne',\n      'styles' : '',\n      'version' : '1.3.0',\n      'format': 'image/png',\n      'transparent' : true,\n      'uppercase' : true\n    }),\n    new maptalks.TileLayer('tile2',{\n      urlTemplate: 'http://korona.geog.uni-heidelberg.de/tiles/adminb/x={x}&y={y}&z={z}'\n    })\n  ])\n */\ndeclare class GroupTileLayer extends TileLayer {\n    layers: TileLayer[];\n    layerMap: Record<string, TileLayer>;\n    private _groupChildren;\n    /**\n     * Reproduce a GroupTileLayer from layer's profile JSON.\n     * @param layerJSON - layer's profile JSON\n     * @return\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(layerJSON: {\n        [x: string]: any;\n    }): GroupTileLayer;\n    /**\n     * @param id    - layer's id\n     * @param layers  - TileLayers to add\n     * @param [options=null]          - construct options\n     * @param [options.*=null]             - options defined in [TileLayer]{@link TileLayer#options}\n     */\n    constructor(id: string, layers: TileLayer[], options?: GroupTileLayerOptionsType);\n    /**\n     * Get children TileLayer\n     */\n    getLayers(): TileLayer[];\n    /**\n     * add tilelayers\n     * @param tileLayers\n     */\n    addLayer(tileLayers?: TileLayer[]): this;\n    /**\n     * remove tilelayers\n     * @param tileLayers\n     */\n    removeLayer(tileLayers?: TileLayer[]): this;\n    /**\n   * clear tilelayers\n   */\n    clearLayers(): this;\n    /**\n     * Export the GroupTileLayer's profile json. <br>\n     * Layer's profile is a snapshot of the layer in JSON format. <br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method\n     * @return layer's profile JSON\n     */\n    toJSON(): LayerJSONType;\n    getTileSize(id: number | string): Size;\n    /**\n     * Get tiles at zoom (or current zoom)\n     * @param z\n     * @returns tiles\n     */\n    getTiles(z: number, parentLayer: any): TilesType;\n    onAdd(): void;\n    onRemove(): void;\n    getLayer(id: string | number): TileLayer;\n    getChildLayer(id: string | number): TileLayer;\n    _removeChildTileCache(layer: TileLayer): this;\n    _onLayerShowHide(e: {\n        type: string;\n        target: any;\n    }): void;\n    _renderLayers(): this;\n    _refresh(): this;\n    isVisible(): boolean;\n    _checkChildren(): void;\n    _sortLayers(): void;\n}\nexport default GroupTileLayer;\nexport type GroupTileLayerOptionsType = TileLayerOptionsType & {\n    maxCacheSize?: number;\n};\n"},{"path":"layer/tile/tileinfo/TileConfig.d.ts","content":"import Coordinate from '../../../geo/Coordinate';\nimport Point from '../../../geo/Point';\nimport Extent from '../../../geo/Extent';\nimport Transformation from '../../../geo/transformation/Transformation';\nimport TileSystem from './TileSystem';\nimport { type Map } from '../../../map';\nimport { type Size } from '../../../geo';\n/**\n * Tile config for tile layers, an utilities class for tile layers to render tiles\n * @class\n * @category layer\n * @private\n */\ndeclare class TileConfig {\n    map: Map;\n    tileSize: Size;\n    fullExtent: Extent;\n    private _xScale;\n    private _yScale;\n    private _pointOrigin;\n    private _glRes;\n    tileSystem: TileSystem;\n    transformation: Transformation;\n    private _tileFullIndex;\n    /**\n     * @param tileSystem  - tileSystem\n     * @param fullExtent      - fullExtent of the tile layer\n     * @param tileSize          - tile size\n     */\n    constructor(map: Map, tileSystem: TileSystem, fullExtent: Extent, tileSize: Size);\n    prepareTileInfo(tileSystem: TileSystem, fullExtent: Extent): void;\n    /**\n     * Get index of point's tile\n     * @param point - transformed point, this.transformation.transform(pCoord)\n     * @param res  - current resolution\n     * @return       tile index\n     */\n    _getTileNum(point: Point, res: number): {\n        x: number;\n        y: number;\n    };\n    /**\n     * Get tile index and offset from tile's northwest\n     * @param pCoord   - projected coordinate\n     * @param res - current resolution\n     * @return   tile index and offset\n     */\n    getTileIndex(pCoord: Coordinate, res: number, repeatWorld: any): TileIndex;\n    /**\n     * Get neibor's tile index\n     * @param tileX\n     * @param tileY\n     * @param offsetX\n     * @param offsetY\n     * @param zoomLevel\n     * @return  tile's neighbor index\n     */\n    getNeighorTileIndex(tileX: number, tileY: number, offsetX: number, offsetY: number, res: number, repeatWorld: any): TileIndex;\n    _getTileFullIndex(res: number): Extent;\n    /**\n     * Get tile's north west's projected coordinate\n     * @param tileX\n     * @param tileY\n     * @param res\n     * @return\n     */\n    getTilePrjNW(tileX: number, tileY: number, res: number, out?: any): Coordinate;\n    getTilePointNW(tileX: number, tileY: number, res: number, out?: any): Point;\n    /**\n     * Get tile's south east's projected coordinate\n     * @param tileX\n     * @param tileY\n     * @param res\n     * @return\n     */\n    getTilePrjSE(tileX: number, tileY: number, res: number, out?: any): Coordinate;\n    getTilePointSE(tileX: number, tileY: number, res: number, out?: any): Point;\n    /**\n     * Get tile's projected extent\n     * @param tileX\n     * @param tileY\n     * @param res\n     * @return\n     */\n    getTilePrjExtent(tileX: number, tileY: number, res: number): Extent;\n}\nexport default TileConfig;\ntype TileIndex = {\n    x: number;\n    y: number;\n    idx: number;\n    idy: number;\n    out: any;\n};\n"},{"path":"layer/tile/tileinfo/TileSystem.d.ts","content":"/**\n * @classdesc\n * A class internally used by tile layer helps to descibe tile system used by different tile services.<br>\n *\n * @class\n * @category layer\n * @example\n * var ts = new TileSystem([1, -1, -20037508.34, 20037508.34]);\n */\ndeclare class TileSystem {\n    scale: {\n        x: number;\n        y: number;\n    };\n    origin: {\n        x: number;\n        y: number;\n    };\n    /**\n     * Similar with [transformation]{@link Transformation}, it contains 4 numbers: sx, sy, ox, oy.<br>\n     * @see {@link http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification}\n     * @param sx the order of X-axis tile index, 1 means right is larger and -1 means the reverse, left is larger;\n     * @param sy the order of Y-axis tile index, 1 means bottom is larger and -1 means the reverse, top is larger;\n     * @param ox x of the origin point of the world's projected coordinate system\n     * @param oy y of the origin point of the world's projected coordinate system\n     */\n    constructor(sx: number | number[], sy?: number, ox?: number, oy?: number);\n    /**\n     * Get the default tile system's code for the projection.\n     * @param projection      - a projection object\n     * @return tile system code\n     */\n    static getDefault(projection: any): string | number[];\n}\nexport default TileSystem;\n"},{"path":"layer/tile/TileLayer.d.ts","content":"import { Matrix4 } from '../../core/util';\nimport { ArrayLRUCache } from '../../core/util/LRUCache';\nimport Size from '../../geo/Size';\nimport Point from '../../geo/Point';\nimport PointExtent from '../../geo/PointExtent';\nimport TileConfig from './tileinfo/TileConfig';\nimport Layer, { LayerJSONType, LayerOptionsType } from '../Layer';\nimport SpatialReference, { SpatialReferenceType } from '../../map/spatial-reference/SpatialReference';\nimport { Coordinate, Extent } from '../../geo';\nimport { type TileLayerCanvasRenderer } from '../../renderer';\nimport { type Map } from '../../map';\ndeclare class TileHashset {\n    private _table;\n    constructor();\n    add(key: string | number): void;\n    has(key: string | number): any;\n    reset(): void;\n}\n/**\n * A layer used to display tiled map services, such as [google maps](http://maps.google.com), [open street maps](http://www.osm.org)\n * @category layer\n * @example\n *  new TileLayer(\"tile\",{\n        urlTemplate : 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n        subdomains:['a','b','c']\n    })\n */\ndeclare class TileLayer extends Layer {\n    tileInfoCache: ArrayLRUCache;\n    _tileSize: Size;\n    _coordCache: Record<string, Point>;\n    _disablePyramid: boolean;\n    _hasOwnSR: boolean;\n    _tileFullExtent: PointExtent;\n    _rootNodes: any;\n    _visitedTiles: TileHashset;\n    _zScale: number;\n    _sr: SpatialReference;\n    _srMinZoom: number;\n    _srMaxZoom: number;\n    _defaultTileConfig: TileConfig;\n    _tileConfig: TileConfig;\n    _polygonOffset: number;\n    _renderer: TileLayerCanvasRenderer;\n    /**\n     *\n     * @param id - tile layer's id\n     * @param options - options defined in TileLayerOptionsType\n     */\n    constructor(id: string, options?: TileLayerOptionsType);\n    /**\n     * Reproduce a TileLayer from layer's profile JSON.\n     * @param layerJSON - layer's profile JSON\n     * @return\n     * @static\n     * @protected\n     * @function\n     */\n    static fromJSON(layerJSON: Record<string, any>): TileLayer;\n    /**\n     * force Reload tilelayer.\n     * Note that this method will clear all cached tiles and reload them. It shouldn't be called frequently for performance reason.\n\n     * @return this\n     */\n    forceReload(): this;\n    /**\n     * Get tile size of the tile layer\n     * @return\n     */\n    getTileSize(id?: string): Size;\n    getTiles(z: number, parentLayer: Layer): TilesType;\n    _isPyramidMode(): boolean;\n    _getTileFullExtent(): Extent;\n    _getRootNodes(offset0: TileOffsetType): TileRootType;\n    createTileNode(x: number, y: number, z: number, idx: number, idy: number, res: number, error: number, parentId?: string, extent2d?: PointExtent, tileId?: string): TileNodeType;\n    _getRootError(): number;\n    _getPyramidTiles(z: number, layer: Layer): TilesType;\n    isParentTile(z: number, maxZoom: number, tile: TileNodeType): boolean;\n    _splitNode(node: TileNodeType, projectionView: Matrix4, queue: TileNodeType[], tiles: TileNodeType[], gridExtent: PointExtent, maxZoom: number, offset: TileOffsetType, parentRenderer: any, glRes: number): void;\n    _createChildNode(node: TileNodeType, dx: number, dy: number, offset?: TileOffsetType, tileId?: string): TileNodeType;\n    _isTileVisible(node: TileNodeType, projectionView: Matrix4, glScale: number, maxZoom: number, offset: TileOffsetType): 0 | 1 | -1;\n    private _isTileInFrustum;\n    /**\n     * Compute tile's SSE\n     * from Cesium\n     * 与cesium不同的是，我们用boundingVolume顶面的四个顶点中的最小值作为distanceToCamera\n     */\n    private _getScreenSpaceError;\n    /**\n     * Get tiles at zoom z (or current zoom)\n     * @param z - zoom\n     * @return tile descriptors\n     */\n    private _getCascadeTiles;\n    /**\n     * Get tile's url\n     * @param x\n     * @param y\n     * @param z\n     * @returns url\n     */\n    getTileUrl(x: number, y: number, z: number): string;\n    /**\n     * Clear the layer\n     * @return this\n     */\n    clear(): this;\n    /**\n     * Export the tile layer's profile json. <br>\n     * Layer's profile is a snapshot of the layer in JSON format. <br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method\n     * @return layer's profile JSON\n     */\n    toJSON(): LayerJSONType;\n    /**\n     * Get tilelayer's spatial reference.\n     * @returns spatial reference\n     */\n    getSpatialReference(): SpatialReference;\n    getMinZoom(): number;\n    getMaxZoom(): number;\n    _getTileZoom(zoom: number): number;\n    /**\n     * Get tileLayer's max available zoom, either options['maxAvailableZoom'] or spatialReference's maxZoom\n     *\n     * @returns\n     **/\n    getMaxAvailableZoom(): number;\n    _getTiles(tileZoom: number, containerExtent: PointExtent, cascadeLevel: number, parentRenderer: any, ignoreMinZoom?: boolean): TileGridType;\n    _convertToExtent2d(containerExtent: PointExtent): PointExtent | Extent;\n    _splitTiles(frustumMatrix: Matrix4, tiles: TileNodeType[], renderer: any, tileIdx: TileNodeType, z: number, res: number, tileExtent: PointExtent, dx?: number, dy?: number, tileOffsets?: Record<string, TileOffsetType>): void;\n    _checkAndAddTile(frustumMatrix: Matrix4, renderer: any, idx: number, idy: number, x: number, y: number, z: number, res: number, i: number, j: number, w: number, h: number, corner: Point, glScale: number, tileOffsets: Record<string, TileOffsetType>): TileNodeType;\n    _getTileOffset(...params: number[]): TileOffsetType;\n    getTileId(x: number, y: number, zoom: number, id: string): string;\n    _getTileId(x: number, y: number, zoom: number, id?: string): string;\n    _project(pcoord: Coordinate, out: Point): Coordinate;\n    _unproject(pcoord: Coordinate, out: Point): Coordinate;\n    /**\n     * initialize [tileConfig]{@link TileConfig} for the tilelayer\n     * @private\n     */\n    _initTileConfig(): void;\n    _getTileConfig(): TileConfig;\n    _bindMap(map: Map): any;\n    _isTileInExtent(frustumMatrix: Matrix4, tileExtent: PointExtent, offset: TileOffsetType, glScale: number): any;\n    _isSplittedTileInExtent(frustumMatrix: any, tileExtent: PointExtent, offset: TileOffsetType, glScale: number): boolean;\n    getEvents(): {\n        spatialreferencechange: () => void;\n    };\n    _onSpatialReferenceChange(): void;\n    /**\n     * Get layer's polygonOffset count\n     * @return\n     */\n    getPolygonOffsetCount(): number;\n    /**\n     * Get layer's base polygon offset\n     * @return\n     */\n    getPolygonOffset(): number;\n    /**\n     * Set layer's base polygon offset, called by GroupGLLayer\n     * @param offset polygon offset\n     * @return\n     */\n    setPolygonOffset(offset: number): this;\n    getRenderer(): TileLayerCanvasRenderer;\n}\nexport default TileLayer;\nexport type TileOffsetType = [number, number];\nexport type TileNodeType = {\n    x: number;\n    y: number;\n    z: number;\n    url: string;\n    res: number;\n    parent: string;\n    offset: TileOffsetType;\n    layer: string;\n    idy: number;\n    idx: number;\n    id: string;\n    extent2d: PointExtent;\n    error: number;\n    children: Array<string>;\n    minAltitude?: number;\n    maxAltitude?: number;\n};\nexport type TileGridType = {\n    count?: number;\n    extent: PointExtent;\n    offset: TileOffsetType;\n    parents?: Array<TileNodeType>;\n    tiles: Array<TileNodeType>;\n    zoom: number;\n};\nexport type TilesType = {\n    tileGrids: Array<TileGridType>;\n    count: number;\n};\nexport type TileCacheType = {\n    info: TileNodeType;\n};\nexport type TileRootType = {\n    status: 0 | 1;\n    error?: string;\n    tiles?: Array<TileNodeType>;\n    mapWidth?: number;\n    mapHeight?: number;\n};\nexport type TileLayerOptionsType = LayerOptionsType & {\n    urlTemplate: string | ((...args: any[]) => string);\n    subdomains?: string[];\n    spatialReference?: SpatialReferenceType;\n    tileSize?: number[];\n    offset?: number[] | ((...args: any[]) => number[]);\n    tileSystem?: [number, number, number, number];\n    maxAvailableZoom?: number;\n    repeatWorld?: boolean;\n    background?: boolean;\n    placeholder?: boolean | ((...args: any[]) => boolean);\n    fragmentShader?: string;\n    crossOrigin?: string;\n    fadeAnimation?: boolean;\n    fadeDuration?: number;\n    debug?: boolean;\n    renderer?: 'gl' | 'canvas';\n    maxCacheSize?: number;\n    cascadeTiles?: boolean;\n    zoomOffset?: number;\n    tileRetryCount?: number;\n    errorUrl?: string;\n    customTags?: Record<string, any>;\n    decodeImageInWorker?: boolean;\n    token?: string;\n    fetchOptions?: Record<string, any>;\n    awareOfTerrain?: boolean;\n    bufferPixel?: number;\n    depthMask?: boolean;\n    loadingLimitOnInteracting?: number;\n    loadingLimit?: number;\n    clipByPitch?: boolean;\n    pyramidMode?: number;\n    tileLimitPerFrame?: number;\n    tileStackStartDepth?: number;\n    tileStackDepth?: number;\n    mipmapTexture?: boolean;\n    currentTilesFirst?: boolean;\n};\n"},{"path":"layer/tile/WMSTileLayer.d.ts","content":"import { LayerJSONType } from '../Layer';\nimport TileLayer, { TileLayerOptionsType } from './TileLayer';\n/**\n * @classdesc\n * Used to display [WMS]{https://en.wikipedia.org/wiki/Web_Map_Service} services as tile layers on the map. Extends [TileLayer]{@link TileLayer}.\n * Implemented based on Leaflet's TileLayer.WMS.\n * @category layer\n * @extends TileLayer\n * @param id - tile layer's id\n * @param - options defined in [WMSTileLayer]{@link TileLayer#options}\n * @example\n * var layer = new maptalks.WMSTileLayer('wms', {\n *     'urlTemplate' : 'https://demo.boundlessgeo.com/geoserver/ows',\n *     'crs' : 'EPSG:3857',\n *     'layers' : 'ne:ne',\n *     'styles' : '',\n *     'version' : '1.3.0',\n *     'format': 'image/png',\n *     'transparent' : true,\n *     'uppercase' : true\n * });\n */\ndeclare class WMSTileLayer extends TileLayer {\n    wmsParams: WMSTileLayerOptionsType;\n    options: WMSTileLayerOptionsType;\n    private _wmsVersion;\n    constructor(id: string, options: WMSTileLayerOptionsType);\n    _optionsHook(options?: {}): this;\n    onAdd(): void;\n    getTileUrl(x: number, y: number, z: number): string;\n    /**\n     * Export the WMSTileLayer's json. <br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method\n     * @return layer's JSON\n     */\n    toJSON(): LayerJSONType;\n    /**\n     * Reproduce a WMSTileLayer from layer's JSON.\n     * @param layerJSON - layer's JSON\n     * @return a WMSTileLayer instance\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(layerJSON: {\n        [x: string]: any;\n    }): WMSTileLayer;\n}\nexport default WMSTileLayer;\nexport declare function getParamString(obj: Record<string, string>, existingUrl: string, uppercase: boolean): string;\nexport type WMSTileLayerOptionsType = TileLayerOptionsType & {\n    service?: string;\n    layers?: string;\n    styles?: string;\n    format?: string;\n    transparent?: boolean;\n    version?: string;\n    crs?: string;\n    uppercase?: boolean;\n    detectRetina?: boolean;\n    width?: number;\n    height?: number;\n};\n"},{"path":"layer/VectorLayer.d.ts","content":"import Extent from '../geo/Extent';\nimport Geometry from '../geometry/Geometry';\nimport OverlayLayer, { LayerIdentifyOptionsType, OverlayLayerOptionsType } from './OverlayLayer';\nimport Painter from '../renderer/geometry/Painter';\nimport CollectionPainter from '../renderer/geometry/CollectionPainter';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport { VectorLayerCanvasRenderer } from '../renderer';\nimport { LayerJSONType } from './Layer';\ntype VectorLayerToJSONOptions = {\n    geometries: any;\n    clipExtent: Extent;\n};\n/**\n * 用于管理、呈现 geometries 的 layer\n *\n * @english\n * @classdesc\n * A layer for managing and rendering geometries.\n * @category layer\n * @extends OverlayLayer\n */\ndeclare class VectorLayer extends OverlayLayer {\n    options: VectorLayerOptionsType;\n    /**\n     * @param id                    - layer's id\n     * @param geometries=null       - geometries to add\n     * @param options=null          - construct options\n     * @param options.style=null    - vectorlayer's style\n     * @param options.*=null        - options defined in [VectorLayer]{@link VectorLayer#options}\n     */\n    constructor(id: string, geometries: VectorLayerOptionsType | Array<Geometry>, options?: VectorLayerOptionsType);\n    onConfig(conf: Record<string, any>): void;\n    /**\n     * 通过给定 coordinate 识别 geometries\n     *\n     * @english\n     * Identify the geometries on the given coordinate\n     * @param  {maptalks.Coordinate} coordinate   - coordinate to identify\n     * @param  {Object} [options=null]  - options\n     * @param  {Object} [options.tolerance=0] - identify tolerance in pixel\n     * @param  {Object} [options.count=null]  - result count\n     * @return {Geometry[]} geometries identified\n     */\n    identify(coordinate: Coordinate, options?: LayerIdentifyOptionsType): Geometry[];\n    /**\n     * 通过给定 point 识别 geometries\n     *\n     * @english\n     * Identify the geometries on the given container point\n     * @param  {maptalks.Point} point   - container point to identify\n     * @param  {Object} [options=null]  - options\n     * @param  {Object} [options.tolerance=0] - identify tolerance in pixel\n     * @param  {Object} [options.count=null]  - result count\n     * @return {Geometry[]} geometries identified\n     */\n    identifyAtPoint(point: Point, options?: LayerIdentifyOptionsType): any;\n    _hitGeos(geometries: Array<Geometry>, cp: Point, options: LayerIdentifyOptionsType): Geometry[];\n    getAltitude(): number;\n    /**\n     * 输出 VectorLayer 的 json\n     *\n     * @english\n     * Export the VectorLayer's JSON. <br>\n     * @param  {Object} [options=null] - export options\n     * @param  {Object} [options.geometries=null] - If not null and the layer is a [OverlayerLayer]{@link OverlayLayer},\n     *                                            the layer's geometries will be exported with the given \"options.geometries\" as a parameter of geometry's toJSON.\n     * @param  {Extent} [options.clipExtent=null] - if set, only the geometries intersectes with the extent will be exported.\n     * @return layer's JSON\n     */\n    toJSON(options?: VectorLayerToJSONOptions): LayerJSONType;\n    getRenderer(): VectorLayerCanvasRenderer;\n    /**\n     * 通过 json 生成 VectorLayer\n     *\n     * @english\n     * Reproduce a VectorLayer from layer's JSON.\n     * @param  {Object} layerJSON - layer's JSON\n     * @return {VectorLayer}\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(json: Record<string, any>): VectorLayer;\n    static getPainterClass(): typeof Painter;\n    static getCollectionPainterClass(): typeof CollectionPainter;\n}\nexport default VectorLayer;\nexport type VectorLayerOptionsType = OverlayLayerOptionsType & {\n    debug?: boolean;\n    enableSimplify?: boolean;\n    cursor?: string;\n    geometryEvents?: boolean;\n    defaultIconSize?: [number, number];\n    cacheVectorOnCanvas?: boolean;\n    cacheSvgOnCanvas?: boolean;\n    enableAltitude?: boolean;\n    altitudeProperty?: string;\n    drawAltitude?: boolean;\n    sortByDistanceToCamera?: boolean;\n    roundPoint?: boolean;\n    altitude?: number;\n    clipBBoxBufferSize?: number;\n    collision?: boolean;\n    collisionBufferSize?: number;\n    collisionDelay?: number;\n    collisionScope?: 'layer' | 'map';\n    progressiveRender?: boolean;\n    progressiveRenderCount?: number;\n    progressiveRenderDebug?: boolean;\n};\n"},{"path":"map/handler/CommonType.d.ts","content":"import { Coordinate, Point } from '../../geo';\nexport type Event = {\n    type: string;\n    target: any;\n    coordinate: Coordinate;\n    containerPoint: Point;\n    viewPoint: Point;\n    domEvent: Event;\n};\nexport type Param = {\n    type: string;\n    target: any;\n    geometry: any;\n    coordinate: Coordinate;\n    containerPoint: Point;\n    viewPoint: Point;\n    domEvent: MouseEvent;\n    ignoreEndEvent?: boolean;\n    interupted?: boolean;\n};\n"},{"path":"map/handler/Map.AutoPanAtEdge.d.ts","content":"import Handler from '../../handler/Handler';\nimport { type Event } from './CommonType';\ndeclare class MapAutoPanAtEdgeHandler extends Handler {\n    addHooks(): void;\n    removeHooks(): void;\n    _onMouseMove(event: Event): void;\n}\nexport default MapAutoPanAtEdgeHandler;\n"},{"path":"map/handler/Map.BoxZoom.d.ts","content":"import Handler from '../../handler/Handler';\nimport DrawTool from '../tool/DrawTool';\nimport { type Param } from './CommonType';\ndeclare class MapBoxZoomHander extends Handler {\n    drawTool: DrawTool;\n    constructor(target: any);\n    addHooks(): void;\n    removeHooks(): void;\n    _onMouseDown(param: Param): void;\n    _boxZoom(param: Param): void;\n}\nexport default MapBoxZoomHander;\n"},{"path":"map/handler/Map.DoubleClickZoom.d.ts","content":"import Handler from '../../handler/Handler';\nimport { type Param } from './CommonType';\ndeclare class MapDoubleClickZoomHandler extends Handler {\n    addHooks(): void;\n    removeHooks(): void;\n    _onDoubleClick(param: Param): void;\n}\nexport default MapDoubleClickZoomHandler;\n"},{"path":"map/handler/Map.Drag.d.ts","content":"import Handler from '../../handler/Handler';\nimport DragHandler from '../../handler/Drag';\nimport { type Param } from './CommonType';\ndeclare class MapDragHandler extends Handler {\n    _dragHandler: DragHandler;\n    startDragTime: number;\n    startBearing: number;\n    _mode: 'rotatePitch' | 'move';\n    preX: number;\n    preY: number;\n    startX: number;\n    startY: number;\n    _startPrjCenter: any;\n    startPrjCoord: any;\n    _rotateMode: 'rotate_pitch' | 'rotate' | 'pitch';\n    _db: number;\n    addHooks(): void;\n    removeHooks(): void;\n    _cancelOn(domEvent: any): boolean;\n    _ignore(param: any): any;\n    _onMouseDown(param: any): void;\n    _onDragStart(param: any): void;\n    _onDragging(param: any): void;\n    _onDragEnd(param: any): void;\n    _start(param: any): void;\n    _moveStart(param: any): void;\n    _moving(param: any): void;\n    _containerPointToPrj(p: any): any;\n    _moveEnd(param: Param): void;\n    _rotateStart(param: Param): void;\n    _rotating(param: Param): void;\n    _rotateEnd(param: Param): void;\n    _clear(): void;\n}\nexport default MapDragHandler;\n"},{"path":"map/handler/Map.GeometryEvents.d.ts","content":"import Handler from '../../handler/Handler';\ndeclare class MapGeometryEventsHandler extends Handler {\n    _mouseDownTime: number;\n    _queryIdentifyTimeout: number;\n    addHooks(): void;\n    removeHooks(): void;\n    _identifyGeometryEvents(domEvent: any, type: any): void;\n}\nexport default MapGeometryEventsHandler;\n"},{"path":"map/handler/Map.ScrollWheelZoom.d.ts","content":"/// <reference types=\"node\" />\nimport Handler from '../../handler/Handler';\ndeclare class MapScrollWheelZoomHandler extends Handler {\n    _thisScrollZoom: number;\n    _wheelZoomRate: number;\n    _defaultZoomRate: number;\n    _delta: number;\n    _zooming: boolean;\n    _trackPadSuspect: number;\n    _ensureTrackpad: boolean;\n    _active: boolean;\n    _timeout: NodeJS.Timeout;\n    _requesting: number;\n    _startZoom: number;\n    _origin: any;\n    _zoomOrigin: any;\n    _lastWheelEvent: any;\n    constructor(target: any);\n    addHooks(): void;\n    removeHooks(): void;\n    _onWheelScroll(evt: any): boolean | void;\n    _seamless(evt: any, origin: any): void;\n    _start(): void;\n    _scrollZoom(): void;\n    _interval(evt: any, origin: any): boolean;\n}\nexport default MapScrollWheelZoomHandler;\n"},{"path":"map/handler/Map.Touch.d.ts","content":"import Handler from '../../handler/Handler';\nimport Point from '../../geo/Point';\ndeclare class MapTouchZoomHandler extends Handler {\n    preY: number;\n    _startP1: Point;\n    _startP2: Point;\n    _startDist: number;\n    _startVector: Point;\n    _startZoom: number;\n    _startBearing: number;\n    mode: 'rotate_zoom' | 'pitch' | 'rotate' | 'zoom';\n    _scale: number;\n    _Origin: Point;\n    addHooks(): void;\n    removeHooks(): void;\n    _onTouchStart(event: any): void;\n    _onTouchMove(event: any): void;\n    _startTouching(param: any): void;\n    _onTouchEnd(event: any): void;\n}\nexport default MapTouchZoomHandler;\n"},{"path":"map/index.d.ts","content":"import Map from './Map';\nimport './handler/Map.DoubleClickZoom';\nimport './handler/Map.Drag';\nimport './handler/Map.GeometryEvents';\nimport './handler/Map.ScrollWheelZoom';\nimport './handler/Map.Touch';\nimport './handler/Map.BoxZoom';\nimport './handler/Map.AutoPanAtEdge';\nimport './Map.Anim';\nimport './Map.DomEvents';\nimport './Map.FullScreen';\nimport './Map.Pan';\nimport './Map.Topo';\nimport './Map.Zoom';\nimport './Map.Camera';\nimport './Map.ViewHistory';\nimport './Map.Collision';\nimport './Map.CoordTransform';\nexport { Map };\n"},{"path":"map/Map.Anim.d.ts","content":"import { Player } from '../core/Animation';\ndeclare module \"./Map\" {\n    interface Map {\n        _mapAnimPlayer: Player;\n        isRotating(): boolean;\n        _animateTo(view: MapViewType, options?: MapAnimationOptionsType, step?: (frame: any) => void): Player;\n        _stopAnim(player?: Player): void;\n        animateTo(view: MapViewType, options?: MapAnimationOptionsType, step?: (frame: any) => void): Player;\n        flyTo(view: MapViewType, options?: MapAnimationOptionsType, step?: (frame: any) => void): this;\n        isAnimating(): boolean;\n    }\n}\n"},{"path":"map/Map.Camera.d.ts","content":"import Point from '../geo/Point';\nimport Coordinate from '../geo/Coordinate';\nimport { type Matrix4 } from '../core/util';\ndeclare module \"./Map\" {\n    interface Map {\n        cameraPosition: Point;\n        cameraLookAt: number[];\n        projViewMatrix: Matrix4;\n        getFov(): number;\n        setFov(fov: number): this;\n        getBearing(): number;\n        setBearing(bearing: number): this;\n        _setBearing(bearing: number): this;\n        getPitch(): number;\n        setPitch(pitch: number): this;\n        _setPitch(pitch: number): this;\n        _calcMatrices(): void;\n        _containerPointToPoint(p: Point, zoom?: number, out?: Point): Point;\n        _recenterOnTerrain(): void;\n        setCameraMovements(frameOptions: Array<MapViewType>, option?: {\n            autoRotate: boolean;\n        }): any;\n        setCameraOrientation(params: MapViewType): this;\n        setCameraPosition(coordinate: Coordinate): any;\n        getFitZoomForCamera(cameraPosition: Array<number>, pitch: number): any;\n        isTransforming(): boolean;\n        getFrustumAltitude(): number;\n        updateCenterAltitude(): any;\n        _queryTerrainByProjCoord(coord: Coordinate): number;\n        _hasAltitudeLayer(): boolean;\n        _queryTerrainInfo(containerPoint: Point): {\n            coordinate: Coordinate;\n            altitude: number;\n        } | null;\n        _pointAtResToContainerPoint(point: Point, res?: number, altitude?: number, out?: Point): Point;\n        _pointToContainerPoint(point: Point, zoom?: number, out?: Point): Point;\n        _pointsAtResToContainerPoints(point: Point[], res?: number, altitude?: number[], out?: Point[]): Point[];\n    }\n}\n"},{"path":"map/Map.Collision.d.ts","content":"import CollisionIndex from '../core/CollisionIndex';\nimport UIComponent from '../ui/UIComponent';\ndeclare module \"./Map\" {\n    interface Map {\n        getCollisionIndex(): CollisionIndex;\n        createCollisionIndex(): CollisionIndex;\n        clearCollisionIndex(): this;\n        _insertUICollidesQueue(): this;\n        uiCollides(): this;\n        _addUI(ui: UIComponent): this;\n        _removeUI(ui: UIComponent): number;\n    }\n}\n"},{"path":"map/Map.CoordTransform.d.ts","content":"import { Coordinate, Extent, Point, PointExtent, Size } from '../geo';\ndeclare module \"./Map\" {\n    interface Map {\n        /**\n         * Converts a coordinate to the 2D point in current zoom or in the specific zoom. <br>\n         * The 2D point's coordinate system's origin is the same with map's origin.\n         * Usually used in plugin development.\n         * @param  coordinate - coordinate\n         * @param  zoom  - zoom level\n         * @param  out    - optional point to receive result\n         * @return  2D point\n         * @example\n         * var point = map.coordinateToPoint(new Coordinate(121.3, 29.1));\n         */\n        coordinateToPoint(coordinate: Coordinate, zoom?: number, out?: Point): Point;\n        /**\n         * Converts a coordinate to the 2D point at specified resolution. <br>\n         * The 2D point's coordinate system's origin is the same with map's origin.\n         * Usually used in plugin development.\n         * @param  coordinate - coordinate\n         * @param  res  - target resolution\n         * @param  out    - optional point to receive result\n         * @return  2D point\n         * @example\n         * var point = map.coordinateToPoint(new Coordinate(121.3, 29.1));\n         */\n        coordinateToPointAtRes(coordinate: Coordinate, res?: number, out?: Point): Point;\n        /**\n         * Converts a 2D point in current zoom or a specific zoom to a coordinate.\n         * Usually used in plugin development.\n         * @param  point - 2D point\n         * @param  zoom  - point's zoom level\n         * @param  out    - optional coordinate to receive result\n         * @return coordinate\n         * @example\n         * var coord = map.pointToCoordinate(new Point(4E6, 3E4));\n         */\n        pointToCoordinate(point: Point, zoom?: number, out?: Coordinate): Coordinate;\n        /**\n         * Converts a 2D point at specific resolution to a coordinate.\n         * Usually used in plugin development.\n         * @param  point - 2D point\n         * @param  res  - point's resolution\n         * @param  out    - optional coordinate to receive result\n         * @return coordinate\n         * @example\n         * var coord = map.pointAtResToCoordinate(new Point(4E6, 3E4), map.getResolution());\n         */\n        pointAtResToCoordinate(point: Point, res?: number, out?: Coordinate): Coordinate;\n        /**\n         * Converts a geographical coordinate to view point.<br>\n         * A view point is a point relative to map's mapPlatform panel's position. <br>\n         * Usually used in plugin development.\n         * @param coordinate\n         * @param  out    - optional point to receive result\n         * @return          */\n        coordinateToViewPoint(coordinate: Coordinate, out?: Point, altitude?: number): Point;\n        /**\n         * Converts a view point to the geographical coordinate.\n         * Usually used in plugin development.\n         * @param viewPoint\n         * @param  out    - optional coordinate to receive result\n         * @return          */\n        viewPointToCoordinate(viewPoint: Point, out?: Coordinate): Coordinate;\n        /**\n         * Convert a geographical coordinate to the container point. <br>\n         *  A container point is a point relative to map container's top-left corner. <br>\n         * @param                - coordinate\n         * @param  zoom  - zoom level\n         * @param  out    - optional point to receive result\n         * @return          */\n        coordinateToContainerPoint(coordinate: Coordinate, zoom?: number, out?: Point): Point;\n        coordinateToContainerPointAtRes(coordinate: Coordinate, res?: number, out?: Point): Point;\n        /**\n         * Convert a geographical coordinate to the container point. <br>\n         * Batch conversion for better performance <br>\n         *  A container point is a point relative to map container's top-left corner. <br>\n         * @param  coordinates - coordinates\n         * @param  zoom  - zoom level\n         * @return {Point[]}\n         */\n        coordinatesToContainerPoints(coordinates: Array<Coordinate>, zoom?: number): Array<Point>;\n        /**\n         * Convert a geographical coordinate to the container point. <br>\n         * Batch conversion for better performance <br>\n         *  A container point is a point relative to map container's top-left corner. <br>\n         * @param  coordinates                - coordinates\n         * @param  resolution  - container points' resolution\n         * @return\n         */\n        coordinatesToContainerPointsAtRes(coordinates: Array<Coordinate>, res?: number): Array<Point>;\n        /**\n         * Converts a container point to geographical coordinate.\n         * @param          * @param  out    - optional coordinate to receive result\n         * @return          */\n        containerPointToCoordinate(containerPoint: Point, out?: Coordinate): Coordinate;\n        /**\n         * Converts a container point extent to the geographic extent.\n         * @param  containerExtent - containeproints extent\n         * @return  geographic extent\n         */\n        containerToExtent(containerExtent: PointExtent): Extent;\n        /**\n         * Converts geographical distances to the pixel length.<br>\n         * The value varis with difference zoom level.\n         *\n         * @param  xDist - distance on X axis.\n         * @param  yDist - distance on Y axis.\n         * @return {Size} result.width: pixel length on X axis; result.height: pixel length on Y axis\n         */\n        distanceToPixel(xDist: number, yDist: number, zoom?: number): Size;\n        /**\n         * Converts geographical distances to the 2d point length.<br>\n         * The value varis with difference zoom level.\n         *\n         * @param  xDist - distance on X axis.\n         * @param  yDist - distance on Y axis.\n         * @param  zoom - point's zoom\n         * @return          */\n        distanceToPoint(xDist: number, yDist: number, zoom?: number, paramCenter?: Coordinate): Point;\n        /**\n         * Converts geographical distances to the 2d point length at specified resolution.\n         *\n         * @param  xDist - distance on X axis.\n         * @param  yDist - distance on Y axis.\n         * @param  res - target resolution\n         * @return          */\n        distanceToPointAtRes(xDist: number, yDist: number, res?: number, paramCenter?: Coordinate, out?: Point): Point;\n        /**\n         * Converts height/altitude  to the 2d point\n         *\n         * @param  altitude - the value of altitude,suche as: map.altitudeToPoint(100);\n         * @param  res - target resolution\n         * @param  [originCenter=null] - optional original coordinate for caculation\n         * @return          */\n        altitudeToPoint(altitude: number, res?: number, originCenter?: Coordinate): number;\n        pointAtResToAltitude(point: Point, res?: number, originCenter?: Coordinate): number;\n        /**\n         * Converts pixel size to geographical distance.\n         *\n         * @param  width - pixel width\n         * @param  height - pixel height\n         * @return  distance - Geographical distance\n         */\n        pixelToDistance(width: number, height: number): number;\n        /**\n         * Converts 2d point distances to geographic length.<br>\n         *\n         * @param  dx - distance on X axis.\n         * @param  dy - distance on Y axis.\n         * @param  zoom - point's zoom\n         * @return distance\n         */\n        pointToDistance(dx: number, dy: number, zoom?: number): number;\n        /**\n         * Converts 2d point distances to geographic length.<br>\n         *\n         * @param  dx - distance on X axis.\n         * @param  dy - distance on Y axis.\n         * @param  res - point's resolution\n         * @return distance\n         */\n        pointAtResToDistance(dx: number, dy: number, res?: number, paramCenter?: Coordinate): number;\n        /**\n         * Computes the coordinate from the given pixel distance.\n         * @param  coordinate - source coordinate\n         * @param  px           - pixel distance on X axis\n         * @param  py           - pixel distance on Y axis\n         * @return Result coordinate\n         */\n        locateByPoint(coordinate: Coordinate, px: number, py: number): Coordinate;\n        /**\n         * Get map's extent in view points.\n         * @param zoom - zoom\n         * @return\n         */\n        get2DExtent(zoom?: number, out?: PointExtent): PointExtent;\n        get2DExtentAtRes(res?: number, out?: PointExtent): PointExtent;\n        /**\n         * Converts a view point extent to the geographic extent.\n         * @param  extent2D - view points extent\n         * @return  geographic extent\n         */\n        pointToExtent(extent2D: PointExtent): Extent;\n        /**\n         * When moving map, map's center is updated in real time, but platform will be moved in the next frame to keep syncing with other layers\n         * Get the offset in current frame and the next frame\n         * @return view point offset\n         */\n        getViewPointFrameOffset(): Point | null;\n        /**\n     * transform view point to geographical projected coordinate\n        * @param  viewPoint\n        * @param  out  - optional coordinate to receive result\n        * @return         */\n        viewPointToPrj(viewPoint: Point, out?: Point): Point;\n        /**\n         * transform geographical projected coordinate to container point\n         * @param  pCoordinate\n         * @param  zoom target zoom\n         * @param  out    - optional point to receive result\n         */\n        prjToContainerPoint(pCoordinate: Coordinate, zoom?: number, out?: Point, altitude?: number): Point;\n        prjToContainerPointAtRes(pCoordinate: Coordinate, res?: number, out?: Point, altitude?: number): Point;\n        /**\n         * transform geographical projected coordinate to view point\n         * @param  pCoordinate\n         * @return          */\n        prjToViewPoint(pCoordinate: Coordinate, out?: Point, altitude?: number): Point;\n        viewPointToPoint(viewPoint: Point, zoom?: number, out?: Point): Point;\n        pointToViewPoint(point: Point, zoom?: number, out?: Point): Point;\n    }\n}\n"},{"path":"map/Map.d.ts","content":"import Class from '../core/Class';\nimport Point from '../geo/Point';\nimport Size from '../geo/Size';\nimport PointExtent from '../geo/PointExtent';\nimport Extent from '../geo/Extent';\nimport Coordinate from '../geo/Coordinate';\nimport Layer from '../layer/Layer';\nimport SpatialReference, { type SpatialReferenceType } from './spatial-reference/SpatialReference';\nimport { AnimationOptionsType, EasingType } from '../core/Animation';\ndeclare const Map_base: {\n    new (...args: any[]): {\n        _handlers?: import(\"src\").Handler[];\n        addHandler(name: any, handlerClass: any): any;\n        removeHandler(name: any): any;\n        _clearHandlers(): void;\n    };\n} & {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & {\n    new (...args: any[]): {};\n    registerRenderer<T extends typeof Class>(name: string, clazz: T): any & typeof Class;\n    getRendererClass(name: string): Class;\n} & typeof Class;\n/**\n * The central class of the library, to create a map on a container.\n *\n * @category map\n *\n * @mixes Eventable\n * @mixes Handlerable\n * @mixes ui.Menuable\n * @mixes Renderable\n *\n * @example\n * var map = new maptalks.Map(\"map\",{\n *      center:     [180,0],\n *      zoom:  4,\n *      baseLayer : new maptalks.TileLayer(\"base\",{\n *          urlTemplate:'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n *          subdomains:['a','b','c']\n *      }),\n *      layers : [\n *          new maptalks.VectorLayer('v', [new maptalks.Marker([180, 0])])\n *      ]\n * });\n */\nexport declare class Map extends Map_base {\n    VERSION: string;\n    private _loaded;\n    private _panels;\n    private _baseLayer;\n    private _layers;\n    private _zoomLevel;\n    private _center;\n    private _centerZ;\n    private _mapViewPoint;\n    isMap: boolean;\n    private _containerDOM;\n    private _spatialReference;\n    private _originLng;\n    private _altitudeOriginDirty;\n    private _glScale;\n    private _cursor;\n    private _prjCenter;\n    private centerAltitude;\n    width: number;\n    height: number;\n    private _prjMaxExtent;\n    private _glRes;\n    private _zooming;\n    private _layerCache;\n    private _mapViewCoord;\n    private _eventSilence;\n    private _moving;\n    private _originCenter;\n    private _suppressRecenter;\n    private _dragRotating;\n    CanvasClass: any;\n    private _priorityCursor;\n    private _initTime;\n    private _renderer;\n    private _containerDomContentRect;\n    private _mapRes;\n    private _onLoadHooks;\n    private cameraCenterDistance;\n    options: MapOptionsType;\n    static VERSION: string;\n    JSON_VERSION: '1.0';\n    /**\n     * @param {(string|HTMLElement|object)} container - The container to create the map on, can be:<br>\n     *                                          1. A HTMLElement container.<br/>\n     *                                          2. ID of a HTMLElement container.<br/>\n     *                                          3. Any canvas compatible container\n     * @param {Object} options - construct options\n     * @param {(Number[]|Coordinate)} options.center - initial center of the map.\n     * @param {Number} options.zoom - initial zoom of the map.\n     * @param {Object} [options.spatialReference=null] - map's spatial reference, default is using projection EPSG:3857 with resolutions used by google map/osm.\n     * @param {Layer} [options.baseLayer=null] - base layer that will be set to map initially.\n     * @param {Layer[]} [options.layers=null] - layers that will be added to map initially.\n     * @param {*} options.* - any other option defined in [Map.options]{@link Map#options}      [description]\n     */\n    constructor(container: MapContainerType, options: MapCreateOptionsType);\n    /**\n     * Add hooks for additional codes when map's loading complete, useful for plugin developping.\n     * Note that it can only be called before the map is created.\n     * @param {Function | any} fn\n     * @returns {Map}\n     */\n    static addOnLoadHook(fn: string | ((...args: any[]) => void), ...args: any[]): typeof Map;\n    /**\n     * Whether the map is loaded or not.\n     * @return {Boolean}\n     */\n    isLoaded(): boolean;\n    /**\n     * Get map's container\n     * @returns {HTMLElement}\n     */\n    getContainer(): HTMLCanvasElement | HTMLDivElement;\n    /**\n     * Get the spatial reference of the Map.\n     * @return {SpatialReference} map's spatial reference\n     */\n    getSpatialReference(): SpatialReference;\n    /**\n     * Change the spatial reference of the map. <br>\n     * A SpatialReference is a series of settings to decide the map presentation:<br>\n     * 1. the projection.<br>\n     * 2. zoom levels and resolutions. <br>\n     * 3. full extent.<br>\n     * There are some [predefined spatial references]{@link http://www.foo.com}, and surely you can [define a custom one.]{@link http://www.foo.com}.<br>\n     * SpatialReference can also be updated by map.config('spatialReference', spatialReference);\n     * @param {SpatialReference} spatialReference - spatial reference\n     * @returns {Map} this\n     * @fires Map#spatialreferencechange\n     * @example\n     *  map.setSpatialReference({\n            projection:'EPSG:4326',\n            resolutions: (function() {\n                const resolutions = [];\n                for (let i=0; i < 19; i++) {\n                    resolutions[i] = 180/(Math.pow(2, i)*128);\n                }\n                return resolutions;\n            })()\n     *  });\n       @example\n     *  map.config('spatialReference', {\n            projection:'EPSG:4326',\n            resolutions: (function() {\n                const resolutions = [];\n                for (let i=0; i < 19; i++) {\n                    resolutions[i] = 180/(Math.pow(2, i)*128);\n                }\n                return resolutions;\n            })()\n        });\n     */\n    setSpatialReference(ref: SpatialReferenceType): this;\n    _updateSpatialReference(ref: SpatialReferenceType, oldRef: any): this;\n    /**\n     * Callback when any option is updated\n     * @param  {Object} conf - options to update\n     * @return {Map}   this\n     */\n    onConfig(conf: {\n        [key: string]: any;\n    }): this;\n    /**\n     * Get the projection of the map. <br>\n     * Projection is an algorithm for map projection, e.g. well-known [Mercator Projection]{@link https://en.wikipedia.org/wiki/Mercator_projection} <br>\n     * A projection must have 2 methods: <br>\n     * 1. project(coordinate) - project the input coordinate <br>\n     * 2. unproject(coordinate) - unproject the input coordinate <br>\n     * Projection also contains measuring method usually extended from a measurer: <br>\n     * 1. measureLength(coord1, coord2) - compute length between 2 coordinates.  <br>\n     * 2. measureArea(coords[]) - compute area of the input coordinates. <br>\n     * 3. locate(coord, distx, disty) - compute the coordinate from the coord with xdist on axis x and ydist on axis y.\n     * @return {Object}\n     */\n    getProjection(): import(\"src/geo/projection\").ProjectionType;\n    /**\n     * Get map's full extent, which is defined in map's spatial reference. <br>\n     * eg: {'left': -180, 'right' : 180, 'top' : 90, 'bottom' : -90}\n     * @return {Extent}\n     */\n    getFullExtent(): Extent;\n    /**\n     * Set map's cursor style, cursor style is same with CSS.\n     * @param {String} cursor - cursor style\n     * @returns {Map} this\n     * @example\n     * map.setCursor('url(cursor.png) 4 12, auto');\n     */\n    setCursor(cursor: string): this;\n    /**\n     * Reset map's cursor style.\n     * @return {Map} this\n     * @example\n     * map.resetCursor();\n     */\n    resetCursor(): this;\n    /**\n     * Get center of the map.\n     * @return {Coordinate}\n     */\n    getCenter(): Coordinate;\n    /**\n     * Set a new center to the map.\n     * @param {Coordinate} center\n     * @param  {Object} [padding]\n     * @param  {Number} [padding.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Number} [padding.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Number} [padding.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Number} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @return {Map} this\n     */\n    setCenter(center: Coordinate, padding?: MapPaddingType): this;\n    /**\n     * Get map's size (width and height) in pixel.\n     * @return {Size}\n     */\n    getSize(): Size;\n    /**\n     * Get container extent of the map\n     * @return {PointExtent}\n     */\n    getContainerExtent(): PointExtent;\n    _getVisualHeight(visualPitch: any): number;\n    /**\n     * Get the geographical extent of map's current view extent.\n     *\n     * @return {Extent}\n     */\n    getExtent(): Extent;\n    /**\n     * Get the projected geographical extent of map's current view extent.\n     *\n     * @return {Extent}\n     */\n    getProjExtent(): Extent;\n    /**\n     * Alias for getProjExtent\n     *\n     * @return {Extent}\n     */\n    getPrjExtent(): Extent;\n    /**\n     * Get the max extent that the map is restricted to.\n     * @return {Extent}\n     */\n    getMaxExtent(): Extent;\n    /**\n     * Sets the max extent that the map is restricted to.\n     * @param {Extent}\n     * @return {Map} this\n     * @example\n     * map.setMaxExtent(map.getExtent());\n     */\n    setMaxExtent(extent: Extent): this;\n    /**\n     * Get map's current zoom.\n     * @return {Number}\n     */\n    getZoom(): number;\n    /**\n     * Caculate the target zoom if scaling from \"fromZoom\" by \"scale\"\n     * @param  {Number} scale\n     * @param  {Number} fromZoom\n     * @param  {Boolean} isFraction - can return fractional zoom\n     * @return {Number} zoom fit for scale starting from fromZoom\n     */\n    getZoomForScale(scale: number, fromZoom?: number, isFraction?: boolean): number;\n    getZoomFromRes(res: number): number;\n    /**\n     * Sets zoom of the map\n     * @param {Number} zoom\n     * @param {Object} [options=null] options\n     * @param {Boolean} [options.animation=true] whether zoom is animation, true by default\n     * @returns {Map} this\n     */\n    setZoom(zoom: number, options?: {\n        animation: boolean;\n    }): this;\n    /**\n     * Get the max zoom that the map can be zoom to.\n     * @return {Number}\n     */\n    getMaxZoom(): number;\n    /**\n     * Sets the max zoom that the map can be zoom to.\n     * @param {Number} maxZoom\n     * @returns {Map} this\n     */\n    setMaxZoom(maxZoom: number): this;\n    /**\n     * Get the min zoom that the map can be zoom to.\n     * @return {Number}\n     */\n    getMinZoom(): number;\n    /**\n     * Sets the min zoom that the map can be zoom to.\n     * @param {Number} minZoom\n     * @return {Map} this\n     */\n    setMinZoom(minZoom: number): this;\n    /**\n     * Maximum zoom the map has\n     * @return {Number}\n     */\n    getMaxNativeZoom(): number;\n    /**\n     * Resolution for world point in WebGL context\n     * @returns {Number}\n     */\n    getGLRes(): number;\n    /**\n     * Caculate scale from gl zoom to given zoom (default by current zoom)\n     * @param {Number} [zoom=undefined] target zoom, current zoom by default\n     * @returns {Number}\n     * @examples\n     * const point = map.coordToPoint(map.getCenter());\n     * // convert to point in gl zoom\n     * const glPoint = point.multi(this.getGLScale());\n     */\n    getGLScale(zoom?: number): number;\n    /**\n     * zoom in\n     * @return {Map} this\n     */\n    zoomIn(): this;\n    /**\n     * zoom out\n     * @return {Map} this\n     */\n    zoomOut(): this;\n    /**\n     * Whether the map is zooming\n     * @return {Boolean}\n     */\n    isZooming(): boolean;\n    /**\n     * Whether the map is being interacted\n     * @return {Boolean}\n     */\n    isInteracting(): boolean;\n    /**\n     * Sets the center and zoom at the same time.\n     * @param {Coordinate} center\n     * @param {Number} zoom\n     * @return {Map} this\n     */\n    setCenterAndZoom(center: Coordinate, zoom?: number): this;\n    /**\n     * Get the padding Size\n     * @param  {Object} options\n     * @param  {Number} [options.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Number} [options.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Number} [options.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Number} [options.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @returns {Object|null}\n     */\n    _getPaddingSize(options?: {}): {\n        width: any;\n        height: any;\n    };\n    /**\n     * Caculate the zoom level that contains the given extent with the maximum zoom level possible.\n     * @param {Extent} extent\n     * @param  {Boolean} [isFraction] - can return fractional zoom\n     * @param  {Object} [padding] [padding] - padding\n     * @param  {Object} [padding.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Object} [padding.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Object} [padding.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Object} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @return {Number} zoom fit for scale starting from fromZoom\n     */\n    getFitZoom(extent: Extent, isFraction?: boolean, padding?: MapPaddingType): number;\n    /**\n     * Get map's current view (center/zoom/pitch/bearing)\n     * @return {Object} { center : *, zoom : *, pitch : *, bearing : * }\n     */\n    getView(): MapViewType;\n    /**\n     * Set map's center/zoom/pitch/bearing at one time\n     * @param {Object} view - a object containing center/zoom/pitch/bearing\n     * return {Map} this\n     */\n    setView(view: MapViewType): this;\n    /**\n     * Get map's resolution\n     * @param {Number} zoom - zoom or current zoom if not given\n     * @return {Number} resolution\n     */\n    getResolution(zoom?: number): number;\n    /**\n     * Get scale of resolutions from zoom to max zoom\n     * @param {Number} zoom - zoom or current zoom if not given\n     * @return {Number} scale\n     */\n    getScale(zoom?: number): number;\n    /**\n     * Get center by the padding.\n     * @private\n     * @param  {Coordinate} center\n     * @param  {Number} zoom\n     * @param  {Object} padding\n     * @param  {Number} [padding.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Number} [padding.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Number} [padding.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Number} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @return {Coordinate}\n     */\n    _getCenterByPadding(center: Coordinate, zoom?: number, padding?: MapPaddingType): Coordinate;\n    /**\n     * Set the map to be fit for the given extent with the max zoom level possible.\n     * @param  {Extent} extent - extent\n     * @param  {Number} zoomOffset - zoom offset\n     * @param  {Object} [options={}] - options\n     * @param  {Object} [options.animation]\n     * @param  {Object} [options.duration]\n     * @param  {Object} [options.zoomAnimationDuration]\n     * @param  {Object} [options.easing='out']\n     * @param  {Number} [options.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Number} [options.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Number} [options.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Number} [options.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @param  {Boolean} [options.isFraction=false] - can locate to fractional zoom\n     * @param  {Function} step - step function for animation\n     * @return {Map | player} - this\n     */\n    fitExtent(extent: Extent, zoomOffset?: number, options?: MapFitType, step?: (frame: any) => void): this | import(\"../core/Animation\").Player;\n    /**\n     * Get the base layer of the map.\n     * @return {Layer}\n     */\n    getBaseLayer(): Layer;\n    /**\n     * Sets a new base layer to the map.<br>\n     * Some events will be thrown such as baselayerchangestart, baselayerload, baselayerchangeend.\n     * @param  {Layer} baseLayer - new base layer\n     * @return {Map} this\n     * @fires Map#setbaselayer\n     * @fires Map#baselayerchangestart\n     * @fires Map#baselayerchangeend\n     */\n    setBaseLayer(baseLayer: Layer): this;\n    /**\n     * Remove the base layer from the map\n     * @return {Map} this\n     * @fires Map#baselayerremove\n     */\n    removeBaseLayer(): this;\n    /**\n     * Get the layers of the map, except base layer (which should be by getBaseLayer). <br>\n     * A filter function can be given to filter layers, e.g. exclude all the VectorLayers.\n     * @param {Function} [filter=undefined] - a filter function of layers, return false to exclude the given layer.\n     * @return {Layer[]}\n     * @example\n     * var vectorLayers = map.getLayers(function (layer) {\n     *     return (layer instanceof VectorLayer);\n     * });\n     */\n    getLayers(filter?: (layer: Layer) => boolean): Array<Layer>;\n    /**\n     * Get the layer with the given id.\n     * @param  {String} id - layer id\n     * @return {Layer}\n     */\n    getLayer(id: string): Layer | null;\n    /**\n     * Add a new layer on the top of the map.\n     * @param  {Layer|Layer[]} layer - one or more layers to add\n     * @return {Map} this\n     * @fires Map#addlayer\n     */\n    addLayer(layers: Layer | Array<Layer>, ...otherLayers: Array<Layer>): this;\n    /**\n     * Remove a layer from the map\n     * @param  {String|String[]|Layer|Layer[]} layer - one or more layers or layer ids\n     * @return {Map} this\n     * @fires Map#removelayer\n     */\n    removeLayer(layers: Layer | Array<Layer>): this;\n    /**\n     * Sort layers according to the order provided, the last will be on the top.\n     * @param  {string[]|Layer[]} layers - layers or layer ids to sort\n     * @return {Map} this\n     * @example\n     * map.addLayer([layer1, layer2, layer3]);\n     * map.sortLayers([layer2, layer3, layer1]);\n     * map.sortLayers(['3', '2', '1']); // sort by layer ids.\n     */\n    sortLayers(layers: Array<Layer>): this;\n    /**\n     * Exports image from the map's canvas.\n     * @param {Object} [options=undefined] - options\n     * @param {String} [options.mimeType=image/png] - mime type of the image: image/png, image/jpeg, image/webp\n     * @param {String} [options.quality=0.92] - A Number between 0 and 1 indicating the image quality to use for image formats that use lossy compression such as image/jpeg and image/webp.\n     * @param {Boolean} [options.save=false] - whether pop a file save dialog to save the export image.\n     * @param {String} [options.fileName=export] - specify the file name, if options.save is true.\n     * @return {String} image of base64 format.\n     */\n    toDataURL(options?: MapDataURLType): string | null;\n    /**\n     * shorter alias for coordinateToPoint\n     */\n    coordToPoint(coordinate: Coordinate, zoom?: number, out?: Point): Point;\n    /**\n     * shorter alias for coordinateToPointAtRes\n     */\n    coordToPointAtRes(coordinate: Coordinate, res?: number, out?: Point): Point;\n    /**\n     * shorter alias for pointToCoordinate\n     */\n    pointToCoord(point: Point, zoom?: number, out?: Coordinate): Coordinate;\n    /**\n     * shorter alias for pointAtResToCoordinate\n     */\n    pointAtResToCoord(point: Point, res?: number, out?: Coordinate): Coordinate;\n    /**\n     * shorter alias for coordinateToViewPoint\n     */\n    coordToViewPoint(coordinate: Coordinate, out?: Point, altitude?: number): Point;\n    /**\n     * shorter alias for viewPointToCoordinate\n     */\n    viewPointToCoord(viewPoint: Point, out?: Coordinate): Coordinate;\n    /**\n     * shorter alias for coordinateToContainerPoint\n     */\n    coordToContainerPoint(coordinate: Coordinate, zoom?: number, out?: Point): Point;\n    /**\n     * shorter alias for containerPointToCoordinate\n     */\n    containerPointToCoord(containerPoint: Point, out?: Coordinate): Coordinate;\n    /**\n     * Converts a container point to the view point.\n     * Usually used in plugin development.\n     * @param {Point}\n     * @param  {Point} [out=undefined]    - optional point to receive result\n     * @returns {Point}\n     */\n    containerPointToViewPoint(containerPoint: Point, out?: Point): Point;\n    /**\n     * Converts a view point to the container point.\n     * Usually used in plugin development.\n     * @param {Point}\n     * @param  {Point} [out=undefined]    - optional point to receive result\n     * @returns {Point}\n     */\n    viewPointToContainerPoint(viewPoint: Point, out?: Point): Point;\n    /**\n     * Checks if the map container size changed and updates the map if so.\n     * @return {Map} this\n     * @fires Map#resize\n     */\n    checkSize(force?: boolean): this;\n    /**\n     * Computes the coordinate from the given meter distance.\n     * @param  {Coordinate} coordinate - source coordinate\n     * @param  {Number} dx           - meter distance on X axis\n     * @param  {Number} dy           - meter distance on Y axis\n     * @return {Coordinate} Result coordinate\n     */\n    locate(coordinate: Coordinate, dx: number, dy: number): Coordinate;\n    /**\n     * Return map's main panel\n     * @returns {HTMLElement}\n     */\n    getMainPanel(): HTMLDivElement | null;\n    /**\n     * Returns map panels.\n     * @return {Object}\n     */\n    getPanels(): Record<string, PanelDom>;\n    /**\n     * Remove the map\n     * @return {Map} this\n     */\n    remove(): this;\n    /**\n     * whether the map is removed\n     * @return {Boolean}\n     */\n    isRemoved(): boolean;\n    /**\n     * Whether the map is moving\n     * @return {Boolean}\n     */\n    isMoving(): boolean;\n    /**\n     * The callback function when move started\n     * @private\n     * @fires Map#movestart\n     */\n    onMoveStart(param?: any): void;\n    onMoving(param: any): void;\n    onMoveEnd(param: any): void;\n    onDragRotateStart(param: any): void;\n    onDragRotating(param: any): void;\n    onDragRotateEnd(param: any): void;\n    isDragRotating(): boolean;\n    /**\n     * Test if given box is out of current screen\n     * @param {Number[] | PointExtent} box - [minx, miny, maxx, maxy]\n     * @param {Number} padding - test padding\n     * @returns {Boolean}\n     */\n    isOffscreen(box: PointExtent | Array<number>, viewportPadding?: number): boolean;\n    getRenderer(): any;\n    /**\n     * Get map's devicePixelRatio, you can override it by setting devicePixelRatio in options.\n     * @returns {Number}\n     */\n    getDevicePixelRatio(): number;\n    /**\n     * Set map's devicePixelRatio\n     * @param {Number} dpr\n     * @returns {Map} this\n     */\n    setDevicePixelRatio(dpr: number): this;\n    _initContainer(container: MapContainerType): void;\n    /**\n     * try to change cursor when map is not setCursored\n     * @private\n     * @param  {String} cursor css cursor\n     */\n    _trySetCursor(cursor: string): this;\n    _setPriorityCursor(cursor: string): this;\n    _setCursorToPanel(cursor: string): void;\n    _removeLayer(layer: Layer, layerList: Array<Layer>): void;\n    _sortLayersByZIndex(): void;\n    _fireEvent(eventName: string, param?: {\n        [key: string]: any;\n    }): void;\n    _Load(): void;\n    _initRenderer(): void;\n    _getRenderer(): any;\n    _loadAllLayers(): void;\n    /**\n     * Gets layers that fits for the filter\n     * @param  {fn} filter - filter function\n     * @return {Layer[]}\n     * @private\n     */\n    _getLayers(filter?: (layer: Layer) => boolean): any[];\n    _eachLayer(fn: any, ...layerLists: any[]): void;\n    _onLayerEvent(param: any): void;\n    _resetMapStatus(): void;\n    setContainerDomRect(domRect: DOMRect): void;\n    _getContainerDomSize(): Size | null;\n    _updateMapSize(mSize: Size): this;\n    /**\n     * Gets projected center of the map\n     * @return {Coordinate}\n     * @private\n     */\n    _getPrjCenter(): Coordinate;\n    _setPrjCenter(pcenter: Coordinate): void;\n    _setPrjCoordAtContainerPoint(coordinate: Coordinate, point: Point): this;\n    _setPrjCoordAtOffsetToCenter(prjCoord: Coordinate, offset: Point): this;\n    _verifyExtent(prjCenter: Coordinate): boolean;\n    /**\n     * Move map's center by pixels.\n     * @param  {Point} pixel - pixels to move, the relation between value and direction is as:\n     * -1,1 | 1,1\n     * ------------\n     *-1,-1 | 1,-1\n     * @private\n     * @returns {Coordinate} the new projected center.\n     */\n    _offsetCenterByPixel(pixel: Point): void;\n    /**\n     * offset map panels.\n     *\n     * @param  {Point} offset - offset in pixel to move\n     * @return {Map} this\n     */\n    /**\n     * Gets map panel's current view point.\n     * @return {Point}\n     */\n    offsetPlatform(offset?: Point): Point;\n    /**\n     * Get map's view point, adding in frame offset\n     * @return {Point} map view point\n     */\n    getViewPoint(): Point;\n    _resetMapViewPoint(): void;\n    /**\n     * Get map's current resolution\n     * @return {Number} resolution\n     * @private\n     */\n    _getResolution(zoom?: number): number;\n    _getResolutions(): number[];\n    /**\n     * Converts the projected coordinate to a 2D point in the specific zoom\n     * @param  {Coordinate} pCoord - projected Coordinate\n     * @param  {Number} zoom   - point's zoom level\n     * @return {Point} 2D point\n     * @private\n     */\n    _prjToPoint(pCoord: any, zoom?: number, out?: Point): Point;\n    _prjToPointAtRes(pCoord: Coordinate, res?: number, out?: Point): Point;\n    /**\n     * Converts the projected coordinate to a 2D point in the specific resolution\n     * @param  {Coordinate} pCoord - projected Coordinate\n     * @param  {Number} res   - point's resolution\n     * @return {Point} 2D point\n     * @private\n     */\n    _prjsToPointsAtRes(pCoords: Array<Coordinate>, res?: number, resultPoints?: any[]): Array<Point>;\n    /**\n     * Converts the 2D point to projected coordinate\n     * @param  {Point} point - 2D point\n     * @param  {Number} zoom   - point's zoom level\n     * @return {Coordinate} projected coordinate\n     * @private\n     */\n    _pointToPrj(point: Point, zoom?: number, out?: Coordinate): Coordinate;\n    _pointToPrjAtRes(point: Point, res?: number, out?: Coordinate): Coordinate;\n    /**\n     * Convert point at zoom to point at current zoom\n     * @param  {Point} point point\n     * @param  {Number} zoom point's zoom\n     * @return {Point} point at current zoom\n     * @private\n     */\n    _pointToPoint(point: Point, zoom?: number, out?: Point): Point;\n    _pointAtResToPoint(point: Point, res?: number, out?: Point): Point;\n    /**\n     * Convert point at current zoom to point at target res\n     * @param  {Point} point point\n     * @param  {Number} res target res\n     * @return {Point} point at target res\n     * @private\n     */\n    _pointToPointAtRes(point: Point, res?: number, out?: Point): Point;\n    /**\n     * transform container point to geographical projected coordinate\n     *\n     * @param  {Point} containerPoint\n     * @return {Coordinate}\n     * @private\n     */\n    _containerPointToPrj(containerPoint: Point, out?: Coordinate): Coordinate;\n    _callOnLoadHooks(): void;\n    _fixPrjOnWorldWide(prjCoord: Coordinate): this;\n    /**\n     * Export the map's json, a snapshot of the map in JSON format.<br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Map#fromJSON} method\n     * @param  {Object} [options=null] - export options\n     * @param  {Boolean|Object} [options.baseLayer=null] - whether to export base layer's JSON, if yes, it will be used as layer's toJSON options.\n     * @param  {Boolean|Extent} [options.clipExtent=null] - if set with an extent instance, only the geometries intersectes with the extent will be exported.\n     *                                                             If set to true, map's current extent will be used.\n     * @param  {Boolean|Object|Object[]} [options.layers=null] - whether to export other layers' JSON, if yes, it will be used as layer's toJSON options.\n     *                                                        It can also be an array of layer export options with a \"id\" attribute to filter the layers to export.\n     * @return {Object} layer's JSON\n     */\n    toJSON(options?: MapOptionsType): {\n        [key: string]: any;\n    };\n    /**\n     * Reproduce a map from map's profile JSON.\n     * @param {(string|HTMLElement|object)} container - The container to create the map on, can be:<br>\n     *                                          1. A HTMLElement container.<br/>\n     *                                          2. ID of a HTMLElement container.<br/>\n     *                                          3. A canvas compatible container in node,\n     *                                          e.g. [node-canvas]{@link https://github.com/Automattic/node-canvas},\n     *                                              [canvas2svg]{@link https://github.com/gliffy/canvas2svg}\n     * @param  {Object} mapJSON - map's profile JSON\n     * @param  {Object} [options=null] - options\n     * @param  {Object} [options.baseLayer=null] - whether to import the baseLayer\n     * @param  {Object} [options.layers=null]    - whether to import the layers\n     * @return {Map}\n     * @static\n     * @function\n     * @example\n     * var map = Map.fromJSON('map', mapProfile);\n     */\n    static fromJSON(container: MapContainerType, profile: {\n        [key: string]: any;\n    }, options?: MapOptionsType): Map;\n}\nexport default Map;\nexport type MapOptionsType = {\n    baseLayer?: Layer;\n    layers?: Array<Layer>;\n    draggable?: boolean;\n    dragPan?: boolean;\n    dragRotate?: boolean;\n    dragPitch?: boolean;\n    dragRotatePitch?: boolean;\n    touchGesture?: boolean;\n    touchZoom?: boolean;\n    touchRotate?: boolean;\n    touchPitch?: boolean;\n    touchZoomRotate?: boolean;\n    doubleClickZoom?: boolean;\n    scrollWheelZoom?: boolean;\n    geometryEvents?: boolean;\n    control?: boolean;\n    attribution?: boolean;\n    zoomControl?: boolean;\n    scaleControl?: boolean;\n    overviewControl?: boolean;\n    fog?: boolean;\n    fogColor?: any;\n    devicePixelRatio?: number;\n    heightFactor?: number;\n    cameraInfiniteFar?: boolean;\n    originLatitudeForAltitude?: number;\n    viewHistory?: boolean;\n    viewHistoryCount?: number;\n    seamlessZoom?: boolean;\n    maxVisualPitch?: number;\n    maxPitch?: number;\n    centerCross?: boolean;\n    zoomInCenter?: boolean;\n    zoomOrigin?: Array<number>;\n    zoomAnimation?: boolean;\n    zoomAnimationDuration?: number;\n    panAnimation?: boolean;\n    panAnimationDuration?: number;\n    rotateAnimation?: boolean;\n    rotateAnimationDuration?: number;\n    zoomable?: boolean;\n    enableInfoWindow?: boolean;\n    hitDetect?: boolean;\n    hitDetectLimit?: number;\n    fpsOnInteracting?: number;\n    layerCanvasLimitOnInteracting?: number;\n    maxZoom?: number;\n    minZoom?: number;\n    maxExtent?: Extent;\n    fixCenterOnResize?: boolean;\n    checkSize?: boolean;\n    checkSizeInterval?: number;\n    renderer?: 'canvas' | 'gl';\n    cascadePitches?: Array<number>;\n    renderable?: boolean;\n    clickTimeThreshold?: number;\n    stopRenderOnOffscreen?: boolean;\n    preventWheelScroll?: boolean;\n    preventTouch?: boolean;\n    supportPluginEvent?: boolean;\n    switchDragButton?: boolean;\n    mousemoveThrottleTime?: number;\n    maxFPS?: number;\n    debug?: boolean;\n    spatialReference?: SpatialReferenceType;\n    autoPanAtEdge?: boolean;\n    boxZoom?: boolean;\n    boxZoomSymbol?: {\n        'markerType': string;\n        'markerLineWidth': number;\n        'markerLineColor': string;\n        'markerLineDasharray': Array<number>;\n        'markerFillOpacity': number;\n        'markerFill': string;\n        'markerWidth': number;\n        'markerHeight': number;\n    };\n    onlyVisibleGeometryEvents?: boolean;\n    compassControl?: boolean;\n    layerSwitcherControl?: boolean;\n    navControl?: boolean;\n    resetControl?: boolean;\n};\nexport type MapCreateOptionsType = {\n    center: Array<number> | Coordinate;\n    zoom: number;\n} & MapOptionsType;\nexport type MapPaddingType = {\n    paddingLeft: number;\n    paddingRight: number;\n    paddingTop: number;\n    paddingBottom: number;\n};\nexport type MapViewType = {\n    center?: Array<number> | Coordinate;\n    zoom?: number;\n    pitch?: number;\n    bearing?: number;\n    height?: number;\n};\nexport type MapFitType = {\n    isFraction?: boolean;\n    animation?: boolean;\n    duration?: number;\n    easing?: EasingType;\n} & MapPaddingType;\nexport type MapDataURLType = {\n    mimeType?: string;\n    fileName?: string;\n    quality?: number;\n    save?: boolean;\n};\nexport type MapAnimationOptionsType = AnimationOptionsType;\nexport type MapIdentifyOptionsType = {\n    tolerance?: number;\n    eventTypes?: Array<string>;\n    layers?: Array<Layer>;\n    count?: number;\n    includeInvisible?: boolean;\n    includeInternals?: boolean;\n};\nexport type MapContainerType = string | HTMLDivElement | HTMLCanvasElement | {\n    [key: string]: any;\n};\nexport type PanelDom = (HTMLDivElement | HTMLElement) & {\n    layerDOM: HTMLElement;\n    uiDOM: HTMLElement;\n};\n"},{"path":"map/Map.DomEvents.d.ts","content":"import { Coordinate, Point } from '../geo';\ndeclare module \"./Map\" {\n    interface Map {\n        _removeDomEvents(): void;\n        _ignoreEvent(domEvent: MapEventDomType): boolean;\n        _isEventOutMap(domEvent: MapEventDomType): boolean;\n        _parseEvent(e: MapEventDomType, type?: string): MapEventDataType;\n        _parseEventFromCoord(coord: Coordinate): MapEventDataType;\n        _fireDOMEvent(target: any, e: MapEventDomType, type: string): any;\n        _getEventParams(e: MapEventDomType): MapEventDataType;\n    }\n}\nexport type MapEventDomType = MouseEvent | TouchEvent | DragEvent;\nexport type MapEventDataType = {\n    coordinate?: Coordinate;\n    containerPoint?: Point;\n    viewPoint?: Point;\n    point2d?: Point;\n    domEvent?: MouseEvent | DragEvent | TouchEvent;\n    terrain?: {\n        coordinate: Coordinate;\n        altitude: number;\n    } | null;\n};\n"},{"path":"map/Map.FullScreen.d.ts","content":"declare module \"./Map\" {\n    interface Map {\n        isFullScreen(): boolean;\n        requestFullScreen(dom?: HTMLDivElement): this;\n        cancelFullScreen(): this;\n        _requestFullScreen(dom: HTMLDivElement): void;\n        _cancelFullScreen(): void;\n    }\n}\nexport {};\n"},{"path":"map/Map.Pan.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\ndeclare module \"./Map\" {\n    interface Map {\n        panTo(coordinate: Coordinate, options?: MapAnimationOptionsType, step?: (frame: any) => void): this;\n        _panTo(prjCoord: Coordinate, options?: MapAnimationOptionsType): this;\n        panBy(offset: Point | Array<number>, options?: MapAnimationOptionsType, step?: (frame: any) => void): this;\n        _panAnimation(target: Coordinate, t?: number, cb?: (frame: any) => void): void;\n    }\n}\n"},{"path":"map/Map.Profile.d.ts","content":"/** Profile **/\n/**\n * Produce a geometry from one or more [JSON]{@link Geometry#toJSON} or GeoJSON.\n * @param  {Object} json - a geometry's JSON or a geojson\n * @return {Geometry} geometry\n * @example\n * var profile = {\n        \"feature\": {\n              \"type\": \"Feature\",\n              \"id\" : \"point1\",\n              \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.0, 0.5]},\n              \"properties\": {\"prop0\": \"value0\"}\n        },\n        //construct options.\n        \"options\":{\n            \"draggable\" : true\n        },\n        //symbol\n        \"symbol\":{\n            \"markerFile\"  : \"http://foo.com/icon.png\",\n            \"markerWidth\" : 20,\n            \"markerHeight\": 20\n        }\n    };\n    const marker = Geometry.fromJSON(profile);\n */\n"},{"path":"map/Map.Topo.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport { type Geometry } from '../geometry';\nimport { MapIdentifyOptionsType } from './Map';\ntype identifyOptionsType = MapIdentifyOptionsType & {\n    coordinate: Coordinate;\n};\ntype identifyAtPointOptionsType = MapIdentifyOptionsType & {\n    containerPoint: Point;\n};\ntype MapIdentifyCBType = (geos: Array<Geometry>) => void;\ndeclare module \"./Map\" {\n    interface Map {\n        computeLength(coord1: Coordinate, coord2: Coordinate): number;\n        computeGeometryLength(geometry: Geometry): number;\n        computeGeometryArea(geometry: Geometry): number;\n        identify(opts: identifyOptionsType, cb: MapIdentifyCBType): void;\n        identifyAtPoint(opts: identifyAtPointOptionsType, cb: MapIdentifyCBType): void;\n    }\n}\nexport {};\n"},{"path":"map/Map.ViewHistory.d.ts","content":"declare module \"./Map\" {\n    interface Map {\n        zoomToPreviousView(options?: any): MapViewType;\n        hasPreviousView(): boolean;\n        zoomToNextView(options?: any): MapViewType;\n        hasNextView(): boolean;\n        getViewHistory(): Array<MapViewType>;\n        _onViewChange(view: MapViewType): void;\n        _getCurrentView(): MapViewType;\n    }\n}\nexport {};\n"},{"path":"map/Map.Zoom.d.ts","content":"import Point from '../geo/Point';\ndeclare module \"./Map\" {\n    interface Map {\n        _zoom(nextZoom: number, origin?: Point): any;\n        _zoomAnimation(nextZoom: number, origin?: Point, startScale?: number): any;\n        _checkZoomOrigin(origin?: Point): Point;\n        _startZoomAnim(nextZoom: number, origin?: Point, startScale?: number): any;\n        onZoomStart(nextZoom: number, origin?: Point): any;\n        onZooming(nextZoom: number, origin?: Point, startScale?: number): any;\n        onZoomEnd(nextZoom: number, origin?: Point): any;\n        _zoomTo(nextZoom: number, origin?: Point): any;\n        _checkZoom(nextZoom: number): number;\n    }\n}\n"},{"path":"map/spatial-reference/SpatialReference.Arc.d.ts","content":"import { type SpatialReferenceType } from './SpatialReference';\nexport type ArcgisConfig = {\n    tileInfo: {\n        cols: number;\n        rows: number;\n        origin: {\n            x: number;\n            y: number;\n        };\n        lods: Array<{\n            resolution: number;\n        }>;\n    };\n    fullExtent: SpatialReferenceType['fullExtent'];\n};\n/**\n * 加载Arcgis空间参考配置文件\n * @param url arcgis spatialreference json file url\n * @param cb\n * @param options\n * @returns\n */\ndeclare const loadArcgis: (url: string, cb: (_: any, spatialRef?: any) => void, options?: any) => void;\nexport default loadArcgis;\n"},{"path":"map/spatial-reference/SpatialReference.d.ts","content":"import Extent, { JsonExtent } from '../../geo/Extent';\nimport * as projections from '../../geo/projection';\nimport type { ProjectionType } from '../../geo/projection';\nimport Transformation from '../../geo/transformation/Transformation';\nexport type FullExtent = {\n    top: number;\n    left: number;\n    bottom: number;\n    right: number;\n};\nexport type SpatialReferenceType = {\n    projection: string | ProjectionType;\n    resolutions?: number[];\n    fullExtent?: FullExtent | JsonExtent;\n};\n/**\n * 空间参考类\n *\n * @english\n * SpatialReference Class\n */\nexport default class SpatialReference {\n    options: SpatialReferenceType;\n    _projection: ProjectionType;\n    isEPSG: boolean;\n    _resolutions: number[];\n    _pyramid: boolean;\n    _fullExtent: Extent;\n    _transformation: Transformation;\n    json: SpatialReferenceType;\n    constructor(options?: SpatialReferenceType);\n    static registerPreset(name: string, value: SpatialReferenceType): void;\n    static getPreset(preset: string): SpatialReferenceType;\n    static getAllPresets(): string[];\n    static loadArcgis(url: string, cb: (_: any, spatialRef?: any) => void, options: any): typeof SpatialReference;\n    static loadWMTS(url: string, cb: (_: any, spatialRef?: any) => void, options: any): typeof SpatialReference;\n    /**\n     * 获取投影类实例对象\n     *\n     * @english\n     * get Projection Class instance\n     * @param projection\n     * @returns\n     */\n    static getProjectionInstance(projection?: string | ProjectionType): any;\n    static equals(sp1: SpatialReferenceType, sp2: SpatialReferenceType): boolean;\n    _initSpatialRef(): void;\n    getResolutions(): number[];\n    getResolution(zoom: number): number;\n    getProjection(): projections.ProjectionType;\n    getFullExtent(): Extent;\n    getTransformation(): Transformation;\n    getMinZoom(): number;\n    getMaxZoom(): number;\n    getZoomDirection(): number;\n    toJSON(): SpatialReferenceType;\n    isPyramid(): boolean;\n}\n"},{"path":"map/spatial-reference/SpatialReference.WMTS.d.ts","content":"export declare const loadWMTS: (url: string, cb: (_: any, layers?: any) => void, options?: {\n    jsonp: boolean;\n}) => void;\nexport default loadWMTS;\n"},{"path":"map/tool/AreaTool.d.ts","content":"import { Geometry } from '../../geometry';\nimport DistanceTool from './DistanceTool';\nexport type AreaToolOptions = {\n    language?: string;\n    metric?: boolean;\n    imperial?: boolean;\n    symbol?: any;\n    vertexSymbol?: any;\n    labelOptions?: any;\n    mode?: string;\n};\n/**\n * 一个继承于DistanceTool类，测量面积的地图工具类。\n *\n * @english\n * A map tool to help measure area on the map .it is extends DistanceTool\n * @category maptool\n * @extends DistanceTool\n * @example\n * var areaTool = new AreaTool({\n *     'once' : true,\n *     'symbol': {\n *       'lineColor' : '#34495e',\n *       'lineWidth' : 2\n *     },\n *     'vertexSymbol' : {\n *       'markerType'        : 'ellipse',\n *       'markerFill'        : '#1bbc9b',\n *       'markerLineColor'   : '#000',\n *       'markerLineWidth'   : 3,\n *       'markerWidth'       : 10,\n *      'markerHeight'      : 10\n *    },\n *    'language' : 'en-US'\n *  }).addTo(map);\n */\ndeclare class AreaTool extends DistanceTool {\n    /**\n     * 配置项\n     *\n     * @english\n     * @param options option              - construct options\n     * @param options.language=zh-CN      - language of the distance tool, zh-CN or en-US\n     * @param options.metric=true         - display result in metric system\n     * @param options.imperial=false      - display result in imperial system.\n     * @param options.symbol=null         - symbol of the line\n     * @param options.vertexSymbol=null   - symbol of the vertice\n     * @param options.labelOptions=null   - construct options of the vertice labels.\n     */\n    constructor(options: AreaToolOptions);\n    _measure(toMeasure: Geometry | Array<any>): string;\n    _msGetCoordsToMeasure(param: any): any;\n    _msOnDrawVertex(param: any): void;\n    _msOnDrawEnd(param: any): void;\n}\nexport default AreaTool;\n"},{"path":"map/tool/DistanceTool.d.ts","content":"import Marker from '../../geometry/Marker';\nimport Translator from '../../lang/translator';\nimport DrawTool from './DrawTool';\nimport Coordinate from '../../geo/Coordinate';\nexport type DistanceToolOptions = {\n    mode?: string;\n    language?: string;\n    metric?: boolean;\n    imperial?: boolean;\n    symbol?: any;\n    vertexSymbol?: any;\n    labelOptions?: any;\n    decimalPlaces?: number;\n    formatLabelContent?: any;\n    clearButtonSymbol?: any;\n    zIndex?: number;\n};\n/**\n * 距离测量工具类\n *\n * @english\n * A map tool to help measure distance on the map\n * @category maptool\n * @extends DrawTool\n * @example\n * var distanceTool = new DistanceTool({\n *     'once' : true,\n *     'symbol': {\n *       'lineColor' : '#34495e',\n *       'lineWidth' : 2\n *     },\n *     'vertexSymbol' : {\n *       'markerType'        : 'ellipse',\n *       'markerFill'        : '#1bbc9b',\n *       'markerLineColor'   : '#000',\n *       'markerLineWidth'   : 3,\n *       'markerWidth'       : 10,\n *      'markerHeight'      : 10\n *    },\n *    'language' : 'en-US'\n *  }).addTo(map);\n *\n */\ndeclare class DistanceTool extends DrawTool {\n    _measureLayers: Array<any>;\n    translator: Translator;\n    _tailMarker?: any;\n    _tailLabel?: any;\n    _lastMeasure?: number | string;\n    _lastVertex?: any;\n    _measureMarkerLayer?: any;\n    _measureLineLayer?: any;\n    /**\n     * 配置项\n     *\n     * @param options=null                  - construct options\n     * @param options.language=zh-CN        - language of the distance tool, zh-CN or en-US\n     * @param options.metric=true           - display result in metric system\n     * @param options.imperial=false        - display result in imperial system.\n     * @param options.symbol=null           - symbol of the line\n     * @param options.vertexSymbol=null     - symbol of the vertice\n     * @param options.labelOptions=null     - construct options of the vertice labels.\n     */\n    constructor(options: DistanceToolOptions);\n    /**\n     * 清空测量\n     *\n     * @english\n     * Clear the measurements\n     * @return {DistanceTool} this\n     */\n    clear(): this;\n    /**\n     * 获取在绘制图形期间的VectorLayers\n     *\n     * @english\n     * Get the VectorLayers with the geometries drawn on the map during measuring.\n     * @return {Array<Layer>}\n     */\n    getMeasureLayers(): any[];\n    /**\n     * 获取最后测量结果\n     *\n     * @english\n     * Get last measuring result\n     * @return {Number}\n     */\n    getLastMeasure(): string | number;\n    /**\n     * 撤消绘图，仅适用于点击/删除模式\n     *\n     * @english\n     * Undo drawing, only applicable for click/dblclick mode\n     * @return {DistanceTool} this\n     */\n    undo(): this;\n    /**\n     * 重做绘图，只适用于click/dblclick模式\n     *\n     * @english\n     * Redo drawing, only applicable for click/dblclick mode\n     * @return {DistanceTool} this\n     */\n    redo(): this;\n    _formatLabelContent(params: any): string;\n    _measure(toMeasure: any): string;\n    _registerMeasureEvents(): void;\n    _afterEnable(): void;\n    _afterDisable(): void;\n    _msOnDrawStart(param: any): void;\n    _msOnMouseMove(param: any): void;\n    _msGetCoordsToMeasure(param: any): any;\n    _msOnDrawVertex(param: any): void;\n    _addVertexMarker(marker: Marker, vertexLabel?: any): void;\n    _msOnDrawEnd(param: any): void;\n    _addClearMarker(coordinates: Coordinate, prjCoord: any, dx: number | string): void;\n    _clearTailMarker(): void;\n    _clearMeasureLayers(): void;\n    _getFirstCoordinate(): any;\n    _getLasttCoordinate(): any;\n}\nexport default DistanceTool;\n"},{"path":"map/tool/DrawTool.d.ts","content":"import Point from '../../geo/Point';\nimport Geometry from '../../geometry/Geometry';\nimport MapTool from './MapTool';\nexport type DrawToolOptions = {\n    mode?: string;\n    symbol?: any;\n    once?: boolean;\n    autoPanAtEdge?: boolean;\n    blockGeometryEvents?: boolean;\n    zIndex?: number;\n    doubleClickZoom?: boolean;\n    ignoreMouseleave?: boolean;\n    enableAltitude?: boolean;\n};\nexport type modeActionType = {\n    action?: string | Array<string>;\n    create?: any;\n    update?: any;\n    generate?: any;\n    clickLimit?: number | string;\n};\n/**\n * 图形绘制工具类\n *\n * @english\n * A map tool to help draw geometries.\n * @category maptool\n * @extends MapTool\n * @example\n * var drawTool = new DrawTool({\n *     mode : 'Polygon',\n *     symbol : {\n *         'lineColor' : '#000',\n *         'lineWidth' : 5\n *     },\n *     once : true\n * }).addTo(map);\n */\ndeclare class DrawTool extends MapTool {\n    _vertexes: Array<any>;\n    _historyPointer: any;\n    _events: any;\n    _geometry?: any;\n    _drawToolLayer?: any;\n    _mapAutoPanAtEdge?: boolean;\n    _geometryEvents?: boolean;\n    _mapDoubleClickZoom?: boolean;\n    _ending: boolean;\n    _mapDraggable?: boolean;\n    _clickCoords?: Array<any>;\n    _layers?: Array<any>;\n    /**\n     * 为DrawTool注册一个新mode\n     *\n     * @english\n     * Register a new mode for DrawTool\n     * @param name                  mode name\n     * @param modeAction            modeActions\n     * @param modeAction.action     the action of DrawTool: click, mousedown, clickDblclick\n     * @param modeAction.create     the create method of drawn geometry\n     * @param modeAction.update     the update method of drawn geometry\n     * @param modeAction.generate   the method to generate geometry at the end of drawing.\n     * @example\n     * //Register \"CubicBezierCurve\" mode to draw Cubic Bezier Curves.\n     * DrawTool.registerMode('CubicBezierCurve', {\n        'action': 'clickDblclick',\n        'create': path => new CubicBezierCurve(path),\n        'update': (path, geometry) => {\n            geometry.setCoordinates(path);\n        },\n        'generate': geometry => geometry\n       }\n     });\n     */\n    static registerMode(name: string, modeAction: modeActionType): void;\n    /**\n     * 根据name获取mode actions\n     *\n     * @english\n     * Get mode actions by mode name\n     * @param name      DrawTool mode name\n     * @return          mode actions\n     */\n    static getRegisterMode(name: string): any;\n    /**\n     * 实例化DrawTool工具\n     *\n     * @english\n     * In default, DrawTool supports the following modes: <br>\n     * [Point, LineString, Polygon, Circle, Ellipse, Rectangle, ArcCurve, QuadBezierCurve, CubicBezierCurve] <br>\n     * You can easily add new mode to DrawTool by calling [registerMode]{@link DrawTool.registerMode}\n     * @param options=null                  - construct options\n     * @param options.mode=null             - mode of the draw tool\n     * @param options.symbol=null           - symbol of the geometries drawn\n     * @param options.once=null             - whether disable immediately once drawn a geometry.\n     * @param options.autoPanAtEdge=false   - Whether to make edge judgement or not.\n     */\n    constructor(options: DrawToolOptions);\n    /**\n     * 获取当前mode\n     *\n     * @english\n     * Get current mode of draw tool\n     * @return mode\n     */\n    getMode(): string;\n    /**\n     * 设置mode\n     *\n     * @english\n     * Set mode of the draw tool\n     * @param mode - mode of the draw tool\n     * @returns {DrawTool} this\n     * @expose\n     */\n    setMode(mode: string): DrawTool;\n    /**\n     * 获取DrawTool的symbol属性\n     *\n     * @english\n     * Get symbol of the draw tool\n     * @return symbol\n     */\n    getSymbol(): any;\n    /**\n     * 设置DrawTool的symbol属性\n     *\n     * @english\n     * Set draw tool's symbol\n     * @param symbol - symbol set\n     * @returns {DrawTool} this\n     */\n    setSymbol(symbol: any): DrawTool;\n    /**\n     * 获取当前绘制图形\n     *\n     * @english\n     * Get geometry is currently drawing\n     * @return geometry currently drawing\n     */\n    getCurrentGeometry(): Geometry;\n    onAdd(): void;\n    onEnable(): this;\n    onDisable(): this;\n    /**\n     * 撤消绘图，仅适用于点击/删除模式\n     *\n     * @english\n     * Undo drawing, only applicable for click/dblclick mode\n     * @return this\n     */\n    undo(): DrawTool;\n    /**\n     * 重做绘图，只适用于click/dblclick模式\n     *\n     * @english\n     * Redo drawing, only applicable for click/dblclick mode\n     * @return this\n     */\n    redo(): DrawTool;\n    /**\n     * 检查历史记录\n     *\n     * @english\n     * check should recor history\n     * @param actions\n     * @returns {boolean}\n     * @private\n     */\n    _shouldRecordHistory(actions: any): boolean;\n    _checkMode(): void;\n    _saveMapCfg(): void;\n    _restoreMapCfg(): void;\n    _loadResources(): void;\n    _getProjection(): import(\"src/geo/projection\").ProjectionType;\n    _getRegisterMode(): any;\n    getEvents(): {};\n    /**\n     * 鼠标按下开始绘画\n     *\n     * @english\n     * mouse down start draw\n     * @param event\n     * @private\n     */\n    _mouseDownHandler(event: any): void;\n    /**\n     * 监听 mouse up 事件\n     *\n     * @english\n     * handle mouse up event\n     * @param event\n     * @private\n     */\n    _mouseUpHandler(event: any): void;\n    /**\n     * 监听mouse first click点击事件\n     *\n     * @english\n     * handle mouse first click handle\n     * @param event\n     * @private\n     */\n    _clickHandler(event: any): void;\n    /**\n     * 第一次事件创建相关geometry\n     *\n     * @param event\n     * @private\n     */\n    _createGeometry(event: any): void;\n    /**\n     * 监听鼠标移动\n     *\n     * @english\n     * handle mouse move event\n     * @param event\n     * @private\n     */\n    _mouseMoveHandler(event: any): void;\n    /**\n     * 监听double click事件\n     *\n     * @english\n     * handle mouse double click event\n     * @param event\n     * @private\n     */\n    _doubleClickHandler(event: any): void;\n    _addGeometryToStage(geometry: any): void;\n    /**\n     * 结束当前绘制\n     *\n     * @english\n     * End current draw\n     * @param [param=null] params of drawend event\n     * @returns this\n     */\n    endDraw(param: any): DrawTool;\n    _clearStage(): void;\n    /**\n     * 获取鼠标事件 ontainer point 信息\n     *\n     * @english\n     * Get container point of the mouse event\n     * @param event -  mouse event\n     * @return\n     * @private\n     */\n    _getMouseContainerPoint(event: Event): Point;\n    _isValidContainerPoint(containerPoint: any): boolean;\n    _getSnapResult(snapTo: any, containerPoint: any): {\n        prjCoord: any;\n        effectedVertex: any;\n    };\n    _getDrawLayer(): any;\n    _fireEvent(eventName: any, param: any): void;\n    _pushLayers(layers: any): this;\n    _outLayers(layers: any): this;\n    /**\n    * 设置Layer的zIndex\n    * @english\n    * set draw inner layers zIndex\n    * @param  {Number} zIndex -  draw layer zIndex\n    * @return this\n    */\n    setLayerZIndex(zIndex: any): DrawTool;\n}\nexport default DrawTool;\n"},{"path":"map/tool/DrawToolRegister.d.ts","content":"export {};\n"},{"path":"map/tool/index.d.ts","content":"import MapTool from './MapTool';\nimport DrawTool from './DrawTool';\nimport DistanceTool from './DistanceTool';\nimport AreaTool from './AreaTool';\nimport './DrawToolRegister';\nexport { MapTool, DrawTool, DistanceTool, AreaTool };\n"},{"path":"map/tool/MapTool.d.ts","content":"import Class from '../../core/Class';\nimport type Map from '../Map';\ndeclare const MapTool_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Class;\n/**\n * @classdesc\n * <pre>\n * The parent class for all the map tools.\n * It is abstract and not intended to be instantiated.\n * Some interface methods to implement:\n * 1. onAdd: optional, a callback method to do some prepares before enabled when the map tool is added to a map\n * 2. onEnable: optional, called when the map tool is enabled, used to setup the context such as adding more event listeners other than the map, disabling map's default handlers (draggable, scrollWheelZoom, etc) and creating temporary layers.\n * 3. getEvents: required, provide an event map to register event listeners on the map.\n * 4. onDisable: optional, called when the map tool is disabled, used to cleanup such as unregistering event listeners, enable map's original handlers and remove temporary layers.\n * </pre>\n * @abstract\n * @category maptool\n * @extends Class\n * @mixes Eventable\n */\ndeclare class MapTool extends MapTool_base {\n    _map: Map;\n    _enabled?: boolean;\n    onEnable?(): void;\n    getEvents?(): void;\n    onDisable?(): void;\n    onAdd?(): void;\n    /**\n     * Adds the map tool to a map.\n     * @param {Map} map\n     * @return {MapTool} this\n     * @fires MapTool#add\n     */\n    addTo(map: Map): this;\n    /**\n     * Gets the map it added to.\n     * @return {Map} map\n     */\n    getMap(): Map;\n    /**\n     * Enable the map tool.\n     * @return {MapTool} this\n     * @fires MapTool#enable\n     */\n    enable(): this;\n    /**\n     * Disable the map tool\n     * @return {MapTool} this\n     * @fires MapTool#disable\n     */\n    disable(): this;\n    /**\n     * Returns whether the tool is enabled\n     * @return {Boolean} true | false\n     */\n    isEnabled(): boolean;\n    remove(): this;\n    _registerEvents(): void;\n    _switchEvents(to: any): void;\n    _fireEvent(eventName: string, param?: any): void;\n}\nexport default MapTool;\n"},{"path":"maptalks.d.ts","content":"export { default as GlobalConfig } from './GlobalConfig';\nexport * from './core/ResourceProxy';\nexport * from './core/Constants';\nexport { default as Browser } from './core/Browser';\ndeclare const Util: any;\nimport * as DomUtil from './core/util/dom';\nimport * as StringUtil from './core/util/strings';\nimport * as MapboxUtil from './core/mapbox';\nimport * as MicroTask from './core/MicroTask';\nexport { Util, DomUtil, StringUtil, MapboxUtil, MicroTask };\nexport { default as LRUCache } from './core/util/LRUCache';\nexport { default as Ajax } from './core/Ajax';\nexport { default as Canvas } from './core/Canvas';\nexport { default as Class } from './core/Class';\nexport { default as Eventable } from './core/Eventable';\nexport { GlobalEvent } from './core/GlobalEvent';\nexport { default as JSONAble } from './core/JSONAble';\nexport { default as CollisionIndex } from './core/CollisionIndex';\nexport { default as Handlerable } from './handler/Handlerable';\nexport { default as Handler } from './handler/Handler';\nexport { default as DragHandler } from './handler/Drag';\nexport { default as Coordinate } from './geo/Coordinate';\nexport { default as CRS } from './geo/CRS';\nexport { default as Extent } from './geo/Extent';\nexport { default as Point } from './geo/Point';\nexport { default as PointExtent } from './geo/PointExtent';\nexport { default as Size } from './geo/Size';\nexport { default as Transformation } from './geo/transformation/Transformation';\nimport { Map } from './map';\nexport { Map };\nexport { MapTool, DrawTool, AreaTool, DistanceTool } from './map/tool';\nexport { default as SpatialReference } from './map/spatial-reference/SpatialReference';\n/** @namespace ui */\nimport * as ui from './ui';\n/** @namespace control */\nimport * as control from './control';\nexport { ui, control };\nexport * from './layer';\nexport * from './geometry';\nimport './geometry/editor/GeometryEditor';\nimport './geometry/editor/TextEditable';\nimport './geometry/ext/Geometry.Animation';\nimport './geometry/ext/Geometry.Drag';\nimport './geometry/ext/Geometry.Edit';\nimport './geometry/ext/Geometry.Events';\nimport './geometry/ext/Geometry.InfoWindow';\nimport './geometry/ext/Geometry.JSON';\n/**\n * @namespace renderer\n */\nimport * as renderer from './renderer';\nexport { renderer };\nimport './renderer/geometry';\nimport * as symbolizer from './renderer/geometry/symbolizers';\n/** @namespace animation */\nimport * as animation from './core/Animation';\nexport { symbolizer, animation };\nexport { animate } from './core/Animation';\nexport { registerWorkerAdapter } from './core/worker/Worker';\nimport Actor from './core/worker/Actor';\n/**\n * @namespace worker\n */\ndeclare const worker: {\n    Actor: typeof Actor;\n};\nexport { worker };\n"},{"path":"renderer/edit/EditHandle.d.ts","content":"import Point, { type PointJson } from '../../geo/Point';\nimport DragHandler from '../../handler/Drag';\nimport { BBOX } from '../../core/util/bbox';\nimport type Map from '../../map/Map';\nimport type GeometryEditor from '../../geometry/editor/GeometryEditor';\ntype EventParams = any;\nexport interface EditHandleOptions {\n    symbol: Record<string, any>;\n    events: string[];\n    cursor: string;\n    zIndex?: number;\n}\ndeclare const EditHandle_base: any;\nexport default class EditHandle extends EditHandle_base {\n    target: GeometryEditor;\n    map: Map;\n    w: number;\n    h: number;\n    opacity: number;\n    events: string[];\n    url: string;\n    bbox: BBOX;\n    _point: Point;\n    _img: any;\n    _dragger: DragHandler;\n    constructor(target: GeometryEditor, map: Map, options: EditHandleOptions);\n    getCursor(): any;\n    _fetchImage(): void;\n    setContainerPoint(cp: Point): void;\n    getContainerPoint(): Point;\n    offset(p: Point | PointJson): void;\n    render(ctx: any): boolean;\n    delete(): void;\n    hitTest(p: Point | PointJson): boolean;\n    addTo(map: Map): void;\n    onEvent(e: EventParams): void;\n    mousedown(e: EventParams): void;\n    onDragstart(e: EventParams): void;\n    onDragging(e: EventParams): void;\n    onDragend(e: EventParams): void;\n    needCollision(): boolean;\n    getRenderBBOX(dpr?: number): BBOX;\n    setZIndex(zIndex: number): void;\n}\nexport {};\n"},{"path":"renderer/edit/EditOutline.d.ts","content":"import type Map from '../../map/Map';\nimport type GeometryEditor from '../../geometry/editor/GeometryEditor';\nimport type { Point } from '../../geo';\nimport type { BBOX } from '../../core/util/bbox';\nexport interface EditOutlineOptions {\n    zIndex?: number;\n}\nexport default class EditOutline {\n    points: any;\n    xmin: number;\n    xmax: number;\n    ymin: number;\n    ymax: number;\n    map: Map;\n    target: GeometryEditor;\n    options: EditOutlineOptions;\n    constructor(target: GeometryEditor, map: Map, options?: EditOutlineOptions);\n    needCollision?(): boolean;\n    getRenderBBOX?(dpr?: number): BBOX;\n    setPoints(points: Point[]): void;\n    hitTest(): boolean;\n    render(ctx: CanvasRenderingContext2D): void;\n    addTo(map: Map): void;\n    delete(): void;\n}\n"},{"path":"renderer/geometry/CollectionPainter.d.ts","content":"import Class from '../../core/Class';\nimport { BBOX } from '../../core/util/bbox';\nimport Painter from './Painter';\nimport Extent from '../../geo/Extent';\nimport { ResourceCache } from '../layer/CanvasRenderer';\nimport { Geometries } from '../../geometry';\n/**\n * @classdesc\n * Painter for collection type geometries\n * @class\n * @private\n */\nexport default class CollectionPainter extends Class {\n    _drawTime: number;\n    bbox: BBOX;\n    geometry: Geometries;\n    isMask: boolean;\n    /**\n     * @param geometry - geometry to paint\n     * @param isMask\n     */\n    constructor(geometry: Geometries, isMask?: boolean);\n    _setDrawTime(time: number): this;\n    getRenderBBOX(): BBOX;\n    _eachPainter(fn: (p: Painter) => void): void;\n    getLayer(): import(\"src\").OverlayLayer;\n    paint(extent: Extent): void;\n    get2DExtent(resources?: ResourceCache, out?: Extent): Extent;\n    remove(): void;\n    setZIndex(index: number): void;\n    show(): void;\n    hide(): void;\n    repaint(): void;\n    refreshSymbol(): void;\n    hasPoint(): boolean;\n    getMinAltitude(): number;\n    getMaxAltitude(): number;\n}\n"},{"path":"renderer/geometry/index.d.ts","content":"import Painter from './Painter';\nimport CollectionPainter from './CollectionPainter';\nimport './PointRenderer';\nimport './VectorRenderer';\nexport { Painter, CollectionPainter };\n"},{"path":"renderer/geometry/Painter.d.ts","content":"import Class from '../../core/Class';\nimport Point from '../../geo/Point';\nimport PointExtent from '../../geo/PointExtent';\nimport { BBOX } from '../../core/util/bbox';\nimport Map from '../../map/Map';\nimport { DebugSymbolizer } from './symbolizers';\nimport Extent from '../../geo/Extent';\nimport { ResourceCache } from '../layer/CanvasRenderer';\nimport type { WithUndef } from '../../types/typings';\nimport { Geometries } from '../../geometry';\ndeclare const TEMP_BBOX: {\n    minx: number;\n    miny: number;\n    maxx: number;\n    maxy: number;\n};\n/**\n * @classdesc\n * Painter class for all geometry types except the collection types.\n * @class\n * @private\n */\ndeclare class Painter extends Class {\n    _drawTime: number;\n    _hasPoint: boolean;\n    _debugSymbolizer: DebugSymbolizer;\n    _renderPoints: Record<string, Point[][]>;\n    _hitPoint: WithUndef<Point>;\n    _sprite: any;\n    _paintParams: any;\n    _cachedParams: any;\n    _unsimpledParams: any;\n    _spriting: boolean;\n    _extent2D: Extent & {\n        _zoom: number;\n    };\n    _fixedExtent: PointExtent;\n    _altAtGL: any;\n    _propAlt: number | number[] | number[][];\n    _projCode: string;\n    _pitched: boolean;\n    _rotated: boolean;\n    _painted: boolean;\n    _containerBbox: typeof TEMP_BBOX;\n    bbox: BBOX;\n    geometry: Geometries;\n    symbolizers: any[];\n    containerOffset: Point;\n    minAltitude: number;\n    maxAltitude: number;\n    /**\n     *  @param geometry - geometry to paint\n     */\n    constructor(geometry: Geometries);\n    _setDrawTime(time: number): this;\n    getRenderBBOX(): BBOX;\n    getMap(): Map;\n    getLayer(): import(\"src\").OverlayLayer;\n    /**\n     * create symbolizers\n     */\n    _createSymbolizers(): any[];\n    hasPoint(): boolean;\n    /**\n     * for point symbolizers\n     * @return points to render\n     */\n    getRenderPoints(placement: string): Point[][];\n    /**\n     * for strokeAndFillSymbolizer\n     * @return resources to render vector\n     */\n    getPaintParams(dx: number, dy: number, ignoreAltitude: boolean, disableClip: boolean, ptkey?: string): any[];\n    _pointContainerPoints(points: any, dx: any, dy: any, ignoreAltitude: any, disableClip: any, pointPlacement: any, ptkey?: string): any;\n    _clip(points: Point[], altitude?: number): {\n        points: any;\n        altitude: any;\n    } | {\n        points: Point[];\n        altitude: number;\n        inView: boolean;\n    };\n    /**\n     * interpolate clipped line segs's altitude\n     * @param {Point[]|Point[][]} clipSegs\n     * @param {Point[]|Point[][]} orig\n     * @param {Number|Number[]} altitude\n     * @private\n     */\n    _interpolateSegAlt(clipSegs: any, orig: any, altitude: any): {\n        points: any;\n        altitude: any;\n    };\n    getSymbol(): any;\n    _resetSymbolizersBBOX(): this;\n    paint(extent?: Extent, context?: any, offset?: Point): void;\n    getSprite(resources: any, canvasClass: any): any;\n    isSpriting(): boolean;\n    hitTest(cp: any, tolerance: any): boolean;\n    isHitTesting(): boolean;\n    _prepareShadow(ctx: CanvasRenderingContext2D, symbol: Record<string, any>): void;\n    _eachSymbolizer(fn: any, context?: any): void;\n    get2DExtent(resources?: ResourceCache, out?: Extent): Extent;\n    _computeExtent2D(extent: any): any;\n    _computeFixedExtent(resources: any, extent: any): any;\n    _isDynamicSize(): boolean;\n    _aboveCamera(): boolean;\n    getFixedExtent(): any;\n    setZIndex(change: number): void;\n    show(): void;\n    hide(): void;\n    repaint(): void;\n    /**\n     * refresh symbolizers when symbol changed\n     */\n    refreshSymbol(): void;\n    remove(): void;\n    _removeSymbolizers(): void;\n    /**\n     * delete painter's caches\n     */\n    removeCache(): void;\n    getAltitude(): any;\n    getMinAltitude(): number;\n    getMaxAltitude(): number;\n    _getGeometryAltitude(): number | number[] | number[][];\n    _verifyProjection(): void;\n    _beforePaint(): void;\n    _afterPaint(): void;\n}\nexport default Painter;\n"},{"path":"renderer/geometry/PointRenderer.d.ts","content":"import Point from '../../geo/Point';\nimport { WithNull } from \"../../types/typings\";\ndeclare const CenterPointRenderer: {\n    _getRenderPoints(): [Point[], Point[]];\n};\nexport type CenterPointRendererType = typeof CenterPointRenderer;\ndeclare module '../../geometry/Marker' {\n    interface Marker extends CenterPointRendererType {\n    }\n}\ndeclare module '../../geometry/LineString' {\n    interface LineString {\n        _getRenderPoints(placement?: string): [Point[], WithNull<Point[]>];\n    }\n}\ndeclare module '../../geometry/Polygon' {\n    interface Polygon {\n        _getRenderPoints(placement?: string): [Point[], WithNull<Point[]>];\n    }\n}\nexport {};\n"},{"path":"renderer/geometry/symbolizers/CanvasSymbolizer.d.ts","content":"import Symbolizer from './Symbolizer';\nimport { ResourceCache } from '../../layer/CanvasRenderer';\n/**\n *所有基于 HTML5 Canvas2D 的symbolizer类\n *\n * @english\n * @classdesc\n * Base symbolizer class for all the symbolizers base on HTML5 Canvas2D\n * @abstract\n * @class\n * @private\n * @memberOf symbolizer\n * @name CanvasSymbolizer\n * @extends {Symbolizer}\n */\ndeclare abstract class CanvasSymbolizer extends Symbolizer {\n    symbol: any;\n    _opacityFn: any;\n    _prepareContext(ctx: CanvasRenderingContext2D): void;\n    prepareCanvas(ctx: CanvasRenderingContext2D, style: any, resources?: ResourceCache): void;\n    remove(): void;\n    setZIndex(): void;\n    show(): void;\n    hide(): void;\n    _defineStyle(style: any): any;\n}\nexport default CanvasSymbolizer;\n"},{"path":"renderer/geometry/symbolizers/DebugSymbolizer.d.ts","content":"import Point from '../../../geo/Point';\nimport PointSymbolizer from './PointSymbolizer';\nexport default class DebugSymbolizer extends PointSymbolizer {\n    getPlacement(): string;\n    getDxDy(): Point;\n    symbolize(ctx: CanvasRenderingContext2D): void;\n}\n"},{"path":"renderer/geometry/symbolizers/DrawAltitudeSymbolizer.d.ts","content":"import Point from '../../../geo/Point';\nimport PointSymbolizer from './PointSymbolizer';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport { PointExtent } from '../../../geo';\nexport default class DrawAltitudeSymbolizer extends PointSymbolizer {\n    dxdy: any;\n    static test(symbol: any, geometry: Geometry): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D): void;\n    getDxDy(): Point;\n    get2DExtent(): PointExtent;\n    getPlacement(): string;\n    _getPaintParams(dx: any, dy: any): any[];\n    _drawMarkerAltitude(ctx: CanvasRenderingContext2D, point: Point, groundPoint: Point): void;\n    _drawLineAltitude(ctx: CanvasRenderingContext2D, points: any[], groundPoints: any[]): void;\n    _drawLine(ctx: CanvasRenderingContext2D, points: any[], groundPoints: any[]): void;\n    _getStyle(): any;\n}\n"},{"path":"renderer/geometry/symbolizers/ImageMarkerSymbolizer.d.ts","content":"import PointExtent from '../../../geo/PointExtent';\nimport PointSymbolizer from './PointSymbolizer';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport { ResourceCache } from '../../layer/CanvasRenderer';\nexport default class ImageMarkerSymbolizer extends PointSymbolizer {\n    _url: [string, string | number, string | number];\n    _fixedExtent: PointExtent;\n    static test(symbol: any): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D, resources: ResourceCache): void;\n    _getImage(resources: ResourceCache): any;\n    getFixedExtent(resources: ResourceCache): PointExtent;\n    translate(): any;\n}\n"},{"path":"renderer/geometry/symbolizers/index.d.ts","content":"import Symbolizer from './Symbolizer';\nimport CanvasSymbolizer from './CanvasSymbolizer';\nimport DebugSymbolizer from './DebugSymbolizer';\nimport ImageMarkerSymbolizer from './ImageMarkerSymbolizer';\nimport PointSymbolizer from './PointSymbolizer';\nimport StrokeAndFillSymbolizer from './StrokeAndFillSymbolizer';\nimport TextMarkerSymbolizer from './TextMarkerSymbolizer';\nimport VectorMarkerSymbolizer from './VectorMarkerSymbolizer';\nimport VectorPathMarkerSymbolizer from './VectorPathMarkerSymbolizer';\nimport DrawAltitudeSymbolizer from './DrawAltitudeSymbolizer';\nexport { Symbolizer, CanvasSymbolizer, DebugSymbolizer, ImageMarkerSymbolizer, PointSymbolizer, StrokeAndFillSymbolizer, TextMarkerSymbolizer, VectorMarkerSymbolizer, VectorPathMarkerSymbolizer, DrawAltitudeSymbolizer };\n"},{"path":"renderer/geometry/symbolizers/PointSymbolizer.d.ts","content":"import PointExtent from '../../../geo/PointExtent';\nimport Point from '../../../geo/Point';\nimport CanvasSymbolizer from './CanvasSymbolizer';\nimport Painter from '../Painter';\nimport { Geometry } from '../../../geometry';\n/**\n * 所有点类型符号样式的symbolizer基类\n *\n * @english\n * @classdesc\n * Base symbolizer class for all the point type symbol styles.\n * @abstract\n * @class\n * @private\n * @memberOf symbolizer\n * @name PointSymbolizer\n * @extends {symbolizer.CanvasSymbolizer}\n */\ndeclare abstract class PointSymbolizer extends CanvasSymbolizer {\n    style: any;\n    symbol: any;\n    geometry: Geometry;\n    painter: Painter;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    get2DExtent(): PointExtent;\n    isDynamicSize(): boolean;\n    _rotateExtent(fixedExtent: PointExtent, angle: number): PointExtent;\n    _getRenderPoints(): Point[][];\n    /**\n     * 获取容器内的点用于绘制\n     *\n     * @english\n     * Get container points to draw on Canvas\n     */\n    _getRenderContainerPoints(ignoreAltitude?: boolean): Point[];\n    getPlacement(): any;\n    getRotation(): number;\n    getDxDy(): Point;\n    _getRotationAt(i: number): number;\n    _rotate(ctx: CanvasRenderingContext2D, origin: Point, rotation: number): Point | null;\n}\nexport default PointSymbolizer;\n"},{"path":"renderer/geometry/symbolizers/StrokeAndFillSymbolizer.d.ts","content":"import { ResourceCache } from '../..';\nimport Coordinate from '../../../geo/Coordinate';\nimport PointExtent from '../../../geo/PointExtent';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport CanvasSymbolizer from './CanvasSymbolizer';\nexport default class StrokeAndFillSymbolizer extends CanvasSymbolizer {\n    _extMin: Coordinate;\n    _extMax: Coordinate;\n    _pxExtent: PointExtent;\n    static test(symbol: any, geometry: Geometry): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D, resources: ResourceCache): void;\n    get2DExtent(): PointExtent;\n    getFixedExtent(): PointExtent;\n    _getPaintParams(): any[];\n    translate(): any;\n    _createGradient(ctx: CanvasRenderingContext2D, points: any[], lineColor: any): void;\n}\n"},{"path":"renderer/geometry/symbolizers/Symbolizer.d.ts","content":"import { BBOX } from \"../../../core/util/bbox\";\nimport { Geometry } from \"../../../geometry\";\nimport { Map } from \"../../../map\";\nimport Painter from \"../Painter\";\n/**\n * symbolilzers的基础类,所有的symbolilzers都继承于此\n * 抽象类,不可实例化\n *\n * @english\n * @classdesc\n * Base class for all the symbolilzers\n * @class\n * @extends Class\n * @abstract\n * @private\n */\ndeclare abstract class Symbolizer {\n    bbox: BBOX;\n    geometry: Geometry;\n    painter: Painter;\n    style: any;\n    constructor();\n    _setBBOX(ctx: CanvasRenderingContext2D, x1?: number | BBOX, y1?: number, x2?: number, y2?: number): Symbolizer;\n    _bufferBBOX(ctx: CanvasRenderingContext2D, bufferSize: number): Symbolizer;\n    getMap(): Map;\n    getPainter(): Painter;\n    isDynamicSize(): boolean;\n    isVisible(): boolean;\n    /**\n     * 测试该属性是否是与着色相关的属性\n     *\n     * @english\n     * Test if the property is a property related with coloring\n     * @param  prop - property name to test\n     * @static\n     * @function\n     * @memberof symbolizer.Symbolizer\n     */\n    static testColor(prop: string): boolean;\n}\nexport default Symbolizer;\n"},{"path":"renderer/geometry/symbolizers/TextMarkerSymbolizer.d.ts","content":"import Point from '../../../geo/Point';\nimport PointExtent from '../../../geo/PointExtent';\nimport PointSymbolizer from './PointSymbolizer';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport { ResourceCache } from '../..';\nexport default class TextMarkerSymbolizer extends PointSymbolizer {\n    _dynamic: any;\n    strokeAndFill: any;\n    _textDesc: any;\n    _fixedExtent: PointExtent;\n    _index: number;\n    static test(symbol: any): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D, resources: ResourceCache): void;\n    getPlacement(): any;\n    getRotation(): number;\n    getDxDy(): Point;\n    getFixedExtent(): PointExtent;\n    translate(): any;\n    translateLineAndFill(s: any): any;\n}\n"},{"path":"renderer/geometry/symbolizers/VectorMarkerSymbolizer.d.ts","content":"import Point from '../../../geo/Point';\nimport PointExtent from '../../../geo/PointExtent';\nimport PointSymbolizer from './PointSymbolizer';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport { Extent } from '../../../geo';\nimport { ResourceCache } from '../../layer/CanvasRenderer';\nexport default class VectorMarkerSymbolizer extends PointSymbolizer {\n    _dynamic: any;\n    strokeAndFill: any;\n    padding: number;\n    _stamp: any;\n    _fixedExtent: PointExtent;\n    static test(symbol: any): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D, resources: ResourceCache): void;\n    _drawMarkers(ctx: CanvasRenderingContext2D, cookedPoints: any[], resources: ResourceCache): void;\n    _drawMarkersWithCache(ctx: CanvasRenderingContext2D, cookedPoints: any[], resources: ResourceCache): void;\n    _createMarkerImage(ctx: CanvasRenderingContext2D, resources: ResourceCache): any;\n    _stampSymbol(): any;\n    _getCacheImageAnchor(w: number, h: number): Point;\n    _getGraidentExtent(points: PointExtent | Extent): PointExtent;\n    _drawVectorMarker(ctx: CanvasRenderingContext2D, point: Point, resources: ResourceCache): void;\n    getFixedExtent(): PointExtent;\n    translate(): any;\n}\n"},{"path":"renderer/geometry/symbolizers/VectorPathMarkerSymbolizer.d.ts","content":"import ImageMarkerSymbolizer from './ImageMarkerSymbolizer';\nimport { ResourceCache } from '../../layer/CanvasRenderer';\nexport default class VectorPathMarkerSymbolizer extends ImageMarkerSymbolizer {\n    _url: any;\n    static test(symbol: any): boolean;\n    constructor(symbol: any, geometry: any, painter: any);\n    _prepareContext(): void;\n    _getImage(resources: ResourceCache): any;\n}\n"},{"path":"renderer/geometry/VectorRenderer.d.ts","content":"import Point from '../../geo/Point';\nimport { BBOX } from '../../core/util/bbox';\nimport Extent from '../../geo/Extent';\nimport Coordinate from '../../geo/Coordinate';\nimport { WithNull } from '../../types/typings';\ndeclare const geometryInclude: {\n    _redrawWhenPitch: () => boolean;\n    _redrawWhenRotate: () => boolean;\n    _getRenderBBOX(ctx: CanvasRenderingContext2D, points: Point[]): BBOX;\n};\nexport type GeometryIncludeType = typeof geometryInclude;\ndeclare module '../../geometry/Geometry' {\n    interface Geometry extends GeometryIncludeType {\n    }\n}\ndeclare function _computeRotatedPrjExtent(): Extent;\ndeclare function getRotatedShell(): Coordinate[];\ndeclare const el: {\n    _redrawWhenPitch: () => boolean;\n    _redrawWhenRotate: () => boolean;\n    _computeRotatedPrjExtent: typeof _computeRotatedPrjExtent;\n    getRotatedShell: typeof getRotatedShell;\n    _paintAsPath: () => boolean;\n    _getPaintParams(): any[];\n    _paintOn: (...args: any[]) => void;\n    _getRenderSize(pt: Coordinate): number[];\n};\nexport type ElType = typeof el;\ndeclare module '../../geometry/Ellipse' {\n    interface Ellipse extends Omit<ElType, '_paintOn' | '_getPaintParams'> {\n    }\n}\ndeclare module '../../geometry/Circle' {\n    interface Circle extends Omit<ElType, '_paintOn' | '_getPaintParams'> {\n    }\n}\ndeclare const rectangleInclude: {\n    _getPaintParams(): any[];\n    _paintOn: (ctx: any, points: any, lineOpacity: any, fillOpacity: any, lineDashArray?: any, smoothness?: any) => void;\n    _computeRotatedPrjExtent: typeof _computeRotatedPrjExtent;\n    getRotatedShell: typeof getRotatedShell;\n};\nexport type RectangleIncludeType = typeof rectangleInclude;\ndeclare module '../../geometry/Rectangle' {\n    interface Rectangle extends Omit<RectangleIncludeType, '_paintOn' | '_getPaintParams'> {\n    }\n}\ndeclare const sectorInclude: {\n    _redrawWhenPitch: () => boolean;\n    _getPaintParams(): [Point, number, [number, number]];\n    _paintOn: (...args: any[]) => void;\n};\nexport type SectorIncludeType = typeof sectorInclude;\ndeclare module '../../geometry/Sector' {\n    interface Sector extends Omit<SectorIncludeType, '_paintOn' | '_getPaintParams'> {\n    }\n}\ndeclare module '../../geometry/Path' {\n    interface Path {\n        _paintAsPath: () => boolean;\n    }\n}\ndeclare const lineStringInclude: {\n    arrowStyles: {\n        classic: number[];\n    };\n    _getArrowShape(prePoint?: Point, point?: any, lineWidth?: number, arrowStyle?: any, tolerance?: number): any[];\n    _getPaintParams(): [Point[]];\n    _paintOn(ctx: CanvasRenderingContext2D, points: Point[], lineOpacity?: number, fillOpacity?: number, dasharray?: number[]): any;\n    _getArrowPlacement(): any;\n    _getArrowStyle(): any;\n    _getArrows(points: any, lineWidth: number, tolerance?: number): any[];\n    _getArrowPoints(arrows: any[], segments: any[], lineWidth?: number, arrowStyle?: any, tolerance?: number): void;\n    _paintArrow(ctx: CanvasRenderingContext2D, points: Point[], lineOpacity?: number): void;\n};\nexport type LineStringIncludeType = typeof lineStringInclude;\ndeclare module '../../geometry/LineString' {\n    interface LineString extends LineStringIncludeType {\n    }\n}\ndeclare module '../../geometry/Polygon' {\n    interface Polygon {\n        _paintOn(ctx: CanvasRenderingContext2D, points: Point[], lineOpacity?: number, fillOpacity?: number, dasharray?: number[]): WithNull<BBOX>;\n    }\n}\nexport {};\n"},{"path":"renderer/index.d.ts","content":"/** @namespace renderer */\nexport { ResourceCache } from './layer/CanvasRenderer';\nexport { default as CanvasRenderer } from './layer/CanvasRenderer';\nexport { default as ImageGLRenderable } from './layer/ImageGLRenderable';\nexport * from './layer/tilelayer';\nexport * from './layer/vectorlayer';\nexport * from './layer/canvaslayer';\nexport { default as MapRenderer } from './map/MapRenderer';\nexport { default as MapCanvasRenderer } from './map/MapCanvasRenderer';\nexport { default as Renderable } from './Renderable';\nexport { ImageLayerCanvasRenderer, ImageLayerGLRenderer } from '../layer/ImageLayer';\n"},{"path":"renderer/layer/canvaslayer/CanvasLayerRenderer.d.ts","content":"import CanvasRenderer from '../../../renderer/layer/CanvasRenderer';\nexport default class CanvasLayerRenderer extends CanvasRenderer {\n    buffer: HTMLCanvasElement;\n    _drawContext: any[];\n    _predrawed: boolean;\n    _shouldClear: boolean;\n    getPrepareParams(): any[];\n    getDrawParams(): any[];\n    onCanvasCreate(): void;\n    needToRedraw(): boolean;\n    draw(...args: any[]): void;\n    drawOnInteracting(...args: any[]): void;\n    getCanvasImage(): any;\n    remove(): void;\n    onZoomStart(param: any): void;\n    onZooming(param: any): void;\n    onZoomEnd(param: any): void;\n    onMoveStart(param: any): void;\n    onMoving(param: any): void;\n    onMoveEnd(param: any): void;\n    onResize(param: any): void;\n    prepareDrawContext(): void;\n    _prepareDrawParams(): any[];\n    _drawLayer(...args: any[]): void;\n    _drawLayerOnInteracting(...args: any[]): void;\n}\n"},{"path":"renderer/layer/canvaslayer/index.d.ts","content":"export { default as CanvasLayerRenderer } from './CanvasLayerRenderer';\n"},{"path":"renderer/layer/CanvasRenderer.d.ts","content":"import Class from '../../core/Class';\nimport Actor from '../../core/worker/Actor';\nimport Point from '../../geo/Point';\nimport Extent from '../../geo/Extent';\nimport { SizeLike } from '../../geo/Size';\nimport { TileRenderingCanvas, TileRenderingContext, ImageType } from '../types';\ndeclare class ResourceWorkerConnection extends Actor {\n    constructor();\n    fetchImage(url: string, cb: Function): void;\n}\n/**\n * 在 HTMLCanvasElement 上渲染图层的基类\n * @english\n * Base Class to render layer on HTMLCanvasElement\n * @abstract\n * @protected\n * @memberOf renderer\n * @extends Class\n */\ndeclare class CanvasRenderer extends Class {\n    layer: any;\n    resources: ResourceCache;\n    context: CanvasRenderingContext2D;\n    canvas: TileRenderingCanvas;\n    gl: TileRenderingContext;\n    middleWest: Point;\n    canvasExtent2D: Extent;\n    _extent2D: Extent;\n    _maskExtent: Extent;\n    _painted: boolean;\n    _drawTime: number;\n    _frameTime: number;\n    _resWorkerConn: ResourceWorkerConnection;\n    _toRedraw: boolean;\n    _loadingResource: boolean;\n    _renderComplete: boolean;\n    _canvasUpdated: boolean;\n    _renderZoom: number;\n    _errorThrown: boolean;\n    __zoomTransformMatrix: number[];\n    drawOnInteracting?(...args: any[]): void;\n    checkResources?(): any[];\n    getImageData?(): ImageData;\n    draw?(...args: any[]): void;\n    /**\n     * @param  {Layer} layer the layer to render\n     */\n    constructor(layer: any);\n    /**\n     * Render the layer.\n     * Call checkResources\n     */\n    render(framestamp?: number): void;\n    getFrameTimestamp(): number;\n    checkAndDraw(drawFn: any, ...args: any[]): void;\n    /**\n     * Check if has any external resources to load\n     * If yes, load the resources before calling draw method\n     * @abstract\n     * @method checkResources\n     * @instance\n     * @returns {Array[]} an array of resource arrays [ [url1, width, height], [url2, width, height], [url3, width, height] .. ]\n     * @memberOf renderer.CanvasRenderer\n     */\n    /**\n     * a required abstract method to implement\n     * draw the layer when map is not interacting\n     * @abstract\n     * @instance\n     * @method draw\n     * @memberOf renderer.CanvasRenderer\n     */\n    /**\n     * an optional abstract method to implement\n     * draw the layer when map is interacting (moving/zooming/dragrotating)\n     * @abstract\n     * @instance\n     * @method drawOnInteracting\n     * @param {Object} eventParam event parameters\n     * @memberOf renderer.CanvasRenderer\n     */\n    /**\n     * @private\n     */\n    testIfNeedRedraw(): boolean;\n    /**\n     * Ask whether the layer renderer needs to redraw\n     */\n    needToRedraw(): boolean;\n    /**\n     * A callback for overriding when drawOnInteracting is skipped due to low fps\n     */\n    onSkipDrawOnInteracting(): void;\n    isLoadingResource(): boolean;\n    isRenderComplete(): boolean;\n    /**\n     * Whether must call render instead of drawOnInteracting when map is interacting\n     */\n    mustRenderOnInteracting(): boolean;\n    /**\n     * Set to redraw, ask map to call draw/drawOnInteracting to redraw the layer\n     */\n    setToRedraw(): this;\n    /**\n     *  Mark layer's canvas updated\n     */\n    setCanvasUpdated(): this;\n    /**\n     * Only called by map's renderer to check whether the layer's canvas is updated\n     * @protected\n     * @return {Boolean}\n     */\n    isCanvasUpdated(): boolean;\n    /**\n     * Remove the renderer, will be called when layer is removed\n     */\n    remove(): void;\n    onRemove(): void;\n    onAdd(): void;\n    /**\n     * Get map\n     */\n    getMap(): any;\n    /**\n     * Get renderer's Canvas image object\n     */\n    getCanvasImage(): any;\n    /**\n     * Clear canvas\n     */\n    clear(): void;\n    /**\n     * A method to help improve performance.\n     * If you are sure that layer's canvas is blank, returns true to save unnecessary layer works of maps.\n     */\n    isBlank(): boolean;\n    /**\n     * Show the layer\n     */\n    show(): void;\n    /**\n     * Hide the layer\n     */\n    hide(): void;\n    /**\n     * Set z-index of layer\n     */\n    setZIndex(_z?: number): void;\n    /**\n     * Detect if there is anything painted on the given point\n     * @param point containerPoint\n     */\n    hitDetect(point: Point): boolean;\n    /**\n     * loadResource from resourceUrls\n     * @param  {String[]} resourceUrls    - Array of urls to load\n     * @returns {Promise[]}\n     */\n    loadResources(resourceUrls: string[][]): Promise<any>;\n    /**\n     * Prepare rendering\n     * Set necessary properties, like this._renderZoom/ this.canvasExtent2D, this.middleWest\n     * @private\n     */\n    prepareRender(): void;\n    /**\n     * Create renderer's Canvas\n     */\n    createCanvas(): void;\n    onCanvasCreate(): void;\n    createContext(): void;\n    resetCanvasTransform(): void;\n    /**\n     * Resize the canvas\n     * @param canvasSize the size resizing to\n     */\n    resizeCanvas(canvasSize?: SizeLike): void;\n    /**\n     * Clear the canvas to blank\n     */\n    clearCanvas(): void;\n    /**\n     * @english\n     * Prepare the canvas for rendering. <br>\n     * 1. Clear the canvas to blank. <br>\n     * 2. Clip the canvas by mask if there is any and return the mask's extent\n     * @return {PointExtent} mask's extent of current zoom's 2d point.\n     */\n    prepareCanvas(): any;\n    clipCanvas(context: CanvasRenderingContext2D & {\n        isMultiClip: boolean;\n        isClip: boolean;\n    }): boolean;\n    /**\n     * Get renderer's current view extent in 2d point\n     * @return {Object} view.extent, view.maskExtent, view.zoom, view.middleWest\n     */\n    getViewExtent(): {\n        extent: Extent;\n        maskExtent: Extent;\n        zoom: number;\n        middleWest: Point;\n    };\n    /**\n     * call when rendering completes, this will fire necessary events and call setCanvasUpdated\n     */\n    completeRender(): void;\n    /**\n     * Get renderer's event map registered on the map\n     * @return {Object} events\n     */\n    getEvents(): {\n        _zoomstart: (param: any) => void;\n        _zooming: (param: any) => void;\n        _zoomend: (param: any) => void;\n        _resize: (param: any) => void;\n        _movestart: (param: any) => void;\n        _moving: (param: any) => void;\n        _moveend: (param: any) => void;\n        _dragrotatestart: (param: any) => void;\n        _dragrotating: (param: any) => void;\n        _dragrotateend: (param: any) => void;\n        _spatialreferencechange: (param: any) => void;\n    };\n    /**\n     * onZoomStart\n     * @param  {Object} param event parameters\n     */\n    onZoomStart(param: any): void;\n    /**\n    * onZoomEnd\n    * @param  {Object} param event parameters\n    */\n    onZoomEnd(param: any): void;\n    /**\n    * onZooming\n    * @param  {Object} param event parameters\n    */\n    onZooming(param: any): void;\n    /**\n    * onMoveStart\n    * @param  {Object} param event parameters\n    */\n    onMoveStart(param: any): void;\n    /**\n    * onMoving\n    * @param  {Object} param event parameters\n    */\n    onMoving(param: any): void;\n    /**\n    * onMoveEnd\n    * @param  {Object} param event parameters\n    */\n    onMoveEnd(param: any): void;\n    /**\n    * onResize\n    * @param  {Object} param event parameters\n    */\n    onResize(param: any): void;\n    /**\n    * onDragRotateStart\n    * @param  {Object} param event parameters\n    */\n    onDragRotateStart(param: any): void;\n    /**\n    * onDragRotating\n    * @param  {Object} param event parameters\n    */\n    onDragRotating(param: any): void;\n    /**\n    * onDragRotateEnd\n    * @param  {Object} param event parameters\n    */\n    onDragRotateEnd(param: any): void;\n    /**\n    * onSpatialReferenceChange\n    * @param  {Object} param event parameters\n    */\n    onSpatialReferenceChange(param: any): void;\n    /**\n     * Get ellapsed time of previous drawing\n     * @return {Number}\n     */\n    getDrawTime(): number;\n    _tryToDraw(framestamp: any): void;\n    _drawAndRecord(framestamp: number): void;\n    _promiseResource(url: any): (resolve: any) => void;\n    _cacheResource(url: [string, number | string, string | number], img: ImageType): void;\n}\nexport default CanvasRenderer;\nexport type ResourceUrl = string | string[];\nexport declare class ResourceCache {\n    resources: any;\n    private _errors;\n    constructor();\n    addResource(url: [string, number | string, number | string], img: any): void;\n    isResourceLoaded(url: ResourceUrl, checkSVG?: boolean): boolean;\n    login(url: string): void;\n    logout(url: string): void;\n    getImage(url: ResourceUrl): any;\n    markErrorResource(url: ResourceUrl): void;\n    merge(res: any): this;\n    forEach(fn: Function): this;\n    _getImgUrl(url: ResourceUrl): string;\n    remove(): void;\n}\n"},{"path":"renderer/layer/ImageGLRenderable.d.ts","content":"import { Matrix4InOut } from '../../core/util';\nimport type { Map } from '../../map';\nimport { MixinConstructor } from '../../core/Mixin';\nimport { VertexAttrib, TileImageBuffer, TileImageTexture, TileImageType, TileRenderingProgram, TileRenderingCanvas, TileRenderingContext } from '../types';\nimport { WithNull } from '../../types/typings';\n/**\n * A mixin providing image support in WebGL env\n * @mixin ImageGLRenderable\n * @protected\n */\ndeclare const ImageGLRenderable: <T extends MixinConstructor>(Base: T) => {\n    new (...args: any[]): {\n        gl: TileRenderingContext;\n        canvas: TileRenderingCanvas;\n        canvas2?: TileRenderingCanvas;\n        _debugInfoCanvas?: TileRenderingCanvas;\n        program?: TileRenderingProgram;\n        _layerAlt: number;\n        _layerAltitude: number;\n        layer?: any;\n        texBuffer?: TileImageBuffer;\n        _debugBuffer?: TileImageBuffer;\n        posBuffer?: TileImageBuffer;\n        _imageBuffers?: TileImageBuffer[];\n        _buffers?: TileImageBuffer[];\n        _textures?: TileImageTexture[];\n        getMap?(): Map;\n        /**\n         * 绘制图片数据\n         *\n         * @english\n         * Draw an image at x, y at map's gl zoom\n         * @param image\n         * @param x x at map's gl zoom\n         * @param y y at map's gl zoom\n         * @param w width at map's gl zoom\n         * @param h height at map's gl zoom\n         * @param scale scale at map's gl zoom\n         * @param opacity\n         * @param debugInfo\n         * @param baseColor\n         */\n        drawGLImage(image: TileImageType, x: number, y: number, w: number, h: number, scale: number, opacity: number, debugInfo?: string, baseColor?: number[]): void;\n        /**\n         * 绘制 debug 信息，包括边线和行列号\n         * @param uMatrix\n         * @param x\n         * @param y\n         * @param w\n         * @param h\n         * @param debugInfo\n         */\n        drawDebug(uMatrix: Matrix4InOut, x: number, y: number, w: number, h: number, debugInfo: string): void;\n        /**\n         * 构建瓦片顶点数据\n         * @param x\n         * @param y\n         * @param w\n         * @param h\n         * @param buffer\n         */\n        bufferTileData(x: number, y: number, w: number, h: number, buffer?: TileImageBuffer): TileImageBuffer;\n        /**\n         * 对于需要两个 canvas 来绘制的图层我们需要重新创建一个 canvas\n         * @english\n         * Create another GL canvas to draw gl images\n         * For layer renderer that needs 2 seperate canvases for 2d and gl\n         */\n        createCanvas2(): void;\n        /**\n         * 创建 webgl 实例，优先使用 canvas2\n         * @english\n         * Get webgl context(this.gl). It prefers canvas2, and will change to this.canvas if canvas2 is not created\n         */\n        createGLContext(): void;\n        /**\n         * Resize GL canvas with renderer's 2D canvas\n         */\n        resizeGLCanvas(): void;\n        /**\n         * Clear gl canvas\n         */\n        clearGLCanvas(): void;\n        disposeImage(image: TileImageType): void;\n        _createTexture(image: TileImageType): TileImageTexture;\n        /**\n         * Get a texture from cache or create one if cache is empty\n         */\n        getTexture(): WithNull<TileImageTexture>;\n        /**\n         * Save a texture to the cache\n         */\n        saveTexture(texture: TileImageTexture): void;\n        /**\n         * Load image into a text and bind it with WebGLContext\n         * @param image\n         */\n        loadTexture(image: TileImageType): TileImageTexture;\n        /**\n         * Get a texture from cache or create one if cache is empty\n         */\n        getImageBuffer(): WithNull<TileImageBuffer>;\n        /**\n         * Save a texture to the cache\n         * @param buffer\n         */\n        saveImageBuffer(buffer: TileImageBuffer): void;\n        /**\n         * Load image into a text and bind it with WebGLContext\n         * @returns\n         */\n        loadImageBuffer(data: Float32Array | Int16Array, glBuffer: TileImageBuffer): TileImageBuffer;\n        createImageBuffer(): TileImageBuffer;\n        /**\n         * remove all the resources and remove gl canvas\n         */\n        removeGLCanvas(): void;\n        /**\n         * Create a WebGL buffer\n         * @returns {WebGLBuffer}\n         */\n        createBuffer(): TileImageBuffer;\n        /**\n         * Enable vertex attributes\n         * @params attributes\n         * @example\n         * rendererr.enableVertexAttrib(['a_position', 3, 'FLOAT']);\n         */\n        enableVertexAttrib(attributes: VertexAttrib): void;\n        /**\n         * Create the linked program object\n         * @param vert a vertex shader program (string)\n         * @param frag a fragment shader program (string)\n         * @return created program object, or null if the creation has failed\n         */\n        createProgram(vert: string, frag: string): TileRenderingProgram;\n        /**\n         * use the given program\n         * @param {WebGLProgram} program\n         */\n        useProgram(program: TileRenderingProgram): any;\n        /**\n         * 启用纹理采样器\n         * Enable a sampler, and set texture\n         * @param sampler\n         * @param texIdx id\n         */\n        enableSampler(sampler: string, texIdx?: number): WebGLUniformLocation;\n        _initUniforms(program: TileRenderingProgram, uniforms: string[]): void;\n        _getUniform(program: TileRenderingProgram, uniformName: string): WebGLUniformLocation;\n        set8(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Float32Array;\n        set8Int(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Int16Array;\n    };\n} & T;\nexport default ImageGLRenderable;\nexport declare function isPowerOfTwo(value: number): boolean;\nexport declare function floorPowerOfTwo(value: number): number;\n"},{"path":"renderer/layer/tilelayer/CanvasTileLayerRenderer.d.ts","content":"import TileLayerCanvasRenderer from './TileLayerCanvasRenderer';\nimport TileLayerGLRenderer from './TileLayerGLRenderer';\ndeclare class CanvasRenderer extends TileLayerCanvasRenderer {\n    loadTile(...args: any[]): any;\n}\ndeclare class GLRenderer extends TileLayerGLRenderer {\n    loadTile(...args: any[]): any;\n}\nexport { CanvasRenderer as CanvasTileLayerCanvasRenderer, GLRenderer as CanvasTileLayerGLRenderer };\n"},{"path":"renderer/layer/tilelayer/index.d.ts","content":"import TileLayerCanvasRenderer from './TileLayerCanvasRenderer';\nimport TileLayerGLRenderer from './TileLayerGLRenderer';\nimport { CanvasTileLayerCanvasRenderer, CanvasTileLayerGLRenderer } from './CanvasTileLayerRenderer';\nimport QuadStencil from './QuadStencil';\nexport { TileLayerCanvasRenderer, TileLayerGLRenderer, CanvasTileLayerCanvasRenderer, CanvasTileLayerGLRenderer, QuadStencil };\n"},{"path":"renderer/layer/tilelayer/QuadStencil.d.ts","content":"import { TileRenderingContext, TileRenderingProgram, VertexAttrib } from '../../types';\ndeclare class QuadStencil {\n    gl: TileRenderingContext;\n    quadVertices: any;\n    attributes: VertexAttrib;\n    debug: boolean;\n    buffer: any;\n    program: TileRenderingProgram;\n    _savedProgram: TileRenderingProgram;\n    colorLoc: WebGLUniformLocation;\n    transformLoc: WebGLUniformLocation;\n    ref: GLint;\n    constructor(gl: TileRenderingContext, vertices: any[] | Int8Array, debug?: boolean);\n    start(): void;\n    end(): void;\n    draw(transform: number[]): void;\n    remove(): this;\n    stencilMask(mask: number): this;\n    stencilFunc(func: number, ref: number, mask: number): this;\n    stencilOp(fail: number, zfail: number, zpass: number): this;\n    resetFunc(): this;\n    _save(): void;\n    _restore(): void;\n    _createBuffer(): void;\n    _createProgram(): void;\n}\nexport default QuadStencil;\n"},{"path":"renderer/layer/tilelayer/TileLayerCanvasRenderer.d.ts","content":"import { default as TileLayer } from '../../../layer/tile/TileLayer';\nimport CanvasRenderer from '../CanvasRenderer';\nimport Extent from '../../../geo/Extent';\nimport LRUCache from '../../../core/util/LRUCache';\nimport Actor from '../../../core/worker/Actor';\nimport { TileImageBuffer, TileImageTexture } from '../../types';\nimport type { WithUndef } from '../../../types/typings';\ndeclare class TileWorkerConnection extends Actor {\n    constructor();\n    checkUrl(url: string): string;\n    fetchImage(url: string, workerId: number, cb: Function, fetchOptions: any): void;\n}\n/**\n * 基于 `HTML5 Canvas2D` 的渲染器类，用于瓦片图层\n *\n * @english\n * Renderer class based on HTML5 Canvas2D for TileLayers\n * @class\n * @protected\n * @group renderer\n * @extends {renderer.CanvasRenderer}\n */\ndeclare class TileLayerCanvasRenderer extends CanvasRenderer {\n    tilesInView: TilesInViewType;\n    tilesLoading: {\n        [key: string]: any;\n    };\n    _parentTiles: any[];\n    _childTiles: any[];\n    _tileZoom: number;\n    _tileQueue: {\n        tileInfo: any;\n        tileData: any;\n    }[];\n    _tileQueueIds: Set<LayerId>;\n    tileCache: typeof LRUCache;\n    _compareTiles: any;\n    _tileImageWorkerConn: TileWorkerConnection;\n    _renderTimestamp: number;\n    _frameTiles: {\n        empty: boolean;\n        timestamp: number;\n    };\n    _terrainHelper: TerrainHelper;\n    _tilePlaceHolder: any;\n    _frameTileGrids: TileGrids;\n    drawingCurrentTiles: WithUndef<boolean>;\n    drawingChildTiles: WithUndef<boolean>;\n    drawingParentTiles: WithUndef<boolean>;\n    avgMinAltitude: number;\n    avgMaxAltitude: number;\n    /**\n     *\n     * @param {TileLayer} layer - TileLayer to render\n     */\n    constructor(layer: TileLayer);\n    getCurrentTileZoom(): number;\n    draw(timestamp: number, context: any): number;\n    getTileGridsInCurrentFrame(): TileGrids;\n    getCurrentTimestamp(): number;\n    _getTilesInCurrentFrame(): {\n        childTiles: any[];\n        missedTiles: any[];\n        parentTiles: any[];\n        tiles: any[];\n        incompleteTiles: unknown[];\n        placeholders: any[];\n        loading: boolean;\n        loadingCount: number;\n        tileQueue: {};\n    };\n    removeTileCache(tileId: TileId): void;\n    isTileCachedOrLoading(tileId: TileId): any;\n    isTileCached(tileId: TileId): boolean;\n    isTileFadingIn(tileImage: Tile['image']): boolean;\n    _drawTiles(tiles: any, parentTiles: any, childTiles: any, placeholders: any, parentContext: any): void;\n    _drawChildTiles(childTiles: any, parentContext: any): void;\n    _drawParentTiles(parentTiles: any, parentContext: any): void;\n    onDrawTileStart(context: RenderContext, parentContext: RenderContext): void;\n    onDrawTileEnd(context: RenderContext, parentContext: RenderContext): void;\n    _drawTile(info: any, image: any, parentContext: any): void;\n    _drawTileAndCache(tile: Tile, parentContext: any): void;\n    drawOnInteracting(event: any, timestamp: number, context: any): void;\n    needToRedraw(): boolean;\n    hitDetect(): boolean;\n    /**\n     * @private\n     * limit tile number to load when map is interacting\n     */\n    _getLoadLimit(): number;\n    isDrawable(): boolean;\n    clear(): void;\n    _isLoadingTile(tileId: TileId): boolean;\n    clipCanvas(context: any): boolean;\n    _clipByPitch(ctx: CanvasRenderingContext2D): boolean;\n    loadTileQueue(tileQueue: any): void;\n    loadTile(tile: Tile['info']): Tile['image'];\n    _fetchImage(image: any, tile: Tile['info']): void;\n    loadTileImage(tileImage: any, url: string): void;\n    abortTileLoading(tileImage: Tile['image'], tileInfo: Tile['info']): void;\n    onTileLoad(tileImage: Tile['image'], tileInfo: Tile['info']): void;\n    removeTileLoading(tileInfo: Tile['info']): void;\n    _consumeTileQueue(): void;\n    _computeAvgTileAltitude(): void;\n    checkTileInQueue(): boolean;\n    consumeTile(tileImage: Tile['image'], tileInfo: Tile['info']): void;\n    resetTileLoadTime(tileImage: Tile['image']): void;\n    onTileError(tileImage: Tile['image'], tileInfo: Tile['info'], error?: any): void;\n    drawTile(tileInfo: Tile['info'], tileImage: Tile['image'], parentContext?: RenderContext): void;\n    getDebugInfo(tileId: TileId): string;\n    findChildTiles(info: Tile['info']): any;\n    _findChildTiles(info: Tile['info']): Tile[] | any;\n    _findChildTilesAt(children: Tile[], pmin: number, pmax: number, layer: any, childZoom: number): void;\n    findParentTile(info: Tile['info'], targetDiff?: number): Tile;\n    _findParentTile(info: Tile['info'], targetDiff?: number): Tile;\n    isValidCachedTile(tile: Tile): boolean;\n    isTileComplete(): boolean;\n    _getLayerOfTile(layerId: LayerId): any;\n    getCachedTile(tile: Tile, isParent: boolean): any;\n    _addTileToCache(tileInfo: Tile['info'], tileImage: Tile['image']): void;\n    getTileOpacity(tileImage: Tile['image'], tileInfo: Tile['info']): number;\n    _getTileFadingOpacity(tileImage: Tile['image']): number;\n    onRemove(): void;\n    markCurrent(tile: Tile, isCurrent?: boolean): void;\n    markTiles(): number[];\n    retireTiles(force?: boolean): void;\n    deleteTile(tile: Tile): void;\n    _generatePlaceHolder(res: number): HTMLCanvasElement;\n    setTerrainHelper(helper: TerrainHelper): void;\n}\nexport default TileLayerCanvasRenderer;\nexport type TileId = string;\nexport type LayerId = string | number;\nexport type TerrainHelper = any;\nexport type TileImage = (HTMLImageElement | HTMLCanvasElement | ImageBitmap) & {\n    loadTime: number;\n    glBuffer?: TileImageBuffer;\n    texture?: TileImageTexture;\n    onerrorTick?: number;\n};\nexport interface Tile {\n    id: TileId;\n    info: {\n        x: number;\n        y: number;\n        z: number;\n        idx: number;\n        idy: number;\n        id: TileId;\n        layer: number | string;\n        children: [];\n        error: number;\n        offset: [number, number];\n        extent2d: Extent;\n        res: number;\n        url: string;\n        parent: any;\n        cache?: boolean;\n        minAltitude?: number;\n        maxAltitude?: number;\n        _glScale: number;\n    };\n    image: TileImage;\n    current?: boolean;\n}\nexport type RenderContext = any;\nexport type TilesInViewType = {\n    [key: string]: Tile;\n};\nexport interface TileGrid {\n    extent: Extent;\n    count: number;\n    tiles: Tile[];\n    parents: any[];\n    offset: number[];\n    zoom: number;\n}\nexport interface TileGrids {\n    count: number;\n    tileGrids: TileGrid[];\n}\n"},{"path":"renderer/layer/tilelayer/TileLayerGLRenderer.d.ts","content":"import TileLayerCanvasRenderer from './TileLayerCanvasRenderer';\nimport type { Tile, RenderContext } from './TileLayerCanvasRenderer';\nimport { SizeLike } from '../../../geo/Size';\ndeclare const TileLayerGLRenderer_base: {\n    new (...args: any[]): {\n        gl: import(\"src/renderer/types\").TileRenderingContext;\n        canvas: import(\"src/renderer/types\").TileRenderingCanvas;\n        canvas2?: import(\"src/renderer/types\").TileRenderingCanvas;\n        _debugInfoCanvas?: import(\"src/renderer/types\").TileRenderingCanvas;\n        program?: import(\"src/renderer/types\").TileRenderingProgram;\n        _layerAlt: number;\n        _layerAltitude: number;\n        layer?: any;\n        texBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        _debugBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        posBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        _imageBuffers?: import(\"src/renderer/types\").TileImageBuffer[];\n        _buffers?: import(\"src/renderer/types\").TileImageBuffer[];\n        _textures?: WebGLTexture[];\n        getMap?(): import(\"src\").Map;\n        drawGLImage(image: import(\"src/renderer/types\").TileImageType, x: number, y: number, w: number, h: number, scale: number, opacity: number, debugInfo?: string, baseColor?: number[]): void;\n        drawDebug(uMatrix: import(\"src/core/util\").Matrix4InOut, x: number, y: number, w: number, h: number, debugInfo: string): void;\n        bufferTileData(x: number, y: number, w: number, h: number, buffer?: import(\"src/renderer/types\").TileImageBuffer): import(\"src/renderer/types\").TileImageBuffer;\n        createCanvas2(): void;\n        createGLContext(): void;\n        resizeGLCanvas(): void;\n        clearGLCanvas(): void;\n        disposeImage(image: import(\"src/renderer/types\").TileImageType): void;\n        _createTexture(image: import(\"src/renderer/types\").TileImageType): WebGLTexture;\n        getTexture(): WebGLTexture;\n        saveTexture(texture: WebGLTexture): void;\n        loadTexture(image: import(\"src/renderer/types\").TileImageType): WebGLTexture;\n        getImageBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        saveImageBuffer(buffer: import(\"src/renderer/types\").TileImageBuffer): void;\n        loadImageBuffer(data: Int16Array | Float32Array, glBuffer: import(\"src/renderer/types\").TileImageBuffer): import(\"src/renderer/types\").TileImageBuffer;\n        createImageBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        removeGLCanvas(): void;\n        createBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        enableVertexAttrib(attributes: import(\"src/renderer/types\").VertexAttrib): void;\n        createProgram(vert: string, frag: string): import(\"src/renderer/types\").TileRenderingProgram;\n        useProgram(program: import(\"src/renderer/types\").TileRenderingProgram): any;\n        enableSampler(sampler: string, texIdx?: number): WebGLUniformLocation;\n        _initUniforms(program: import(\"src/renderer/types\").TileRenderingProgram, uniforms: string[]): void;\n        _getUniform(program: import(\"src/renderer/types\").TileRenderingProgram, uniformName: string): WebGLUniformLocation;\n        set8(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Float32Array;\n        set8Int(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Int16Array;\n    };\n} & typeof TileLayerCanvasRenderer;\n/**\n * 基于 HTML5 WebGL 的 TileLayers 渲染器\n *\n * @english\n * Renderer class based on HTML5 WebGL for TileLayers\n * @class\n * @protected\n * @group renderer\n * @extends {renderer.TileLayerCanvasRenderer}\n * @param layer - TileLayer to render\n */\ndeclare class TileLayerGLRenderer extends TileLayerGLRenderer_base {\n    isDrawable(): boolean;\n    needToRedraw(): boolean;\n    onDrawTileStart(context: RenderContext, parentContext: RenderContext): void;\n    onDrawTileEnd(context: RenderContext, parentContext: RenderContext): void;\n    drawTile(tileInfo: Tile['info'], tileImage: Tile['image'], parentContext: RenderContext): void;\n    _bindGLBuffer(image: Tile['image'], w: number, h: number): void;\n    loadTileImage(tileImage: HTMLImageElement, url: string): void;\n    /**\n     * prepare gl, create program, create buffers and fill unchanged data: image samplers, texture coordinates\n     */\n    onCanvasCreate(): void;\n    createContext(): void;\n    resizeCanvas(canvasSize: SizeLike): void;\n    clearCanvas(): void;\n    getCanvasImage(): any;\n    /**\n     * decide whether the layer is renderer with gl.\n     * when map is pitching, or fragmentShader is set in options\n     */\n    isGL(): boolean;\n    deleteTile(tile: Tile): void;\n    onRemove(): void;\n}\nexport default TileLayerGLRenderer;\n"},{"path":"renderer/layer/vectorlayer/index.d.ts","content":"import OverlayLayerCanvasRenderer from './OverlayLayerCanvasRenderer';\nimport VectorLayerCanvasRenderer from './VectorLayerCanvasRenderer';\nexport { OverlayLayerCanvasRenderer, VectorLayerCanvasRenderer };\n"},{"path":"renderer/layer/vectorlayer/OverlayLayerCanvasRenderer.d.ts","content":"import { type Geometry } from '../../../geometry';\nimport CanvasRenderer from '../CanvasRenderer';\nimport { Geometries } from '../../../geometry';\nimport Extent from '../../../geo/Extent';\ninterface MapStateCacheType {\n    resolution: number;\n    pitch: number;\n    bearing: number;\n    glScale: number;\n    glRes: number;\n    _2DExtent: Extent;\n    glExtent: Extent;\n    containerExtent: Extent;\n    offset: number;\n}\n/**\n * OverlayLayer 的父呈现器类，供 OverlayLayer 的子类继承。\n *\n * @english\n *\n * A parent renderer class for OverlayLayer to inherit by OverlayLayer's subclasses.\n * @protected\n * @memberOf renderer\n * @name OverlayLayerCanvasRenderer\n * @extends renderer.CanvasRenderer\n */\ndeclare class OverlayLayerRenderer extends CanvasRenderer {\n    _geosToCheck: Geometries[];\n    _resourceChecked: boolean;\n    clearImageData?(): void;\n    _lastGeosToDraw: Geometry[];\n    mapStateCache: MapStateCacheType;\n    /**\n     * @english\n     * possible memory leaks:\n     * 1. if geometries' symbols with external resources change frequently,\n     * resources of old symbols will still be stored.\n     * 2. removed geometries' resources won't be removed.\n     */\n    checkResources(): any[];\n    render(...args: any[]): void;\n    _addGeoToCheckRes(res: Geometries | Geometries[]): void;\n    onGeometryAdd(geometries: Geometries | Geometries[]): void;\n    onGeometryRemove(params: any): void;\n    onGeometrySymbolChange(e: {\n        target: Geometries;\n    }): void;\n    onGeometryShapeChange(params: any): void;\n    onGeometryPositionChange(params: any): void;\n    onGeometryZIndexChange(params: any): void;\n    onGeometryShow(params: any): void;\n    onGeometryHide(params: any): void;\n    onGeometryPropertiesChange(_: any): void;\n}\nexport default OverlayLayerRenderer;\n"},{"path":"renderer/layer/vectorlayer/VectorLayerCanvasRenderer.d.ts","content":"import { type Vector3 } from '../../../core/util';\nimport OverlayLayerCanvasRenderer from './OverlayLayerCanvasRenderer';\nimport Extent from '../../../geo/Extent';\nimport type { Painter, CollectionPainter } from '../../geometry';\nimport { Point } from '../../../geo';\nimport { Geometries } from '../../../geometry';\nimport type { WithUndef } from '../../../types/typings';\n/**\n * 基于 `HTML5 Canvas2D` 的渲染器类，用于矢量层\n *\n * @english\n * Renderer class based on HTML5 Canvas2D for VectorLayers\n * @protected\n * @group renderer\n * @name VectorLayerCanvasRenderer\n * @extends renderer.OverlaylayerCanvasRenderer\n * @param layer - layer to render\n */\ndeclare class VectorLayerRenderer extends OverlayLayerCanvasRenderer {\n    _lastRenderTime: number;\n    _lastCollisionTime: number;\n    _imageData: ImageData;\n    _geosToDraw: Geometries[];\n    _lastGeosToDraw: Geometries[];\n    _hasPoint: boolean;\n    _onlyHasPoint: WithUndef<boolean>;\n    _displayExtent: Extent;\n    _drawnRes: number;\n    renderEnd: boolean;\n    pageGeos: Geometries[];\n    page: number;\n    maxTolerance: number;\n    geoPainterList: (Painter | CollectionPainter)[];\n    snapshotCanvas: HTMLCanvasElement;\n    setToRedraw(): this;\n    _geoIsCollision(geo: GeoType, collisionIndex: any): boolean;\n    getImageData(): ImageData;\n    clearImageData(): void;\n    checkResources(...args: any[]): any;\n    needToRedraw(): boolean;\n    /**\n     * render layer\n     */\n    draw(): void;\n    isBlank(): boolean;\n    drawOnInteracting(): void;\n    /**\n     * Show and render\n     * @override\n     */\n    show(...args: any[]): void;\n    forEachGeo(fn: Function, context?: any): void;\n    _checkGeos(): this;\n    drawGeos(): void;\n    prepareToDraw(): this;\n    _setDrawGeosDrawTime(): this;\n    checkGeo(geo: Geometries): void;\n    _collidesGeos(): this;\n    onZoomEnd(...args: any[]): void;\n    onRemove(): void;\n    onGeometryPropertiesChange(param: any): void;\n    _updateDisplayExtent(): void;\n    identifyAtPoint(point: Point, options?: {}): any;\n    _updateMapStateCache(): this;\n    /**\n     * 使用批量坐标转换提升性能\n     * 优化前 11fps\n     * 优化后 15fps\n     * Better performance of batch coordinate conversion\n     * @param glRes\n     */\n    _batchConversionMarkers(glRes: number): any[];\n    _sortByDistanceToCamera(cameraPosition: Vector3): void;\n    _constructorIsThis(): boolean;\n    isProgressiveRender(): boolean;\n    getGeosForIdentify(): Geometries[];\n    getGeoPainterList(): (Painter | CollectionPainter)[];\n    _checkSnapshotCanvas(): HTMLCanvasElement;\n    _getCurrentNeedRenderGeos(): Geometries[];\n    _resetProgressiveRender(): void;\n    _clearSnapshotCanvas(): void;\n    _snapshot(): this;\n    _drawSnapshot(): this;\n}\ntype GeoType = any;\nexport default VectorLayerRenderer;\n"},{"path":"renderer/map/MapCanvasRenderer.d.ts","content":"import Point from '../../geo/Point';\nimport MapRenderer from './MapRenderer';\nimport Map from '../../map/Map';\nimport type EditHandle from '../edit/EditHandle';\nimport type EditOutline from '../edit/EditOutline';\nimport type { Layer } from '../../layer';\nimport type Size from '../../geo/Size';\nimport type { WithUndef } from '../../types/typings';\n/**\n * 基于 Canvas2D 的 map 渲染器\n *\n * @english\n * Renderer class based on HTML5 Canvas for maps.\n * @class\n * @protected\n * @extends {renderer.MapRenderer}\n * @memberOf renderer\n */\ndeclare class MapCanvasRenderer extends MapRenderer {\n    _containerIsCanvas: boolean;\n    _loopTime: number;\n    _resizeTime: number;\n    _resizeCount: number;\n    _frameCycleRenderCount: number;\n    _resizeEventList: ResizeObserverEntry[];\n    _needClear: boolean;\n    _canvasUpdated: boolean;\n    _isViewChanged: WithUndef<boolean>;\n    _spatialRefChanged: WithUndef<boolean>;\n    _resizeObserver: ResizeObserver;\n    _resizeInterval: number;\n    _checkSizeInterval: number;\n    _hitDetectFrame: number;\n    _animationFrame: number;\n    _mapview: MapView;\n    _zoomMatrix: number[];\n    _eventParam: any;\n    _canvasIds: string[];\n    _updatedIds: string[];\n    _frameTimestamp: number;\n    _checkPositionTime: number;\n    _tops: (EditHandle | EditOutline)[];\n    context: CanvasRenderingContext2D;\n    canvas: HTMLCanvasElement;\n    topLayer: HTMLCanvasElement;\n    topCtx: CanvasRenderingContext2D;\n    /**\n     * @param map - map for the renderer\n     */\n    constructor(map: Map);\n    load(): void;\n    /**\n     * render layers in current frame\n     * @returns return false to cease frame loop\n     */\n    renderFrame(framestamp: number): boolean;\n    updateMapDOM(): void;\n    drawLayers(layers: Layer[], framestamp: number): void;\n    /**\n     * check if need to call layer's draw/drawInteracting\n     * @param layer\n     */\n    _checkLayerRedraw(layer: Layer): boolean;\n    /**\n     * Draw canvas rendered layer when map is interacting\n     * @param layer\n     * @param t     current consumed time of layer drawing\n     * @param timeLimit time limit for layer drawing\n     * @param framestamp\n     * @returns time to draw this layer\n     * @private\n     */\n    _drawCanvasLayerOnInteracting(layer: Layer, t: number, timeLimit: number, framestamp: number): number;\n    /**\n     * Fire layerload events.\n     * Make sure layer are drawn on map when firing the events\n     * @private\n     */\n    _fireLayerLoadEvents(): void;\n    isLayerCanvasUpdated(): boolean;\n    setLayerCanvasUpdated(): void;\n    /**\n     * Renders the layers\n     */\n    drawLayerCanvas(layers: Layer[]): boolean;\n    setToRedraw(): void;\n    updateMapSize(size: Size): void;\n    getMainPanel(): HTMLCanvasElement | HTMLDivElement | (HTMLElement & {\n        layerDOM: HTMLElement;\n        uiDOM: HTMLElement;\n    });\n    toDataURL(mimeType: string, quality?: number): string;\n    remove(): void;\n    hitDetect(point: Point): void;\n    _getLayerImage(layer: Layer): any;\n    /**\n     * initialize container DOM of panels\n     */\n    initContainer(): void;\n    /**\n     * Is current map's state changed?\n     */\n    isViewChanged(): boolean;\n    _recordView(): void;\n    isSpatialReferenceChanged(): boolean;\n    _getMapView(): MapView;\n    _lockFrameRenderEnable(): boolean;\n    /**\n    * Main frame loop\n    */\n    _frameLoop(framestamp: number): void;\n    _cancelFrameLoop(): void;\n    _drawLayerCanvasImage(layer: Layer, layerImage: any, targetWidth?: number, targetHeight?: number): void;\n    _drawCenterCross(): void;\n    _drawContainerExtent(): void;\n    _drawFog(): void;\n    _debugSky(): this;\n    _getAllLayerToRender(): any[];\n    clearCanvas(): void;\n    _updateCanvasSize(): boolean;\n    createCanvas(): void;\n    _updateDomPosition(framestamp: number): this;\n    _handleResizeEventList(time: number): this;\n    _checkSize(): void;\n    _setCheckSizeInterval(interval: number): void;\n    _registerEvents(): void;\n    _onMapMouseMove(param: any): void;\n    _getCanvasLayers(): any[];\n    addTopElement(e: EditHandle | EditOutline): void;\n    removeTopElement(e: EditHandle | EditOutline): void;\n    getTopElements(): (EditHandle | EditOutline)[];\n    sortTopElements(): void;\n    drawTops(): void;\n}\nexport type MapView = {\n    x: number;\n    y: number;\n    zoom: number;\n    pitch: number;\n    bearing: number;\n    width: number;\n    height: number;\n};\nexport default MapCanvasRenderer;\n"},{"path":"renderer/map/MapRenderer.d.ts","content":"import Class from '../../core/Class';\nimport Point from '../../geo/Point';\nimport type { WithUndef } from '../../types/typings';\nimport type Map from '../../map/Map';\ntype handlerQueueFn = () => void;\n/**\n * 所有地图渲染器的基类。\n * @english\n * Base class for all the map renderers.\n * @abstract\n * @protected\n * @memberOf renderer\n * @extends {Class}\n */\ndeclare abstract class MapRenderer extends Class {\n    map: Map;\n    _handlerQueue: handlerQueueFn[];\n    _frontCount: WithUndef<number>;\n    _backCount: WithUndef<number>;\n    _uiCount: WithUndef<number>;\n    _thisDocVisibilitychange: () => void;\n    _thisDocDragStart: () => void;\n    _thisDocDragEnd: () => void;\n    _thisDocDPRChange: () => void;\n    constructor(map: Map);\n    abstract _frameLoop(f?: number): void;\n    abstract setToRedraw(): void;\n    callInNextFrame(fn: handlerQueueFn): void;\n    executeFrameCallbacks(): void;\n    /**\n     * Move map platform with offset\n     * @param offset\n     * @param force\n     */\n    offsetPlatform(offset: Point, force?: boolean): this;\n    domChanged(): boolean;\n    resetContainer(): void;\n    onZoomEnd(): void;\n    onLoad(): void;\n    _onDocVisibilitychange(): void;\n    _getWrapPanel(): import(\"../../map/Map\").PanelDom;\n    _onDocDragStart(): void;\n    _onDocDragEnd(): void;\n    _onDocDPRChange(): void;\n    _containerIsOffscreen(): boolean;\n}\nexport default MapRenderer;\n"},{"path":"renderer/Renderable.d.ts","content":"import Class from \"../core/Class\";\nimport { MixinConstructor } from \"../core/Mixin\";\n/**\n * 一切可渲染的公共方法，例如：`Map`、'Layers'\n * @english\n * Common methods for classes can be rendered, e.g. Map, Layers\n * @mixin Renderable\n * @protected\n */\nexport default function <T extends MixinConstructor>(Base: T): {\n    new (...args: any[]): {};\n    /**\n     * 用给定的 name 注册一个 `renderer` 类\n     * @english\n     * Register a renderer class with the given name.\n     * @param  name  - renderer's register key\n     * @param  clazz - renderer's class{@link Class}).\n     */\n    registerRenderer<T_1 extends typeof Class>(name: string, clazz: T_1): any & T;\n    /**\n     * 返回用name注册的 `renderer` 类\n     * @english\n     * Get the registered renderer class by the given name\n     * @param  name  - renderer's register key\n     */\n    getRendererClass(name: string): Class | null;\n} & T;\n"},{"path":"renderer/types.d.ts","content":"export type TileRenderingCanvas = {\n    gl?: TileRenderingContext;\n    texture?: TileImageTexture;\n    _parentTileTimestamp?: number;\n} & HTMLCanvasElement;\nexport type TileRenderingContext = {\n    program: TileRenderingProgram;\n    wrap: () => TileRenderingContext;\n} & (WebGLRenderingContext | WebGL2RenderingContext);\nexport type TileRenderingProgram = {\n    fragmentShader: string;\n    vertexShader: string;\n} & WebGLProgram;\nexport type ImageType = HTMLImageElement | ImageBitmap | HTMLCanvasElement;\nexport type TileImageType = {\n    glBuffer?: TileImageBuffer;\n    texture?: TileImageTexture;\n} & ImageType;\nexport type TileImageBuffer = {\n    width?: number;\n    height?: number;\n    type?: string;\n} & WebGLBuffer;\nexport type TileImageTexture = WebGLTexture;\nexport type VertexAttrib = [name: string, stride: number, type?: string];\n"},{"path":"symbol/index.d.ts","content":"export type FunctionTypeExponential = {\n    stops: Array<Array<number>>;\n    base?: number;\n    property?: string;\n    default?: number;\n    type: 'exponential';\n};\nexport type FunctionTypeIdentity = {\n    property: string;\n    default?: any;\n    type: 'identity';\n};\nexport type FunctionTypeInterval = {\n    stops: Array<[number, any]>;\n    property?: string;\n    default?: any;\n    type: 'interval';\n};\nexport type FunctionTypeCategorical = {\n    stops: Array<[number, any]>;\n    property?: string;\n    default?: any;\n    type: 'categorical';\n};\nexport type FunctionTypeColor_Interpolate = {\n    stops: Array<[number, string]>;\n    property?: string;\n    default?: any;\n    type: 'color-interpolate';\n};\nexport type SymbolBooleanType = boolean | FunctionTypeIdentity | FunctionTypeInterval | FunctionTypeCategorical;\nexport type SymbolNumberType = number | FunctionTypeExponential | FunctionTypeIdentity | FunctionTypeInterval | FunctionTypeCategorical;\nexport type SymbolColorType = string | Array<number> | FunctionTypeColor_Interpolate;\nexport type SymbolCommon = {\n    visible?: SymbolBooleanType;\n    opacity?: SymbolNumberType;\n    shadowBlur?: SymbolNumberType;\n    shadowColor?: SymbolColorType;\n    shadowOffsetX?: SymbolNumberType;\n    shadowOffsetY?: SymbolNumberType;\n};\nexport type MarkerCommonSymbol = {\n    markerOpacity?: SymbolNumberType;\n    markerWidth?: SymbolNumberType;\n    markerHeight?: SymbolNumberType;\n    markerDx?: SymbolNumberType;\n    markerDy?: SymbolNumberType;\n    markerHorizontalAlignment?: 'left' | 'middle' | 'right';\n    markerVerticalAlignment?: 'top' | 'middle' | 'bottom';\n    markerPlacement?: 'point' | 'vertex' | 'line' | 'vertex-first' | 'vertex-last';\n    markerRotation?: number;\n};\nexport type FileMarkerSymbol = {\n    markerFile: string;\n} & MarkerCommonSymbol & SymbolCommon;\nexport type VectorMarkerSymbol = {\n    markerType: 'ellipse' | 'cross' | 'x' | 'diamond' | 'bar' | 'square' | 'rectangle' | 'triangle' | 'pin' | 'pie';\n    markerFill?: SymbolColorType;\n    markerFillPatternFile?: string;\n    markerFillOpacity?: number;\n    markerLineColor?: SymbolColorType;\n    markerLineWidth?: number;\n    markerLineOpacity?: number;\n    markerLineDasharray?: Array<number>;\n    markerLinePatternFile?: string;\n} & MarkerCommonSymbol & SymbolCommon;\ntype SVGPathItem = {\n    path: string;\n    fill?: string;\n};\nexport type PathMarkerSymbol = {\n    markerType: 'path';\n    markerPath: string | Array<SVGPathItem>;\n    markerPathWidth: number;\n    markerPathHeight: number;\n} & MarkerCommonSymbol & SymbolCommon;\nexport type TextSymbol = {\n    textName?: string;\n    textPlacement?: 'point' | 'vertex' | 'line' | 'vertex-first' | 'vertex-last';\n    textFaceName?: string;\n    textFont?: string;\n    textWeight?: string;\n    textStyle?: string;\n    textSize?: SymbolNumberType;\n    textFill?: SymbolColorType;\n    textOpacity?: SymbolNumberType;\n    textHaloFill?: SymbolColorType;\n    textHaloRadius?: SymbolNumberType;\n    textHaloOpacity?: SymbolNumberType;\n    textWrapWidth?: number;\n    textWrapCharacter?: string;\n    textLineSpacing?: number;\n    textHorizontalAlignment?: 'left' | 'middle' | 'right';\n    textVerticalAlignment?: 'top' | 'middle' | 'bottom';\n    textAlign?: 'left' | 'right' | 'center';\n    textRotation?: number;\n    textDx?: SymbolNumberType;\n    textDy?: SymbolNumberType;\n};\nexport type LineSymbol = {\n    lineColor?: SymbolColorType;\n    lineWidth?: SymbolNumberType;\n    lineDasharray?: Array<number>;\n    lineOpacity?: SymbolNumberType;\n    lineJoin?: 'round' | 'bevel' | 'miter';\n    lineCap?: 'butt' | 'round' | 'square';\n    linePatternFile?: string;\n    lineDx?: SymbolNumberType;\n    lineDy?: SymbolNumberType;\n};\nexport type FillSymbol = {\n    polygonFill?: SymbolColorType;\n    polygonOpacity?: SymbolNumberType;\n    polygonPatternFile?: string;\n} & LineSymbol;\nexport type AnyMarkerSymbol = FileMarkerSymbol | VectorMarkerSymbol | PathMarkerSymbol | TextSymbol;\nexport type AnySymbol = FillSymbol | LineSymbol | TextSymbol | FileMarkerSymbol | VectorMarkerSymbol | PathMarkerSymbol;\nexport {};\n"},{"path":"test/LayerDrill.d.ts","content":"export {};\n"},{"path":"test/MapDrill.d.ts","content":""},{"path":"test/MarkerDrill.d.ts","content":""},{"path":"types/control/Control.Attribution.d.ts","content":"import Control, { ControlOptionsType } from './Control';\n/**\n * @classdesc\n * A control to allows to display attribution content in a small text box on the map.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var map = new maptalks.Map('map', {\n *    center: [-0.113049, 51.498568],\n *    zoom: 14,\n *    attribution: {\n *       content : 'my attribution',\n *       position : 'bottom-left'\n *    },\n *    baseLayer: new maptalks.TileLayer('base', {\n *        urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n *        subdomains: ['a','b','c','d'],\n *        attribution: '&copy; <a href=\"http://osm.org\">OpenStreetMap</a> contributors, &copy; <a href=\"https://carto.com/\">CARTO</a>'\n *    })\n * });\n * map.addLayer(new maptalks.TileLayer('base', {\n *      urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n *      subdomains: ['a','b','c','d'],\n *      attribution: '&copy; <a href=\"http://osm.org\">OpenStreetMap</a> contributors, &copy; <a href=\"https://carto.com/\">CARTO</a>'\n * }));\n */\ndeclare class Attribution extends Control {\n    _attributionContainer: HTMLDivElement;\n    buildOn(): HTMLDivElement;\n    onAdd(): void;\n    onRemove(): void;\n    _update(): void;\n}\nexport default Attribution;\nexport type AttributionOptionsType = {\n    content?: string;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.Compass.d.ts","content":"import Control, { ControlOptionsType, PositionType } from './Control';\nimport Map from '../map/Map';\ndeclare class Compass extends Control {\n    _compass: HTMLDivElement;\n    _bearing: number;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLDivElement;\n    onAdd(): void;\n    _getCompass(): HTMLElement;\n    _registerDomEvents(): void;\n    _rotateCompass(): void;\n    onRemove(): void;\n    _resetView(): void;\n}\nexport default Compass;\nexport type CompassOptionsType = {\n    position: string | PositionType;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.d.ts","content":"import Class from '../core/Class';\nimport Point from '../geo/Point';\nimport Map from '../map/Map';\ndeclare const Control_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Class;\n/**\n * Base class for all the map controls, you can extend it to build your own customized Control.\n * It is abstract and not intended to be instantiated.\n * @category control\n * @memberOf control\n * @abstract\n * @extends Class\n * @mixes Eventable\n */\ndeclare abstract class Control extends Control_base {\n    _map: Map;\n    __ctrlContainer: HTMLElement;\n    _controlDom: HTMLElement;\n    options: ControlOptionsType;\n    static positions: {\n        [key: string]: PositionType;\n    };\n    /**\n     * Methods needs to implement:  <br>\n     *  <br>\n     * 1. Method to create UI's Dom element  <br>\n     * function buildOn : HTMLElement  <br>\n     *  <br>\n     * 2. Optional, a callback when the control is added.  <br>\n     * function onAdd : void  <br>\n     * 3. Optional, a callback when the control is removed.  <br>\n     * function onRemove : void  <br>\n     *  <br>\n     * @param  {Object} [options=null] configuration options\n     */\n    constructor(options: ControlOptionsType);\n    onAdd(): void;\n    onRemove(): void;\n    abstract buildOn(map?: Map): HTMLElement;\n    /**\n     * Adds the control to a map.\n     * @param {Map} map\n     * @returns {control.Control} this\n     * @fires control.Control#add\n     */\n    addTo(map: Map): this;\n    /**\n     * update control container\n     * @return {control.Control} this\n     */\n    update(): this;\n    /**\n     * Get the map that the control is added to.\n     * @return {Map}\n     */\n    getMap(): Map;\n    /**\n     * Get the position of the control\n     * @return {Object}\n     */\n    getPosition(): PositionType;\n    /**\n     * update the control's position\n     * @param {String|Object} position - can be one of 'top-left', 'top-right', 'bottom-left', 'bottom-right' or a position object like {'top': 40,'left': 60}\n     * @return {control.Control} this\n     * @fires control.Control#positionchange\n     */\n    setPosition(position: ControlPositionType): this;\n    /**\n     * Get the container point of the control.\n     * @return {Point}\n     */\n    getContainerPoint(): Point;\n    /**\n     * Get the control's container.\n     * Container is a div element wrapping the control's dom and decides the control's position and display.\n     * @return {HTMLElement}\n     */\n    getContainer(): HTMLElement;\n    /**\n     * Get html dom element of the control\n     * @return {HTMLElement}\n     */\n    getDOM(): HTMLElement;\n    /**\n     * Show\n     * @return {control.Control} this\n     */\n    show(): this;\n    /**\n     * Hide\n     * @return {control.Control} this\n     */\n    hide(): this;\n    /**\n     * Whether the control is visible\n     * @return {Boolean}\n     */\n    isVisible(): boolean;\n    /**\n     * Remove itself from the map\n     * @return {control.Control} this\n     * @fires control.Control#remove\n     */\n    remove(): this;\n    _parse(position: ControlPositionType): PositionType;\n    _updatePosition(): void;\n}\nexport type PositionType = {\n    top?: number | string;\n    bottom?: number | string;\n    left?: number | string;\n    right?: number | string;\n};\nexport type ControlPositionType = string | PositionType;\nexport type ControlOptionsType = {\n    position?: ControlPositionType;\n};\ndeclare module \"./../map/Map\" {\n    interface Map {\n        addControl(control: Control): this;\n        removeControl(control: Control): this;\n    }\n}\nexport default Control;\n"},{"path":"types/control/Control.LayerSwitcher.d.ts","content":"import type { Layer } from '../layer';\nimport Map from '../map/Map';\nimport Control, { ControlOptionsType } from './Control';\n/**\n * @classdesc\n * A LayerSwitcher control for the map.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var LayerSwitcher = new LayerSwitcher({\n *     position : {'top': '0', 'right': '0'}\n * }).addTo(map);\n*/\ndeclare class LayerSwitcher extends Control {\n    container: HTMLDivElement;\n    panel: HTMLDivElement;\n    button: HTMLButtonElement;\n    /**\n     * method to build DOM of the control\n     * @return {HTMLDOMElement}\n     */\n    buildOn(): HTMLDivElement;\n    onAdd(): void;\n    onRemove(): void;\n    _show(): void;\n    _hide(e: any): void;\n    _createPanel(): void;\n    _renderLayers(map: Map, elm: HTMLElement): void;\n    _isExcluded(layer: Layer): boolean;\n    _renderLayer(layer: any, isBase?: boolean, parentChecked?: boolean): HTMLElement;\n}\nexport default LayerSwitcher;\nexport type LayerSwitcherOptionsType = {\n    baseTitle?: string;\n    overlayTitle?: string;\n    containerClass?: string;\n    excludeLayers?: Array<string>;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.Nav.d.ts","content":"import Control, { ControlOptionsType, PositionType } from './Control';\nexport default class Nav extends Control {\n    buildOn(): any;\n}\nexport type NavOptionsType = {\n    position: string | PositionType;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.Overview.d.ts","content":"import Polygon from '../geometry/Polygon';\nimport Map from '../map/Map';\nimport Control, { ControlOptionsType } from './Control';\n/**\n * @classdesc\n * An overview control for the map.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var overview = new Overview({\n *     position: {'bottom': '0', 'right': '0'},\n *     size: [300, 200]\n * }).addTo(map);\n */\ndeclare class Overview extends Control {\n    mapContainer: HTMLDivElement;\n    button: HTMLDivElement;\n    _overview: Map;\n    _perspective: Polygon;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(): HTMLElement;\n    onAdd(): void;\n    onRemove(): void;\n    /**\n     * Maximize overview control\n     * @returns {control.Overview}\n     */\n    maxmize(): this;\n    /**\n     * Minimize overview control\n     * @returns {control.Overview}\n     */\n    minimize(): this;\n    /**\n     * Return overview's map object\n     * @returns {Map}\n     */\n    getOverviewMap(): Map;\n    _onButtonClick(): void;\n    _updateButtonText(): void;\n    _createOverview(): void;\n    _getOverviewZoom(): number;\n    _onDragEnd(): void;\n    _getPerspectiveCoords(): import(\"src/geo/Coordinate\").default[];\n    _update(): void;\n    _updateSpatialReference(): void;\n    _updateBaseLayer(): void;\n}\nexport default Overview;\nexport type OverviewOptionsType = {\n    level?: number;\n    size?: Array<number>;\n    maximize?: boolean;\n    symbol?: {\n        'lineWidth': number;\n        'lineColor': string;\n        'polygonFill': string;\n        'polygonOpacity': number;\n    };\n    containerClass?: string;\n    buttonClass?: string;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.Panel.d.ts","content":"import { Point } from '../geo';\nimport DragHandler from '../handler/Drag';\nimport Control, { ControlOptionsType, PositionType } from './Control';\n/**\n * @classdesc\n * Class for panel controls.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var panel = new Panel({\n *     position : {'bottom': '0', 'right': '0'},\n *     draggable : true,\n *     custom : false,\n *     content : '<div class=\"map-panel\">hello </div>',\n *     closeButton : true\n * }).addTo(map);\n */\ndeclare class Panel extends Control {\n    draggable: DragHandler;\n    options: PanelOptionsType;\n    _startPos: Point;\n    _startPosition: PositionType;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(): HTMLDivElement;\n    /**\n     * update control container\n     * @return {control.Panel} this\n     */\n    update(): any;\n    /**\n     * Set the content of the Panel.\n     * @param {String|HTMLElement} content - content of the infowindow.\n     * return {control.Panel} this\n     * @fires Panel#contentchange\n     */\n    setContent(content: string | HTMLElement): this;\n    /**\n     * Get content of  the infowindow.\n     * @return {String|HTMLElement} - content of the infowindow\n     */\n    getContent(): string | HTMLElement;\n    _cancelOn(domEvent: any): boolean;\n    _onDragStart(param: any): void;\n    _onDragging(param: any): void;\n    _onDragEnd(param: any): void;\n    /**\n     * Get the connect points of panel for connector lines.\n     * @private\n     */\n    _getConnectPoints(): import(\"src/geo/Coordinate\").default[];\n}\nexport default Panel;\nexport type PanelOptionsType = {\n    draggable?: boolean;\n    custom?: boolean;\n    content?: string | HTMLElement;\n    closeButton?: boolean;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.Reset.d.ts","content":"import Control, { ControlOptionsType } from './Control';\nimport { MapViewType } from '../map/Map';\ndeclare class Reset extends Control {\n    _reset: HTMLDivElement;\n    _view: MapViewType;\n    options: ResetOptionsType;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(): HTMLDivElement;\n    onAdd(): void;\n    setView(view: MapViewType): void;\n    _getReset(): HTMLDivElement;\n    _registerDomEvents(): void;\n    onRemove(): void;\n    _resetView(): void;\n}\nexport default Reset;\nexport type ResetOptionsType = {\n    view?: MapViewType;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.Scale.d.ts","content":"import Map from '../map/Map';\nimport Control, { ControlOptionsType } from './Control';\ndeclare class Scale extends Control {\n    _scaleContainer: HTMLDivElement;\n    _mScale: HTMLDivElement;\n    _iScale: HTMLDivElement;\n    options: ScaleOptionsType;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLDivElement;\n    onRemove(): void;\n    _addScales(): void;\n    _update(): void;\n    _updateScales(maxMeters: number): void;\n    _updateMetric(maxMeters: number): void;\n    _updateImperial(maxMeters: number): void;\n    _updateScale(scale: HTMLDivElement, text: string, ratio: number): void;\n    _getRoundNum(num: number): number;\n}\nexport default Scale;\nexport type ScaleOptionsType = {\n    maxWidth?: number;\n    metric?: boolean;\n    imperial?: boolean;\n    containerClass?: string;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.Toolbar.d.ts","content":"import Control, { ControlOptionsType } from './Control';\nimport type { Map } from './../map/Map';\n/**\n * @classdesc\n * A toolbar control of the map.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var toolbar = new Toolbar({\n *     position : 'top-right',\n *     items: [\n *          {\n *            item: 'item1',\n *            click: function () {\n *              alert('item1 clicked');\n *            }\n *          },\n *          {\n *            item: 'item2',\n *            click: function () {\n *              alert('item2 clicked');\n *            }\n *          }\n *      ]\n * }).addTo(map);\n */\ndeclare class Toolbar extends Control {\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLElement;\n    _createDropMenu(index: number): HTMLElement;\n    _getItems(): any;\n}\nexport default Toolbar;\nexport type ToolBarItem = {\n    item: string;\n    click: () => void;\n};\nexport type ToolbarOptionsType = {\n    height?: number;\n    vertical?: boolean;\n    reverseMenu?: boolean;\n    items: Array<ToolBarItem>;\n} & ControlOptionsType;\n"},{"path":"types/control/Control.Zoom.d.ts","content":"import Map from '../map/Map';\nimport Control, { ControlOptionsType } from './Control';\n/**\n * @classdesc\n * A zoom control with buttons to zoomin/zoomout and a slider indicator for the zoom level.\n * @category control\n * @extends control.Control\n * @memberOf control\n * @example\n * var zoomControl = new Zoom({\n *     position : 'top-left',\n *     slider : true,\n *     zoomLevel : false\n * }).addTo(map);\n */\ndeclare class Zoom extends Control {\n    _levelDOM: HTMLSpanElement;\n    _zoomInButton: HTMLLinkElement;\n    _zoomOutButton: HTMLLinkElement;\n    /**\n     * method to build DOM of the control\n     * @param  {Map} map map to build on\n     * @return {HTMLDOMElement}\n     */\n    buildOn(map: Map): HTMLElement;\n    onRemove(): void;\n    _update(): void;\n    _updateText(): void;\n    _registerDomEvents(): void;\n    _onZoomInClick(e: any): void;\n    _onZoomOutClick(e: any): void;\n}\nexport default Zoom;\nexport type ZoomOptionsType = {\n    zoomLevel?: boolean;\n    seamless?: boolean;\n} & ControlOptionsType;\n"},{"path":"types/control/index.d.ts","content":"import Control from './Control';\nimport Attribution from './Control.Attribution';\nimport Compass from './Control.Compass';\nimport LayerSwitcher from './Control.LayerSwitcher';\nimport Overview from './Control.Overview';\nimport Panel from './Control.Panel';\nimport Reset from './Control.Reset';\nimport Scale from './Control.Scale';\nimport Toolbar from './Control.Toolbar';\nimport Zoom from './Control.Zoom';\nexport { Control, Attribution, Compass, LayerSwitcher, Overview, Panel, Reset, Scale, Toolbar, Zoom };\n"},{"path":"types/core/Ajax.d.ts","content":"export type AjaxGetOption = {\n    headers: any;\n    responseType: any;\n    credentials: any;\n};\nexport type Callback = (...params: any[]) => any;\n/**\n * @classdesc\n * Ajax Utilities. It is static and should not be initiated.\n * @class\n * @static\n * @category core\n */\ndeclare const Ajax: {\n    /**\n     * Get JSON data by jsonp\n     * from https://gist.github.com/gf3/132080/110d1b68d7328d7bfe7e36617f7df85679a08968\n     * @param url - resource url\n     * @param callback  - callback function when completed\n     */\n    jsonp: (url: string, callback: Callback) => any;\n    /**\n     * Fetch remote resource by HTTP \"GET\" method\n     * @param  {String}   url - resource url\n     * @param  {Object}   [options=null] - request options\n     * @param  {Object}   [options.headers=null] - HTTP headers\n     * @param  {String}   [options.responseType=null] - responseType\n     * @param  {String}   [options.credentials=null]  - if with credentials, set it to \"include\"\n     * @param  {Function} cb  - callback function when completed\n     * @return {Ajax}  Ajax\n     * @example\n     * maptalks.Ajax.get(\n     *     'url/to/resource',\n     *     (err, data) => {\n     *         if (err) {\n     *             throw new Error(err);\n     *         }\n     *         // do things with data\n     *     }\n     * );\n     */\n    get: (url: string, options?: any, cb?: any) => any;\n    /**\n     * Fetch remote resource by HTTP \"POST\" method\n     * @param  {String}   url - resource url\n     * @param  {Object}   options - request options\n     * @param  {String|Object}  options.postData - post data\n     * @param  {Object}   [options.headers=null]  - HTTP headers\n     * @param  {Function} cb  - callback function when completed\n     * @return {Ajax}  Ajax\n     * @example\n     * maptalks.Ajax.post(\n     *   'url/to/post',\n     *   {\n     *     postData : {\n     *       'param0' : 'val0',\n     *       'param1' : 1\n     *     }\n     *   },\n     *   (err, data) => {\n     *     if (err) {\n     *       throw new Error(err);\n     *     }\n     *     // do things with data\n     *   }\n     * );\n     */\n    post: (url: string, options?: any, cb?: Callback) => any;\n    _wrapCallback: (client: any, cb: Callback) => () => void;\n    _getClient: (cb: Callback) => any;\n    /**\n     * Fetch resource as arraybuffer.\n     * @param {String} url    - url\n     * @param {Object} [options=null] - options, same as Ajax.get\n     * @param {Function} cb   - callback function when completed.\n     * @example\n     * maptalks.Ajax.getArrayBuffer(\n     *     'url/to/resource.bin',\n     *     (err, data) => {\n     *         if (err) {\n     *             throw new Error(err);\n     *         }\n     *         // data is a binary array\n     *     }\n     * );\n     */\n    getArrayBuffer(url: string, options: any, cb: Callback): any;\n    getImage(img: any, url: string, options: any): any;\n    getJSON: (url: string, options?: any, cb?: Callback) => any;\n};\nexport default Ajax;\n"},{"path":"types/core/Animation.d.ts","content":"export type Callback = (...params: any[]) => any;\n/**\n * @classdesc\n * Easing functions for anmation, from openlayers 3\n * @class\n * @category animation\n * @memberof animation\n * @protected\n */\ndeclare const Easing: {\n    outExpo(x: number): number;\n    outQuint(x: number): number;\n    /**\n     * Start slow and speed up.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    in(t: number): number;\n    /**\n     * Start fast and slow down.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    out(t: number): number;\n    /**\n     * Start slow, speed up, and then slow down again.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    inAndOut(t: number): number;\n    /**\n     * Maintain a constant speed over time.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    linear(t: number): number;\n    /**\n     * Start slow, speed up, and at the very end slow down again.  This has the\n     * same general behavior as {@link inAndOut}, but the final slowdown\n     * is delayed.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    upAndDown(t: number): number;\n};\n/**\n * Animation Frame used internally in animation player.\n * @category animation\n * @memberof animation\n * @protected\n */\ndeclare class Frame {\n    state: any;\n    styles: any;\n    /**\n     * Create an animation frame.\n     * @param {Object} state  - animation state\n     * @param {Object} styles - styles to animate\n     */\n    constructor(state: any, styles: any);\n    get playState(): any;\n    get symbol(): any;\n}\n/**\n * An [Web Animation API]{@link https://developer.mozilla.org/zh-CN/docs/Web/API/Animation} style animation player\n * @category animation\n * @memberof animation\n */\ndeclare class Player {\n    _animation: Callback;\n    options: AnimationOptionsPrivateType;\n    _onFrame: (frame: Frame) => void;\n    playState: string;\n    ready: boolean;\n    finished: boolean;\n    target: any;\n    duration: number;\n    _framer: (cb: Callback) => void;\n    currentTime: number;\n    startTime: number;\n    _playStartTime: number;\n    /**\n     * Create an animation player\n     * @param {Function} animation - animation [framing]{@link framing} function\n     * @param {Object} options     - animation options\n     * @param {Function} onFrame  - callback function for animation steps\n     */\n    constructor(animation: Callback, options: object, onFrame: Callback, target: object);\n    _prepare(): void;\n    /**\n     * Start or resume the animation\n     * @return {Player} this\n     */\n    play(): this;\n    /**\n     * Pause the animation\n     * @return {Player} this\n     */\n    pause(): this;\n    /**\n     * Cancel the animation play and ready to play again\n     * @return {Player} this\n     */\n    cancel(): this;\n    /**\n     * Finish the animation play, and can't be played any more.\n     * @return {Player} this\n     */\n    finish(): this;\n    reverse(): void;\n    _run(): void;\n}\n/**\n * @classdesc\n * Utilities for animation\n * @class\n * @category animation\n * @memberof animation\n */\ndeclare const Animation: {\n    /**\n     * @property {Object} speed         - predefined animation speed\n     * @property {Number} speed.slow    - 2000ms\n     * @property {Number} speed.normal  - 1000ms\n     * @property {Number} speed.fast    - 500ms\n     */\n    speed: {\n        slow: number;\n        normal: number;\n        fast: number;\n    };\n    /**\n     * resolve styles for animation, get a style group of start style, styles to animate and end styles.\n     * @param  {Object} styles - styles to resolve\n     * @return {Object[]}  styles resolved\n     * @private\n     */\n    _resolveStyles(styles: any): {}[];\n    /**\n     * Generate a framing function\n     * @param  {Object[]} styles        - animation style group\n     * @param  {Object} [options=null]  - options\n     * @param  {Object} [options.easing=null]  - animation easing\n     * @return {Function} framing function helps to generate animation frames.\n     */\n    framing(styles: any[], options?: any): (elapsed: number, duration: number) => Frame;\n    _requestAnimFrame(fn: Callback): void;\n    _a(): void;\n    _run(): void;\n    /**\n     * Create an animation player\n     * @param  {Object} styles  - styles to animate\n     * @param  {Object} options - animation options\n     * @param  {Function} step  - callback function for animation steps\n     * @return {Player} player\n     */\n    animate(styles: any, options: any, step: Callback, target: any): Player;\n    _frameFn: () => void;\n};\ndeclare const animate: (styles: any, options: any, step: Callback, target: any) => Player;\nexport { Animation, Easing, Player, Frame, animate };\nexport type EasingType = 'outExpo' | 'outQuint' | 'in' | 'out' | 'inAndOut' | 'linear' | 'upAndDown';\nexport type AnimationOptionsType = {\n    duration?: number;\n    easing?: EasingType;\n    repeat?: boolean;\n};\ntype AnimationOptionsPrivateType = {\n    speed?: number;\n    framer?: () => void;\n    startTime?: number;\n} & AnimationOptionsType;\n"},{"path":"types/core/Browser.d.ts","content":"declare let Browser: any;\nexport default Browser;\n"},{"path":"types/core/Canvas.d.ts","content":"import Extent from '../geo/Extent';\nimport Size from '../geo/Size';\nexport type Ctx = CanvasRenderingContext2D;\ndeclare const Canvas: {\n    getCanvas2DContext(canvas: HTMLCanvasElement): CanvasRenderingContext2D;\n    setHitTesting(testing: boolean): void;\n    createCanvas(width: number, height: number, canvasClass?: any): any;\n    prepareCanvasFont(ctx: Ctx, style: any): void;\n    /**\n     * Set canvas's fill and stroke style\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Object} style\n     * @param {Object} resources\n     * @param {Boolean} testing  - paint for testing, ignore stroke and fill patterns\n     */\n    prepareCanvas(ctx: Ctx, style: any, resources: any, testing?: boolean): void;\n    _createGradient(ctx: Ctx, g: any, extent: Extent): any;\n    _setStrokePattern(ctx: Ctx, strokePattern: string, strokeWidth: number, linePatternOffset: number, resources: any): void;\n    clearRect(ctx: Ctx, x1: number, y1: number, x2: number, y2: number): void;\n    fillCanvas(ctx: Ctx, fillOpacity: number, x?: number, y?: number): void;\n    getRgba(color: any, op: number): any;\n    normalizeColorToRGBA(fill: number[], opacity?: number): string;\n    image(ctx: Ctx, img: CanvasImageSource, x: number, y: number, width?: number, height?: number): void;\n    text(ctx: Ctx, text: any, pt: any, style: any, textDesc: any): import(\"./util/bbox\").BBOX;\n    _textOnMultiRow(ctx: Ctx, texts: any[], style: any, point: any, splitTextSize: Size, textSize: Size): import(\"./util/bbox\").BBOX;\n    _textOnLine(ctx: Ctx, text: any, pt: any, textHaloRadius: number, textHaloFill: any, textHaloAlpha: number): void;\n    fillText(ctx: any, text: any, pt: any, rgba?: any): void;\n    _stroke(ctx: any, strokeOpacity: any, x?: any, y?: any): void;\n    _path(ctx: any, points: any, lineDashArray?: any, lineOpacity?: any, ignoreStrokePattern?: any): void;\n    path(ctx: any, points: any, lineOpacity: any, fillOpacity?: any, lineDashArray?: any): void;\n    _multiClip(ctx: any, points: any): void;\n    polygon(ctx: any, points: any, lineOpacity: any, fillOpacity: any, lineDashArray?: any, smoothness?: any): void;\n    _ring(ctx: any, ring: any, lineDashArray: any, lineOpacity: any, ignorePattern?: any): void;\n    paintSmoothLine(ctx: any, points: any, lineOpacity: any, smoothValue: any, close: any, tailIdx?: any, tailRatio?: any): void;\n    /**\n     * draw an arc from p1 to p2 with degree of (p1, center) and (p2, center)\n     * @param  {Context} ctx    canvas context\n     * @param  {Point} p1      point 1\n     * @param  {Point} p2      point 2\n     * @param  {Number} degree arc degree between p1 and p2\n     */\n    _arcBetween(ctx: CanvasRenderingContext2D, p1: any, p2: any, degree: any): any[];\n    _lineTo(ctx: CanvasRenderingContext2D, p: any): void;\n    bezierCurveAndFill(ctx: CanvasRenderingContext2D, points: any, lineOpacity: any, fillOpacity: any): void;\n    _bezierCurveTo(ctx: CanvasRenderingContext2D, p1: any, p2: any, p3: any): void;\n    ellipse(ctx: CanvasRenderingContext2D, pt: any, width: any, heightTop: any, heightBottom: any, lineOpacity: any, fillOpacity: any): void;\n    rectangle(ctx: CanvasRenderingContext2D, pt: any, size: any, lineOpacity: any, fillOpacity: any): void;\n    sector(ctx: CanvasRenderingContext2D, pt: any, size: any, angles: any, lineOpacity: any, fillOpacity: any): void;\n    _isPattern(style: any): boolean;\n    drawCross(ctx: CanvasRenderingContext2D, x: number, y: number, lineWidth: number, color: string | CanvasGradient | CanvasPattern): void;\n    copy(canvas: HTMLCanvasElement, c?: HTMLCanvasElement): HTMLCanvasElement;\n    pixelRect(ctx: CanvasRenderingContext2D, point: number[], lineOpacity: number, fillOpacity: number): void;\n};\nexport default Canvas;\n"},{"path":"types/core/Class.d.ts","content":"export type ClassOptions = Record<string, any>;\n/**\n *\n * 基类（Class）\n * 该库中所有的类都继承于该基类。\n * 该类提供了定义新类时常用的工具方法，如管理配置options，添加 init hooks 等。\n *\n * @english\n * This library uses ES2015 class system.\n * Class is the root class of class hierachy.\n * It provides utility methods to make it easier to manage configration options, merge mixins and add init hooks.\n *\n * @example\n * const defaultOptions = {\n *     'foo' : 'bar'\n * };\n * class Foo extends maptalks.Class {\n *     constructor(id, options) {\n *         super(options);\n *         this.setId(id);\n *     }\n *\n *     setId(id) {\n *         this.id = id;\n *     }\n *\n *     whenCreated() {\n *         // .....\n *     }\n * }\n *\n * Foo.mergeOptions(defaultOptions);\n *\n * Foo.addInitHook('whenCreated');\n * @category core\n */\ndeclare class Class {\n    _isUpdatingOptions?: boolean;\n    _initHooksCalled?: boolean;\n    _initHooks?: Function[];\n    options?: ClassOptions;\n    /**\n     *\n     * @english\n     * Create an object, set options if given and call all the init hooks.<br />\n     * Options is where the object manages its configuration. Options passed to the object will be merged with parent's instead of overriding it.\n     *\n     * @param options - options to set\n     */\n    constructor(options?: ClassOptions);\n    proxyOptions(): this;\n    /**\n     * 遍历并执行该类或父类用 addInitHook 添加的 init hooks\n     *\n     * @english\n     * Visit and call all the init hooks defined on Class and its parents.\n     */\n    callInitHooks(): this;\n    /**\n     * 设置新的配置 options\n     *\n     * @english\n     * Merges options with the default options of the object.\n     * @param options - options to set\n     */\n    setOptions(options: ClassOptions): this;\n    /**\n     *\n     * 更新options中指定的配置项。\n     * 1. 如果没有提供参数，则返回options配置对象\n     * 2. 如果配置项有对应的handler，handler会被启用或停用，例如draggable\n     *\n     * @english\n     * 1. Return object's options if no parameter is provided. <br/>\n     * 2. update an option and enable/disable the handler if a handler with the same name existed.\n     *\n     * @example\n     * // Get marker's options;\n     * const options = marker.config();\n     * // Set map's option \"draggable\" to false and disable map's draggable handler.\n     * map.config('draggable', false);\n     * // You can update more than one options like this:\n     * map.config({\n     *     'scrollWheelZoom' : false,\n     *     'doubleClickZoom' : false\n     * });\n     * @param conf - config to update\n     * @return\n     */\n    config(conf?: string | ClassOptions, value?: any): ClassOptions | this;\n    /**\n     * options被更新时的回调函数\n     *\n     * @english\n     * Default callback when config is called\n     *\n     * @param conf - updated options\n     */\n    onConfig(conf: ClassOptions): void;\n    _visitInitHooks(proto: any): void;\n    /**\n     * 添加一个初始化钩子（init hook）方法，实例化时会被调用。\n     * 该方法一般用于插件开发，利用初始化钩子，子类无需重载父类的构造函数（constructor），就可以在实例化时执行一些必要的逻辑\n     *\n     * @english\n     * Add an init hook, which will be called when the object is initiated. <br>\n     * It is useful in plugin developing to do things when creating objects without changing class's constructor.\n     * @param fn - a hook function or name of the hook function\n     * @param args - arguments for the init hook function\n     */\n    static addInitHook(fn: Function | string, ...args: any[]): typeof Class;\n    /**\n     * 将一个或多个，sources中定义的方法或属性，mixin到该类的prototype中\n     *\n     * @english\n     * Mixin the specified objects into the class as prototype properties or methods.\n     * @param sources - objects to mixin\n     */\n    static include(...sources: any[]): typeof Class;\n    /**\n     * 用参数中的options定义扩展默认的options\n     *\n     * @english\n     * Mixin options with the class's default options.\n     * @param options - options to merge.\n     */\n    static mergeOptions(options: ClassOptions): typeof Class;\n}\nexport default Class;\n"},{"path":"types/core/CollisionIndex.d.ts","content":"export type Search = {\n    minX?: number;\n    minY?: number;\n    maxX?: number;\n    maxY?: number;\n};\n/**\n * 碰撞检测的实现思路：\n * 1. 选择 collsionIndex\n *    1.1 如果 collision scope 是 layer，则在layer上创建\n *    1.2 如果 collision scope 是 map, 则直接使用map的collisionIndex\n * 2. painter中查询collisionIndex中是否有命中\n *   2.1 如果有，则从 elements 中删除当前item\n *   2.2 如果没有，如果需要的，insert到collisionIndex中\n */\ndeclare class CollisionIndex {\n    _tree: any;\n    constructor();\n    /**\n     * Test if given box is collided with any other\n     * @param {Number[]} box - [minx, miny, maxx, maxy]\n     * @returns {Boolean}\n     */\n    collides(box: any): any;\n    /**\n     * Insert box in collision index\n     * @param {Number[]} box - [minx, miny, maxx, maxy]\n     * @returns {CollisionIndex} this\n     */\n    insertBox(box: any): this;\n    /**\n     * Bulk insert boxes in collision index\n     * Powered by rbush, it will perform better in subsquent query\n     * @param {Number[][]} boxes - [[minx, miny, maxx, maxy], ...]\n     * @returns {CollisionIndex} this\n     */\n    bulkInsertBox(boxes: any): this;\n    /**\n     * Clear the collision index\n     * @returns {CollisionIndex} this\n     */\n    clear(): this;\n}\nexport default CollisionIndex;\n"},{"path":"types/core/Constants.d.ts","content":"/**\n * INTERNAL_LAYER_PREFIX The id prefix of internal layers\n * @global\n */\nexport declare const INTERNAL_LAYER_PREFIX = \"_maptalks__internal_layer_\";\nexport declare const GEOMETRY_COLLECTION_TYPES: string[];\nexport declare const GEOJSON_TYPES: string[];\n/**\n * Symbol properties containing external resources\n */\nexport declare const RESOURCE_PROPERTIES: string[];\n/**\n * Corresponding size properties for the above resource properties\n */\nexport declare const RESOURCE_SIZE_PROPERTIES: string[][];\n/**\n * numeric symbol properties\n */\nexport declare const NUMERICAL_PROPERTIES: {\n    lineWidth: number;\n    lineOpacity: number;\n    lineDx: number;\n    lineDy: number;\n    polygonOpacity: number;\n    markerWidth: number;\n    markerHeight: number;\n    markerDx: number;\n    markerDy: number;\n    markerOpacity: number;\n    markerFillOpacity: number;\n    markerLineWidth: number;\n    markerLineOpacity: number;\n    textSize: number;\n    textOpacity: number;\n    textHaloRadius: number;\n    textWrapWidth: number;\n    textLineSpacing: number;\n    textDx: number;\n    textDy: number;\n};\n/**\n *  color symbol properties\n */\nexport declare const COLOR_PROPERTIES: string[];\nexport declare const DEFAULT_TEXT_SIZE = 14;\n"},{"path":"types/core/Eventable.d.ts","content":"import { MixinConstructor } from './Mixin';\ntype HandlerContext = {\n    handler: HandlerFn;\n    context: any;\n};\nexport type EventRecords = Record<string, HandlerFn>;\nexport type BaseEventParamsType = {\n    type?: string;\n    target?: any;\n    [propName: string]: any;\n};\nexport type HandlerFnResultType = {\n    type: string;\n    target: any;\n    [propName: string]: any;\n};\nexport type HandlerFn = (result?: HandlerFnResultType) => void | boolean;\nexport default function <T extends MixinConstructor>(Base: T): {\n    new (...args: any[]): {\n        _eventMap?: Record<string, HandlerContext[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        /**\n         * 注册事件的监听\n         *\n         * @english\n         * Register a handler function to be called whenever this event is fired.\n         *\n         * @param eventsOn           - event types to register, seperated by space if more than one.\n         * @param handler            - handler function to be called\n         * @param context            - the context of the handler\n         * @example\n         * foo.on('mousedown mousemove mouseup', onMouseEvent, foo);\n         */\n        on(eventsOn: string | EventRecords, handler: HandlerFn, context?: any): this;\n        /**\n         * on方法的alias\n         *\n         * @english\n         * Alias for [on]{@link Eventable.on}\n         *\n         * @param eventTypes     - event types to register, seperated by space if more than one.\n         * @param handler        - handler function to be called\n         * @param context        - the context of the handler\n         */\n        addEventListener(...args: any[]): this;\n        /**\n         * 与on方法作用类似，但监听方法只会执行一次\n         *\n         * @english\n         * Same as on, except the listener will only get fired once and then removed.\n         *\n         * @param eventTypes         - event types to register, seperated by space if more than one.\n         * @param handler            - listener handler\n         * @param context            - the context of the handler\n         * @example\n         * foo.once('mousedown mousemove mouseup', onMouseEvent, foo);\n         */\n        once(eventTypes: string | EventRecords, handler: HandlerFn, context?: any): any;\n        /**\n         *\n         * 取消对事件的监听\n         *\n         * @english\n         * Unregister the event handler for the specified event types.\n         *\n         * @param eventsOff         - event types to unregister, seperated by space if more than one.\n         * @param handler           - listener handler\n         * @param context           - the context of the handler\n         * @example\n         * foo.off('mousedown mousemove mouseup', onMouseEvent, foo);\n         */\n        off(eventsOff: string | EventRecords, handler: HandlerFn, context?: any): any;\n        /**\n         * off方法的别名 alias\n         *\n         * @english\n         * Alias for [off]{@link Eventable.off}\n         *\n         * @param eventTypes       - event types to unregister, seperated by space if more than one.\n         * @param handler          - listener handler\n         * @param context          - the context of the handler\n         */\n        removeEventListener(...args: any[]): any;\n        /**\n         * 是否监听了指定的事件\n         *\n         * @english\n         * Returns listener's count registered for the event type.\n         *\n         * @param eventType       - an event type\n         * @param hanlder         - listener function\n         * @param context         - the context of the handler\n         */\n        listens(eventType: string, handler?: HandlerFn, context?: any): number;\n        /**\n         * 返回所有监听的事件\n         * @english\n         * Get all the listening event types\n         */\n        getListeningEvents(): string[];\n        /**\n         * 把事件监听拷贝给给定的目标对象\n         * @english\n         * Copy all the event listener to the target object\n         * @param target - target object to copy to.\n         */\n        copyEventListeners(target: any): any;\n        /**\n         * 触发一个事件，并执行所有监听该事件的handler方法\n         *\n         * @english\n         * Fire an event, causing all handlers for that event name to run.\n         *\n         * @param  eventType - an event type to fire\n         * @param  param     - parameters for the listener function.\n         */\n        fire(eventType: string, param?: BaseEventParamsType): this;\n        _wrapOnceHandler(evtType: string, handler: HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        /**\n         * 设置一个事件父级对象，用来代替执行所有的事件监听\n         *\n         * @english\n         * Set a event parent to handle all the events\n         * @param parent - event parent\n         * @private\n         */\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: BaseEventParamsType): any;\n    };\n} & T;\nexport {};\n"},{"path":"types/core/GlobalEvent.d.ts","content":"declare class Base {\n}\ndeclare const GlobalEventable_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"./Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"./Eventable\").EventRecords, handler: import(\"./Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"./Eventable\").EventRecords, handler: import(\"./Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"./Eventable\").EventRecords, handler: import(\"./Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"./Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"./Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"./Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"./Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"./Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Base;\ndeclare class GlobalEventable extends GlobalEventable_base {\n}\nexport declare const GlobalEvent: GlobalEventable;\nexport declare const EVENT_DPR_CHANGE = \"dprchange\";\nexport declare const EVENT_DOC_VISIBILITY_CHANGE = \"docvisibilitychange\";\nexport declare const EVENT_DOC_DRAGSTART = \"dragstart\";\nexport declare const EVENT_DOC_DRAGEND = \"dragend\";\nexport {};\n"},{"path":"types/core/JSONAble.d.ts","content":"import { MixinConstructor } from \"./Mixin\";\n/**\n * A helper mixin for JSON serialization.\n * @mixin JSONAble\n */\nexport default function <Class extends MixinConstructor>(Base: Class): {\n    new (...args: any[]): {\n        _jsonType?: string;\n        /**\n         * 返回该类的JSON type\n         * @english\n         * Get object's JSON Type\n         */\n        getJSONType(): string;\n    };\n    /**\n     * 静态方法，用于将该类注册用于JSON序列化与反序列化\n     *\n     * @english\n     * It is a static method. <br>\n     * Register class for JSON serialization and assign a JSON type.\n     * @param  type - JSON type\n     */\n    registerJSONType(type: string): void;\n    /**\n     * 静态方法，返回type对应的注册类\n     * @english\n     * It is a static method. <br>\n     * Get class of input JSON type\n     * @param  type - JSON type\n     */\n    getJSONClass(type: string): Class | null;\n} & Class;\n"},{"path":"types/core/mapbox/index.d.ts","content":"import { loadFunctionTypes, isFunctionDefinition, getFunctionTypeResources, interpolated, hasFunctionDefinition } from '@maptalks/function-type';\n/**\n * @classdesc\n * Utilities from mapbox or implementations of mapbox specifications. It is static and should not be initiated.\n * @class\n * @category core\n * @name MapboxUtil\n */\nexport * from '@maptalks/feature-filter';\nexport { loadFunctionTypes, isFunctionDefinition, getFunctionTypeResources, interpolated, hasFunctionDefinition };\nexport declare function loadGeoSymbol(symbol: any, geo: any): any;\n"},{"path":"types/core/MicroTask.d.ts","content":"type runFunction = () => any;\ntype TaskCreateItem = runFunction | {\n    count?: number;\n    run: runFunction;\n};\n/**\n *\n * @param {Object|Function} task  - a micro task(Promise)\n * @param {Number} task.count - task run count\n * @param {Function} task.run - task run function\n * @return {Promise}\n * @example\n * const run =()=>{\n * //do some things\n * };\n * runTaskAsync({count:4,run}).then(result=>{})\n * runTaskAsync(run).then(result=>{})\n */\nexport declare function runTaskAsync(task: TaskCreateItem): Promise<any>;\nexport declare function startTasks(): void;\nexport declare function pushLoopHook(func: any): void;\nexport {};\n"},{"path":"types/core/Mixin.d.ts","content":"export type MixinConstructor = new (...args: any[]) => {};\n"},{"path":"types/core/ResourceProxy.d.ts","content":"type ProxyItemType = {\n    target: string;\n    [propName: string]: any;\n};\ntype ProxyConfig = {\n    [key: string]: ProxyItemType;\n};\ntype SpriteOptionsType = {\n    imgUrl: string;\n    jsonUrl: string;\n    sourceName?: string;\n};\ntype SVGOptionsType = {\n    url?: string;\n    symbols?: Array<SVGSymbolElement>;\n    sourceName?: string;\n    fill?: string;\n    stroke?: string;\n};\ndeclare function loadSprite(options?: SpriteOptionsType): Promise<unknown>;\ndeclare function loadSvgs(svgs: string | Array<SVGSymbolElement> | SVGOptionsType): Promise<unknown>;\n/**\n * simple Resouce Proxy implementation\n *\n * https://www.webpackjs.com/configuration/dev-server/#devserverproxy\n */\nexport declare const ResourceProxy: {\n    host: string;\n    resources: {\n        [key: string]: any;\n    };\n    proxy: ProxyConfig;\n    origin: ProxyConfig;\n    fromJSON(json: string | object): void;\n    toJSON(): {\n        host: string;\n        proxy: ProxyConfig;\n        origin: ProxyConfig;\n    };\n    getResource(name: string): any;\n    /**\n     * remove resource\n     * @param {String} name\n     */\n    removeResource(name: string): void;\n    /**\n     * add resource\n     * @param {String} name\n     * @param {Object} res\n     */\n    addResource(name: string, res: string | ImageBitmap): void;\n    /**\n    * update  resource (remove and add)\n     * @param {String} name\n     * @param {Object} res\n     */\n    updateResource(name: string, res: string | ImageBitmap): void;\n    /**\n     * get all resource [key,value]\n     * @returns {Object} source\n     */\n    allResource(): {\n        [key: string]: any;\n    };\n    loadSprite: typeof loadSprite;\n    loadSvgs: typeof loadSvgs;\n};\nexport declare function formatResourceUrl(path: string): any;\nexport declare function parseSVG(str: string): any[];\nexport {};\n"},{"path":"types/core/util/bbox.d.ts","content":"import Coordinate from '../../geo/Coordinate';\nexport type BBOX = [number, number, number, number];\nexport declare function getDefaultBBOX(): BBOX;\nexport declare const BBOX_TEMP: BBOX;\n/**\n * 重置bbox\n *\n * @english\n * reset bbox\n * @param bbox\n */\nexport declare function resetBBOX(bbox: BBOX): void;\n/**\n * cal points bbox:linestring,polygon etc\n *\n * @english\n * cal points bbox:linestring,polygon etc\n * @param points\n * @param out\n * @returns\n */\nexport declare function pointsBBOX(points: Coordinate, out: BBOX): void;\nexport declare function pointsBBOX(points: Coordinate[], out: BBOX): void;\nexport declare function setBBOX(bbox: BBOX, x1?: number | BBOX, y1?: number, x2?: number, y2?: number): void;\nexport declare function validateBBOX(bbox?: BBOX): boolean;\nexport declare function bufferBBOX(bbox: BBOX, bufferSize?: number): void;\n"},{"path":"types/core/util/common.d.ts","content":"export declare function now(): number;\n/**\n * @classdesc\n * Utilities methods used internally. It is static and should not be initiated.\n * @class\n * @static\n * @category core\n * @name Util\n */\n/**\n * Merges the properties of sources into destination object.\n * @param dest\n * @param source\n * @return\n * @module Util\n */\nexport declare function extend<T extends {}, U>(dest: T, source: U): T & U;\nexport declare function extend<T extends {}, U, V>(dest: T, source1: U, source2: V): T & U & V;\nexport declare function extend<T extends {}, U, V, W>(dest: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport declare function extend<T extends {}, U, V, W, X>(dest: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport declare function extend(dest: object, ...args: Array<any>): any;\n/**\n * Whether the object is null or undefined.\n * @param  obj - object\n * @return\n * @memberOf Util\n */\nexport declare function isNil(obj: Object): obj is null;\n/**\n * Whether val is a number and not a NaN.\n * @param  val - val\n * @return\n * @memberOf Util\n */\nexport declare function isNumber(val: Object): val is number;\n/**\n * Whether a number is an integer\n * @param  n\n * @return\n * @memberOf Util\n */\nexport declare function isInteger(n: number): boolean;\n/**\n * Whether the obj is a javascript object.\n * @param obj  - object\n * @return\n * @memberOf Util\n */\nexport declare function isObject(obj: Object): obj is object;\n/**\n * Check whether the object is a string\n * @param obj\n * @return\n * @memberOf Util\n */\nexport declare function isString(obj: Object): obj is string;\n/**\n * Check whether the object is a function\n * @param {Object} obj\n * @return {Boolean}\n * @memberOf Util\n */\nexport declare function isFunction(obj: Object): obj is Function;\n/**\n * Check whether the object owns the property.\n * @param obj - object\n * @param key - property\n * @return\n * @memberOf Util\n */\nexport declare function hasOwn(obj: Object, key: string): boolean;\n/**\n * Join an array, standard or a typed one.\n * @param  arr       array to join\n * @param  seperator  seperator\n * @return  result string\n * @private\n * @memberOf Util\n */\nexport declare function join(arr: Object[], seperator: string): string;\n/**\n * Determine if an object has any properties.\n * @param object The object to check.\n * @returns The object is empty\n * @memberOf Util\n */\nexport declare function isEmpty(object: Object): boolean;\nexport declare function toRadian(d: number): number;\nexport declare function toDegree(r: number): number;\n"},{"path":"types/core/util/dom.d.ts","content":"/**\n * DOM utilities used internally.\n * Learned a lot from Leaflet.DomUtil\n * @class\n * @category core\n */\nimport Point from '../../geo/Point';\nimport Size from '../../geo/Size';\n/**\n * Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).\n * @property {String} TRANSFORM\n */\nexport declare const TRANSFORM: string;\n/**\n * Vendor-prefixed tfransform-origin name (e.g. `'webkitTransformOrigin'` for WebKit).\n * @property {String} TRANSFORMORIGIN\n */\nexport declare const TRANSFORMORIGIN: string;\n/**\n * Vendor-prefixed transition name (e.g. `'WebkitTransition'` for WebKit).\n * @property {String} TRANSITION\n */\nexport declare const TRANSITION: string;\n/**\n * Vendor-prefixed filter name (e.g. `'WebkitFilter'` for WebKit).\n * @property {String} FILTER\n */\nexport declare const CSSFILTER: string;\n/**\n * Create a html element.\n * @param tagName\n * @param className\n * @returns\n */\nexport declare function createEl(tagName: string, className?: string): HTMLElement;\n/**\n * Create a html element on the specified container\n * @param tagName\n * @param style - css styles\n * @param container\n * @return\n */\nexport declare function createElOn(tagName: string, style: string, container: HTMLElement): HTMLElement;\n/**\n * Removes a html element.\n * @param node\n */\nexport declare function removeDomNode(node?: HTMLElement): any;\n/**\n * Adds a event listener to the dom element.\n * @param  obj     - dom element to listen on\n * @param  typeArr      - event types, seperated by space\n * @param  handler    - listener function\n * @param  context      - function context\n */\nexport declare function addDomEvent(obj: HTMLElement | Document, typeArr: string, handler: Function, context?: Object): any;\n/**\n * Removes event listener from a dom element\n * @param  obj         - dom element\n * @param  typeArr          - event types, separated by space\n * @param  handler        - listening function\n */\nexport declare function removeDomEvent(obj: HTMLElement | Document, typeArr: string, handler: Function): any;\n/**\n * Check if event type of the dom is listened by the handler\n * @param  obj     - dom element to check\n * @param  typeArr      - event\n * @param  handler    - the listening function\n * @return {Number} - the handler's index in the listener chain, returns -1 if not.\n */\nexport declare function listensDomEvent(obj: HTMLElement | Document, type: string, handler: Function): number;\n/**\n * Prevent default behavior of the browser. <br/>\n * preventDefault Cancels the event if it is cancelable, without stopping further propagation of the event.\n * @param {Event} event - browser event\n */\nexport declare function preventDefault(event: Event): any;\n/**\n * Stop browser event propagation\n * @param   e - browser event.\n */\nexport declare function stopPropagation(e: Event): any;\nexport declare function preventSelection(dom: any): any;\n/**\n * Get the dom element's current position or offset its position by offset\n * @param  dom - HTMLElement\n * @param  offset - position to set.\n * @return  dom element's current position if offset is null.\n */\nexport declare function offsetDom(dom: HTMLElement, offset?: Point): Point;\n/**\n * Compute dom's position\n * @param  dom\n * @return\n */\nexport declare function computeDomPosition(dom: HTMLElement): number[];\n/**\n * Get event's position from the top-left corner of the dom container\n * @param ev    event\n * @return\n */\nexport declare function getEventContainerPoint(ev: MouseEvent, dom: HTMLElement): Point;\n/**\n * set css style to the dom element\n * @param dom dom element\n * @param strCss css text\n */\nexport declare function setStyle(dom: HTMLElement, strCss: string): any;\n/**\n * Whether the dom has the given css class.\n * @param el HTML Element\n * @param name css class\n */\nexport declare function hasClass(el: HTMLElement, name: string): boolean;\n/**\n * add css class to dom element\n * @param el HTML Element\n * @param name css class\n */\nexport declare function addClass(el: HTMLElement, name: string): any;\n/**\n * Set dom's css class\n * @param el HTML Element\n * @param name css class\n */\nexport declare function setClass(el: HTMLElement, name: string): any;\n/**\n * Get dom's css class\n * @param name css class\n * @retrun class字符串\n */\nexport declare function getClass(el: HTMLElement): string;\nexport declare function setOpacity(el: HTMLElement, value: string): any;\n/**\n * Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n * @param el\n * @param offset\n */\nexport declare function setTransform(el: HTMLElement, offset: Point): any;\nexport declare function setTransformMatrix(el: any, m: any): any;\nexport declare function removeTransform(el: any): any;\nexport declare function isHTML(str: string): boolean;\nexport declare function measureDom(parentTag: any, dom: any): Size;\nexport declare function getDomRuler(tag: any): any;\n/**\n * Alias for [addDomEvent]{@link DomUtil.addDomEvent}\n * @param {HTMLElement} obj     - dom element to listen on\n * @param {String} typeArr      - event types, seperated by space\n * @param {Function} handler    - listener function\n * @param {Object} context      - function context\n * @static\n * @function\n * @return {DomUtil}\n */\nexport declare const on: typeof addDomEvent;\n/**\n * Alias for [removeDomEvent]{@link DomUtil.removeDomEvent}\n * @param {HTMLElement} obj         - dom element\n * @param {String} typeArr          - event types, separated by space\n * @param {Function} handler        - listening function\n * @static\n * @function\n * @return {DomUtil}\n */\nexport declare const off: typeof removeDomEvent;\nexport declare function isMoveEvent(type?: string): boolean;\nexport declare const MOUSEMOVE_THROTTLE_TIME = 48;\nexport declare function isMousemoveEventBlocked(target: HTMLElement | any, mousemoveThrottleTime: number): boolean;\n"},{"path":"types/core/util/draw.d.ts","content":"import { ResourceCache } from '../../renderer/layer/CanvasRenderer';\nexport declare function drawImageMarker(ctx: CanvasRenderingContext2D, image: any, point: any, symbol: any): void;\nexport declare function getImage(resources: ResourceCache, url: string): any;\nexport declare function drawVectorMarker(ctx: CanvasRenderingContext2D, point: any, symbol: any, resources: ResourceCache): HTMLCanvasElement;\ninterface TemplateSymbol {\n    markerLineColor: any;\n    markerLinePatternFile: any;\n    markerLineWidth: any;\n    markerLineOpacity: any;\n    markerLineDasharray: any;\n    markerFill: any;\n    markerFillPatternFile: any;\n    markerFillOpacity: any;\n}\nexport declare function translateMarkerLineAndFill<T extends Partial<TemplateSymbol>>(s: T): {\n    lineColor: any;\n    linePatternFile: any;\n    lineWidth: any;\n    lineOpacity: any;\n    lineDasharray: any;\n    lineCap: string;\n    lineJoin: string;\n    polygonFill: any;\n    polygonPatternFile: any;\n    polygonOpacity: any;\n};\nexport type MarkerType = 'triangle' | 'cross' | 'diamond' | 'square' | 'rectangle' | 'x' | 'bar' | 'pin' | 'pie';\nexport declare function getVectorMarkerPoints(markerType: MarkerType, width: number, height: number): any[];\nexport {};\n"},{"path":"types/core/util/env.d.ts","content":"/**\n * from detect-node\n * https://github.com/iliakan/detect-node\n *\n * @property {boolean} IS_NODE - whether running in nodejs but not on electron,node-webkit\n * @global\n * @name IS_NODE\n */\nexport declare const IS_NODE: boolean;\nexport declare function getGlobalThis(): typeof globalThis;\n"},{"path":"types/core/util/gl.d.ts","content":"export declare function createGLContext(canvas: HTMLCanvasElement, options: any): any;\n/**\n* Create a shader object\n* @param gl GL context\n* @param type the type of the shader object to be created\n* @param source shader program (string)\n* @return created shader object, or null if the creation has failed.\n* @private\n*/\nexport declare function compileShader(gl: WebGL2RenderingContext, type: number, source: string): WebGLShader;\n/**\n * Create the linked program object\n * @param gl WebGL2RenderingContext\n * @param vert a vertex shader program (string)\n * @param frag a fragment shader program (string)\n * @return created program object, or null if the creation has failed\n * @private\n */\nexport declare function createProgram(gl: WebGL2RenderingContext | any, vert: string, frag: string): {\n    program: any;\n    vertexShader: WebGLShader;\n    fragmentShader: WebGLShader;\n};\n/**\n * Enable vertex attributes\n * @param gl WebGL2RenderingContext\n * @param attributes [[name, stride, type], [name, stride, type]...]\n * @example\n * rendererr.enableVertexAttrib([\n *  ['a_position', 3, 'FLOAT'],\n *  ['a_normal', 3, 'FLOAT']\n * ]);\n * @private\n */\nexport declare function enableVertexAttrib(gl: WebGL2RenderingContext | any, program: WebGLProgram, attributes: any[]): void;\ndeclare const DEPTH_FUNC_CONSTANTS: {\n    never: number;\n    '<': number;\n    '=': number;\n    '<=': number;\n    '>': number;\n    '!=': number;\n    '>=': number;\n    always: number;\n};\nexport declare function getDepthFunc(v: keyof typeof DEPTH_FUNC_CONSTANTS): number;\nexport {};\n"},{"path":"types/core/util/index.d.ts","content":"export * from './common';\nexport * from './env';\nexport * from './util';\nexport * from './resource';\nexport * from './style';\nexport * from './strings';\nexport * from './mat4';\n"},{"path":"types/core/util/LRUCache.d.ts","content":"/**\n * from mapbox-gl-js\n * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)\n * with hash lookup made possible by keeping a list of keys in parallel to\n * an array of dictionary of values\n *\n * @public\n */\nexport declare class ArrayLRUCache {\n    max: number;\n    onRemove: Function;\n    data: any;\n    order: any[];\n    /**\n     * @param max number of permitted values\n     * @param onRemove callback called with items when they expire\n     */\n    constructor(max: number, onRemove: Function);\n    /**\n     * Clear the cache\n     *\n     * @returns this cache\n     */\n    reset(): this;\n    clear(): void;\n    /**\n     * Add a key, value combination to the cache, trimming its size if this pushes\n     * it over max length.\n     *\n     * @param key lookup key for the item\n     * @param data any value\n     * @returns this cache\n     */\n    add(key: string, data: any): this;\n    /**\n     * Determine whether the value attached to `key` is present\n     *\n     * @param key the key to be looked-up\n     * @returns whether the cache has this value\n     */\n    has(key: string): boolean;\n    /**\n     * List all keys in the cache\n     *\n     * @returns an array of keys in this cache.\n     */\n    keys(): string[];\n    /**\n     * Get the value attached to a specific key and remove data from cache.\n     * If the key is not found, returns `null`\n     *\n     * @param key the key to look up\n     * @returns the data, or null if it isn't found\n     */\n    getAndRemove(key: string): any;\n    /**\n     * Get the value attached to a specific key without removing data\n     * from the cache. If the key is not found, returns `null`\n     *\n     * @param key the key to look up\n     * @returns the data, or null if it isn't found\n     */\n    get(key: string): any;\n    /**\n     * Remove a key/value combination from the cache.\n     *\n     * @param key the key for the pair to delete\n     * @returns this cache\n     */\n    remove(key: string): this;\n    /**\n     * Change the max size of the cache.\n     *\n     * @param max the max size of the cache\n     * @returns this cache\n     */\n    setMaxSize(max: number): this;\n}\ndeclare const LRUCache: any;\nexport default LRUCache;\n"},{"path":"types/core/util/marker.d.ts","content":"import Point from '../../geo/Point';\nimport PointExtent from '../../geo/PointExtent';\nimport { type MarkerType } from './draw';\nimport { ResourceCache } from '../../renderer/layer/CanvasRenderer';\nexport declare const DEFAULT_MARKER_SYMBOLS: {\n    markerWidth: number;\n    markerHeight: number;\n    markerLineWidth: number;\n};\nexport declare function getMarkerRotationExtent(out: PointExtent, rad: number, width: number, height: number, dxdy: Point, alignPoint: Point): PointExtent;\nexport declare function getVectorMarkerFixedExtent(out: PointExtent, symbol: any, size?: [number, number]): PointExtent;\nexport declare function getDefaultHAlign(markerType?: MarkerType): \"right\" | \"middle\";\nexport declare function getDefaultVAlign(markerType?: MarkerType): \"bottom\" | \"middle\" | \"top\";\nexport declare function getVectorMarkerAnchor(symbol: any, w: number, h: number): Point;\nexport declare function calVectorMarkerSize(out: [number, number], symbol: any): [number, number];\nexport declare function getMarkerRotation(symbol: any, prop?: string): number;\nexport declare function getImageMarkerFixedExtent(out: PointExtent, symbol: any, resources?: ResourceCache): PointExtent;\nexport declare function getTextMarkerFixedExtent(out: PointExtent, symbol: any, textDesc: any): PointExtent;\nexport declare function getMarkerFixedExtent(out: PointExtent, symbol: any, resources: ResourceCache, textDesc: any): PointExtent;\nexport declare function isTextSymbol(symbol: any): boolean;\nexport declare function isImageSymbol(symbol: any): boolean;\nexport declare function isVectorSymbol(symbol: any): boolean;\nexport declare function isPathSymbol(symbol: any): boolean;\nexport declare const DYNAMIC_SYMBOL_PROPS: string[];\nexport declare const SIZE_SYMBOL_PROPS: string[];\nexport declare function emptyExtent(extent: PointExtent): void;\n"},{"path":"types/core/util/mat4.d.ts","content":"export type Matrix4 = [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number];\nexport type Matrix4InOut = Matrix4 | number[];\nexport type Vector3 = [number, number, number];\nexport type Vector4 = [number, number, number, number];\nexport type Vector = Vector3 | Vector4;\nexport declare function perspective(out: Matrix4InOut, fovy: number, aspect: number, near: number, far: number): Matrix4InOut;\nexport declare function translate(out: Matrix4InOut, a: Matrix4InOut, v: Vector): Matrix4InOut;\nexport declare function scale(out: Matrix4InOut, a: Matrix4InOut, v: Vector): Matrix4InOut;\nexport declare function rotateX(out: Matrix4InOut, a: Matrix4InOut, rad: number): Matrix4InOut;\nexport declare function rotateZ(out: Matrix4InOut, a: Matrix4InOut, rad: number): Matrix4InOut;\nexport declare function multiply(out: Matrix4InOut, a: Matrix4InOut, b: Matrix4InOut): Matrix4InOut;\nexport declare function invert(out: Matrix4InOut, a: Matrix4InOut): Matrix4InOut;\n/**\n * Set a mat4 to the identity matrix\n * @ignore\n * @param out the receiving matrix\n * @returns out\n */\nexport declare function identity(out: Matrix4InOut): Matrix4InOut;\n/**\n * Copy the values from one mat4 to another\n * @ignore\n * @param out the receiving matrix\n * @param a the source matrix\n * @returns out\n */\nexport declare function copy(out: Matrix4InOut, a: Matrix4InOut): Matrix4InOut;\n"},{"path":"types/core/util/math.d.ts","content":"import { Matrix4InOut, Vector3, Vector4 } from './mat4';\nexport declare function applyMatrix(out: Matrix4InOut, v: Vector3, e: Matrix4InOut): Matrix4InOut;\nexport declare function applyMatrix4(out: Matrix4InOut, v: Vector4, e: Matrix4InOut): any;\nexport declare function matrixToQuaternion(out: any, te: any): any;\nexport declare function quaternionToMatrix(out: Matrix4InOut, q: any): Matrix4InOut;\nexport declare function setPosition(out: Matrix4InOut, v: Vector3): Matrix4InOut;\nexport declare function lookAt(te: Matrix4InOut, eye: any, target: any, up: any): Matrix4InOut;\n"},{"path":"types/core/util/path.d.ts","content":"import Point from '../../geo/Point';\nimport Coordinate from '../../geo/Coordinate';\nexport declare function clipLine(points: any, bounds: any, round?: boolean, noCut?: boolean): any[];\nexport declare function clipSegment(a: any, b: any, bounds: any, useLastCode: any, round: any, noCut: any): false | any[];\nexport declare function clipPolygon(points: any, bounds: any, round?: boolean): any;\n/**\n * caculate the distance from a point to a segment.\n * @param p\n * @param p1\n * @param p2\n * @return distance from p to (p1, p2)\n * @memberOf Util\n */\nexport declare function distanceToSegment(p: Point, p1: Point, p2: Point): number;\n/**\n * Whether the coordinate is inside the polygon\n * @param p\n * @param points\n * @return\n * @memberOf Util\n */\nexport declare function pointInsidePolygon(p: Coordinate, points: Coordinate[]): boolean;\n/**\n * Is the point within an ellipse\n * @param  point\n * @param  center ellipse's center\n * @param  southeast ellipse's southeast point\n * @param  tolerance\n * @returns\n * @private\n * @memberOf Util\n */\nexport declare function withInEllipse(point: Point, center: Point, southeast: Point, tolerance: number): boolean;\nexport declare function getMinMaxAltitude(altitude: number | number[] | number[][]): [number, number];\n"},{"path":"types/core/util/resource.d.ts","content":"/**\n * Translate symbol properties to SVG properties\n * @param s - object with symbol properties\n * @return  object with SVG properties\n * @memberOf Util\n */\nexport declare function translateToSVGStyles(s: any): {\n    stroke: {\n        stroke: any;\n        'stroke-width': any;\n        'stroke-opacity': any;\n        'stroke-dasharray': any;\n        'stroke-linecap': string;\n        'stroke-linejoin': string;\n    };\n    fill: {\n        fill: any;\n        'fill-opacity': any;\n    };\n};\n/**\n * Get SVG Base64 String from a marker symbol with (markerType : path)\n * @param  symbol - symbol with markerType of path\n * @param  width\n * @param  height\n * @return SVG Base64 String\n * @memberOf Util\n */\nexport declare function getMarkerPathBase64(symbol: any, width?: number, height?: number): string;\n/**\n * Get external resources from the given symbol\n * @param symbol     - symbol\n * @param toAbsolute - whether convert url to aboslute\n * @return resource urls\n * @memberOf Util\n */\nexport declare function getExternalResources(symbol: any, toAbsolute?: boolean): string[];\n/**\n * Convert symbol's resources' urls from relative path to an absolute path.\n * @param symbol\n * @private\n * @memberOf Util\n */\nexport declare function convertResourceUrl(symbol: any): any;\nexport declare function isImageBitMap(img: any): boolean;\n"},{"path":"types/core/util/strings.d.ts","content":"import Point from '../../geo/Point';\nimport Size from '../../geo/Size';\n/**\n * @classdesc\n * Utilities methods for Strings used internally. It is static and should not be initiated.\n * @class\n * @static\n * @category core\n * @name StringUtil\n */\nexport declare const EMPTY_STRING = \"\";\n/**\n * Trim the string\n * @param str\n * @return\n * @memberOf StringUtil\n */\nexport declare function trim(str: string): string;\nexport declare function replaceAll(str: string, key: string, value: string): string;\n/**\n * Escape special characters from string.\n * Including: \\b \\t \\r \\v \\f\n * @param str string to escape\n * @return\n * @memberOf StringUtil\n */\nexport declare function escapeSpecialChars(str: string): string;\n/**\n * Split string by specified char\n * @param chr - char to split\n * @return\n * @memberOf StringUtil\n */\nexport declare function splitWords(chr: string): string[];\n/**\n * Gets width of the text with a certain font.\n * More performant than stringLength.\n * @param text - text to measure\n * @param font - font of the text, same as the CSS font.\n * @return\n * @memberOf StringUtil\n */\nexport declare function stringWidth(text: string, font?: string): number;\n/**\n * Gets size in pixel of the text with a certain font.\n * @param text - text to measure\n * @param font - font of the text, same as the CSS font.\n * @return\n * @memberOf StringUtil\n */\nexport declare function stringLength(text: string, font: string, size?: number): Size;\n/**\n * Split text content by dom.\n * @param content - content to split\n * @param font - font of the text, same as the CSS font.\n * @return wrapWidth - width to wrap\n * @return {String[]}\n * @memberOf StringUtil\n */\nexport declare function splitContent(content: string, font: string, wrapWidth: number, textWidth: number): any[];\n/**\n * Replace variables wrapped by square brackets ({foo}) with actual values in props.\n * @example\n *     // will returns 'John is awesome'\n *     const actual = replaceVariable('{foo} is awesome', {'foo' : 'John'});\n * @param str      - string to replace\n * @param props    - variable value properties\n * @return\n * @memberOf StringUtil\n */\nexport declare function replaceVariable(str: string, props: Object): string;\n/**\n * Generate text descriptors according to symbols\n * @return {Object} text descriptor\n * @memberOf StringUtil\n */\nexport declare function describeText(textContent: any, symbol: any): {\n    total: number;\n    size: Size;\n    rows: any[];\n    rawSize: Size;\n};\n/**\n * Gets text's align point according to the horizontalAlignment and verticalAlignment\n * @param  {Size} size                  - text size\n * @param  {String} horizontalAlignment - horizontalAlignment: left/middle/right\n * @param  {String} verticalAlignment   - verticalAlignment: top/middle/bottom\n * @return {Point}\n * @memberOf StringUtil\n */\nexport declare function getAlignPoint(size: Size, horizontalAlignment: string, verticalAlignment: string): Point;\nexport declare const DEFAULT_FONT = \"sans-serif\";\nexport declare const DEFAULT_TEXTSIZE = 14;\n/**\n * Returns CSS Font from a symbol with text styles.\n * @param  {Object} style symbol with text styles\n * @return {String}       CSS Font String\n * @memberOf StringUtil\n */\nexport declare function getFont(style: any): any;\n/**\n * Split a text to multiple rows according to the style.\n * @param {String} text     - text to split\n * @param {Object} style    - text style\n * @return {Object[]} the object's structure: { rowNum: rowNum, textSize: textSize, rows: textRows, rawSize : rawSize }\n * @memberOf StringUtil\n */\nexport declare function splitTextToRow(text: string, style: Object): {\n    total: number;\n    size: Size;\n    rows: any[];\n    rawSize: Size;\n};\nexport declare function hashCode(s: string): number;\n"},{"path":"types/core/util/style.d.ts","content":"/**\n * Whether the color is a gradient\n * @param g - color to test\n * @return\n * @memberOf Util\n */\nexport declare function isGradient(g: Object): boolean;\n/**\n * Get stamp of a gradient color object.\n * @param g gradient color object\n * @return gradient stamp\n * @memberOf Util\n */\nexport declare function getGradientStamp(g: Object): string;\nexport declare function getSymbolStamp(symbol: Object, prefix: string): string | number;\n/**\n * Get stamp of a symbol\n * @param symbol symbol\n * @return symbol's stamp\n * @memberOf Util\n */\nexport declare function getSymbolHash(symbol: Object | Object[], prefix?: string): string | number;\n/**\n * Reduce opacity of the color by ratio\n * @param symbol symbols to set\n * @param ratio  ratio of opacity to reduce\n * @return new symbol or symbols\n * @memberOf Util\n */\nexport declare function lowerSymbolOpacity(symbol: Object | Object[], ratio: number): Object | Object[];\n/**\n * Merges the properties of sources into the symbol. <br>\n * @param args - sources\n * @return merged symbol\n * @memberOf Util\n */\nexport declare function extendSymbol(...args: Object[]): Object | Object[];\nexport declare function parseStyleRootPath(style: any): any;\nexport declare function convertStylePath(styles: any[], replacer: any): void;\nexport declare function parseSymbolPath(symbol: any, replacer: string): void;\n/**\n * geometry symbol has lineDasharray\n * @memberOf Util\n */\nexport declare function isDashLine(symbolizers?: any[]): boolean;\n"},{"path":"types/core/util/util.d.ts","content":"declare let requestAnimFrame: any, cancelAnimFrame: typeof clearTimeout;\nexport { requestAnimFrame, cancelAnimFrame };\nexport declare function isSVG(url: string): 0 | 1 | 2;\n/**\n * Load a image, can be a remote one or a local file. <br>\n * If in node, a SVG image will be converted to a png file by [svg2img]{@link https://github.com/FuZhenn/node-svg2img}<br>\n * @param img  - the image object to load.\n * @param imgDesc - image's descriptor, it's an array. imgUrl[0] is the url string, imgUrl[1] is the width, imgUrl[2] is the height.\n * @private\n * @memberOf Util\n */\nexport declare function loadImage(img: any, imgDesc: Object[]): void;\nexport declare function UID(): number;\nexport declare const GUID: typeof UID;\n/**\n * Parse a JSON string to a object\n * @param str   - a JSON string\n * @return\n * @memberOf Util\n */\nexport declare function parseJSON(str: string): any;\nexport declare function pushIn<T extends Array<any>>(...args: T[]): number;\nexport declare function removeFromArray<T>(obj: T, array: T[]): void;\nexport declare function forEachCoord(arr: any[], fn: Function, context?: any): any;\nexport declare function getValueOrDefault<T>(v: T, d: T): T;\n/**\n * Polyfill for Math.sign\n * @param  x\n * @return\n * @memberOf Util\n */\nexport declare function sign(x: number): number;\nexport declare function log2(x: number): number;\n/**\n * Interpolate between two number.\n *\n * @param from\n * @param to\n * @param t interpolation factor between 0 and 1\n * @returns interpolated color\n */\nexport declare function interpolate(a: number, b: number, t: number): number;\n/**\n * constrain n to the given range, via modular arithmetic\n * @param n value\n * @param min the minimum value to be returned, inclusive\n * @param max the maximum value to be returned, inclusive\n * @returns constrained number\n * @private\n */\nexport declare function wrap(n: number, min: number, max: number): number;\n/**\n * constrain n to the given range via min + max\n *\n * @param n value\n * @param min the minimum value to be returned\n * @param max the maximum value to be returned\n * @returns the clamped value\n * @private\n */\nexport declare function clamp(n: number, min: number, max: number): number;\n/**\n * Is object an array and not empty.\n * @param obj\n * @return true|false\n * @private\n * @memberOf Util\n */\nexport declare function isArrayHasData(obj: Object): boolean;\n/**\n * Whether the input string is a valid url.\n * form: https://github.com/axios/axios/blob/master/lib/helpers/isAbsoluteURL.js\n * @param url - url to check\n * @return\n * @memberOf Util\n * @private\n */\nexport declare function isURL(url: string): boolean;\nexport declare function isCssUrl(str: string): 0 | 1 | 2 | 3;\nexport declare function extractCssUrl(str: string): any;\n/**\n * btoa or a polyfill in old browsers. <br>\n * Creates a base-64 encoded ASCII string from a String object in which each character in the string is treated as a byte of binary data.<br>\n * From https://github.com/davidchambers/Base64.js\n * @param input - input string to convert\n * @return ascii\n * @memberOf Util\n * @example\n *     const encodedData = Util.btoa(stringToEncode);\n */\nexport declare function btoa(input: string): string;\nexport declare function b64toBlob(b64Data: string, contentType: string): Blob;\n/**\n * Compute degree bewteen 2 points.\n * @param  x0\n * @param  y0\n * @param  x1\n * @param  y1\n * @return    degree between 2 points\n * @memberOf Util\n */\nexport declare function computeDegree(x0: number, y0: number, x1: number, y1: number): number;\n/**\n * Transparent 1X1 gif image\n * from https://css-tricks.com/snippets/html/base64-encode-of-1x1px-transparent-gif/\n * @memberOf Util\n */\nexport declare const emptyImageUrl = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n/**\n * shallow equal\n * @param  obj1\n * @param  obj2\n * @return\n * @private\n * @memberOf Util\n */\nexport declare function equalMapView(obj1: Object, obj2: Object): boolean;\n/**\n * Flash something, show and hide by certain internal for times of count.\n *\n * @param interval   - interval of flash, in millisecond (ms)\n * @param count      - flash times\n * @param cb         - callback function when flash ended\n * @param context    - callback context\n * @return this\n * @private\n * @memberOf Util\n */\nexport declare function flash(interval?: number, count?: number, cb?: Function, context?: any): any;\nexport declare function _defaults(obj: any, defaults: any): any;\nexport declare function getPointsResultPts(points?: any[], ptKey?: string): any[];\nexport declare function getImageBitMap<T>(data: {\n    data: T;\n}, cb: (d: T) => void | any): void;\nexport declare function getAbsoluteURL(url: string): string;\nexport declare function calCanvasSize(size: {\n    width: number;\n    height: number;\n}, devicePixelRatio?: number): {\n    cssWidth: string;\n    cssHeight: string;\n    width: number;\n    height: number;\n};\n"},{"path":"types/core/util/vec3.d.ts","content":"import { Matrix4InOut, Vector3 as Vec3 } from './mat4';\n/**\n * Set the components of a vec3 to the given values\n * @ignore\n * @param out the receiving vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @returns out\n */\nexport declare function set(out: Vec3, x: number, y: number, z: number): Vec3;\n/**\n * Adds two vec3's\n * @ignore\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @returns out\n */\nexport declare function add(out: Vec3, a: Vec3, b: Vec3): Vec3;\n/**\n * Subtracts vector b from vector a\n * @ignore\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @returns out\n */\nexport declare function subtract(out: Vec3, a: Vec3, b: Vec3): Vec3;\n/**\n * Calculates the length of a vec3\n * @ignore\n * @param a vector to calculate length of\n * @returns length of a\n */\nexport declare function length(a: Vec3): number;\n/**\n * Normalize a vec3\n * @ignore\n * @param out the receiving vector\n * @param a vector to normalize\n * @returns out\n */\nexport declare function normalize(out: Vec3, a: Vec3): Vec3;\n/**\n * Calculates the dot product of two vec3's\n * @ignore\n * @param a the first operand\n * @param b the second operand\n * @returns dot product of a and b\n */\nexport declare function dot(a: Vec3, b: Vec3): number;\n/**\n * Scales a vec3 by a scalar number\n * @ignore\n * @param out the receiving vector\n * @param a the vector to scale\n * @param b amount to scale the vector by\n * @returns out\n */\nexport declare function scale(out: Vec3, a: Vec3, b: number): Vec3;\n/**\n * Computes the cross product of two vec3's\n * @ignore\n * @param out the receiving vector\n * @param a the first operand\n * @param b the second operand\n * @returns out\n */\nexport declare function cross(out: Vec3, a: Vec3, b: Vec3): Vec3;\n/**\n * Calculates the euclidian distance between two vec3's\n * @ignore\n * @param a the first operand\n * @param b the second operand\n * @returns distance between a and b\n */\nexport declare function distance(a: Vec3, b: Vec3): number;\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n * @ignore\n * @param out the receiving vector\n * @param a the vector to transform\n * @param m matrix to transform with\n * @returns out\n */\nexport declare function transformMat4(out: Vec3, a: Vec3, m: Matrix4InOut): Vec3;\nexport declare function angle(a: Vec3, b: Vec3): number;\n"},{"path":"types/core/worker/Actor.d.ts","content":"import WorkerPool from './WorkerPool';\nexport type Message<T = any> = {\n    command: \"broadcast\" | 'send';\n    data: T;\n    buffers: ArrayBuffer[];\n    cb: Function;\n    workerId?: number;\n};\n/**\n * An actor to exchange data from main-thread to workers\n * contains code from [mapbox-gl-js](https://github.com/mapbox/mapbox-gl-js)\n * @category core\n * @memberof worker\n * @example\n *  const workerKey = 'test_worker_key';\n    maptalks.registerWorkerAdapter(workerKey, function (exports, global) {\n      //will be called only for once when loaded in worker thread\n      exports.initialize = function () {\n        console.log('[worker] initialized');\n      };\n      //to receive message from main thread sent by maptalks.worker.Actor\n      exports.onmessage = function (message, postResponse) {\n        const data = message.data;\n        console.log(`[worker] received data : ` + data);\n        //send message back to main thread\n        //the parameters:\n        //error, data, buffers (arraybuffers in data)\n        postResponse(null, 'message from worker thread', null);\n      };\n    });\n\n    const MyActor = class extends maptalks.worker.Actor {\n      test(info, cb) {\n        //send data to worker thread\n        this.send(info, null, cb);\n      }\n    }\n\n    //must be same with workerKey for maptalks.registerWorkerAdapter\n    const actor = new MyActor(workerKey);\n    actor.test('hi', (err, data) => {\n      //received data from worker thread\n      console.log(data);\n    });\n */\ndeclare class Actor {\n    _delayMessages: Message[];\n    initializing: boolean;\n    workerKey: string;\n    workerPool: WorkerPool;\n    currentActor: number;\n    actorId: number;\n    workers: Worker[];\n    callbacks: {\n        [key: string]: Function;\n    };\n    callbackID: number;\n    receiveFn: any;\n    constructor(workerKey: string);\n    created(): void;\n    /**\n     * If the actor is active\n     * @returns\n     */\n    isActive(): boolean;\n    /**\n     * Broadcast a message to all Workers.\n     * @param {Object} data - data to send to worker thread\n     * @param {ArrayBuffer[]} buffers - arraybuffers in data as transferables\n     * @param {Function} cb - callback function when received message from worker thread\n     */\n    broadcast<T = any>(data: T, buffers: ArrayBuffer[], cb: Function): this;\n    /**\n     * Sends a message from a main-thread to a Worker and call callback when response received.\n     *\n     * @param {Object} data - data to send to worker thread\n     * @param {ArrayBuffer[]} buffers - arraybuffers in data as transferables\n     * @param {Function} cb - callback function when received message from worker thread\n     * @param {Number} [workerId=undefined] - Optional, a particular worker id to which to send this message.\n     */\n    send<T = any>(data: T, buffers: ArrayBuffer[], cb: Function, workerId?: number): this;\n    /**\n     * A listener callback for incoming message from worker thread.\n     * SHOULD NOT BE OVERRIDED only if you know what you are doing.\n     * @param {Object} message - response message from worker thread\n     */\n    receive(message: Message): void;\n    /**\n     * Remove the actor\n     */\n    remove(): void;\n    /**\n     * Send a message to a Worker.\n     * @param {Object} data - data to send\n     * @param {ArrayBuffer[]} buffers   - arraybuffers in data\n     * @param {Number} targetID The ID of the Worker to which to send this message. Omit to allow the dispatcher to choose.\n     * @returns {Number} The ID of the worker to which the message was sent.\n     */\n    post(data: any, buffers: ArrayBuffer[], targetID: number): number;\n    /**\n     * Get a dedicated worker in a round-robin fashion\n     */\n    getDedicatedWorker(): number;\n}\nexport default Actor;\n"},{"path":"types/core/worker/CoreWorkers.d.ts","content":"import WorkerPool from './WorkerPool';\nexport declare const imageFetchWorkerKey = \"core-fetch-image\";\nexport declare function setWorkerPool(pool: WorkerPool): void;\nexport declare function getWorkerPool(): WorkerPool;\nexport declare function setWorkersCreated(): void;\nexport declare function workersHasCreated(): boolean;\nexport declare function adapterHasCreated(workerKey: string): boolean;\nexport declare function pushAdapterCreated(workerKey: string): void;\n"},{"path":"types/core/worker/FPSCheckWorker.d.ts","content":"export declare const CHECK_FPS_WORKER_KEY = \"check_browser_max_fps\";\n"},{"path":"types/core/worker/Worker.d.ts","content":"type AdapterFunction = (exports: {\n    initialize: Function;\n    onmessage: (message: any, postResponse: Function) => void;\n}, global: any) => void;\ntype Adapter = string | AdapterFunction;\n/**\n * Register a worker adapter\n * @param {String} workerKey  - an unique key name of the worker adapter\n * @param {Function} adapter  - the worker adapter function, it must be a complete packaged function with no dependency of other functions\n * @example\n * maptalks.registerWorkerAdapter('foo', function (exports, global) {\n        //will be called only for once when loaded in worker thread\n        exports.initialize = function () {\n          console.log('[worker] initialized');\n        };\n        //to receive message from main thread sent by maptalks.worker.Actor\n        exports.onmessage = function (message, postResponse) {\n          const data = message.data;\n          console.log(`[worker] received data : ` + data);\n          //send message back to main thread\n          //the parameters:\n          //error, data, buffers (arraybuffers in data)\n          postResponse(null, 'message from worker thread', null);\n        };\n     });\n    @global\n    @static\n */\nexport declare function registerWorkerAdapter(workerKey: string, adapter: Adapter): void;\nexport declare function getWorkerSourcePath(): string;\nexport declare function createAdapter(key: string, cb: Function): void;\nexport {};\n"},{"path":"types/core/worker/WorkerPool.d.ts","content":"import { type Message } from './Actor';\ndeclare class MessageBatch {\n    _limit: number;\n    _messages: Message[];\n    buffers: ArrayBuffer[];\n    constructor(limit?: number);\n    addMessage(msg: Message, buffers: ArrayBuffer[]): void;\n    isFull(): boolean;\n    getMessage(): {\n        messageType: string;\n        messages: Message[];\n    };\n}\n/**\n * Worker Pool\n * contains code from [mapbox-gl-js](https://github.com/mapbox/mapbox-gl-js)\n * @private\n */\nexport default class WorkerPool {\n    active: {\n        [key: number]: boolean;\n    };\n    workerCount: number;\n    _messages: MessageBatch[][];\n    _messageBuffers: ArrayBuffer[];\n    workers: Worker[];\n    constructor();\n    acquire(id: number): Worker[];\n    release(id: number): void;\n    addMessage(workerId: number, data: any, buffers: ArrayBuffer[]): void;\n    commit(): void;\n    getWorkers(): Worker[];\n    broadcastIdleMessage(): this;\n}\nexport declare function getGlobalWorkerPool(): WorkerPool;\nexport {};\n"},{"path":"types/geo/Coordinate.d.ts","content":"import Position from './Position';\nexport type CoordinateJson = {\n    x: number;\n    y: number;\n    z?: number;\n};\nexport type CoordinateArray = [number, number] | [number, number, number];\nexport type CoordinateLike = Coordinate | CoordinateJson | CoordinateArray;\n/**\n * 坐标 `Coordinate` 的实现，例如一个地理坐标点（经度，纬度）\n *\n * @english\n *\n * Represents a coordinate point <br>\n * e.g. <br>\n * A geographical point (longitude, latitude)\n * @example\n *\n * ```ts\n * const coord = new Coordinate(0, 0);\n * ```\n * @example\n *\n * ```ts\n * const coord = new Coordinate([ 0, 0 ]);\n * ```\n * @example\n *\n * ```ts\n * const coord = new Coordinate({ x : 0, y : 0 });\n * ```\n * @category basic types\n */\ndeclare class Coordinate extends Position {\n    /**\n     * 将一个或多个坐标对象转换为GeoJSON风格的坐标。\n     *\n     * @english\n     *\n     * Convert one or more Coordinate objects to GeoJSON style coordinates\n     * @param coordinates - coordinates to convert\n     * @example\n     *\n     * ```ts\n     * // result is [[100,0], [101,1]]\n     * const numCoords = Coordinate.toNumberArrays([new Coordinate(100,0), new Coordinate(101,1)]);\n     * ```\n     */\n    static toNumberArrays(coordinates: Coordinate): any;\n    static toNumberArrays(coordinates: Coordinate[]): any;\n    static toNumberArrays(coordinates: Coordinate[][]): any;\n    static toNumberArrays(coordinates: Coordinate[][][]): any;\n    /**\n     * 将一个或多个GeoJSON风格的坐标转换为坐标对象。\n     *\n     * @english\n     *\n     * Convert one or more GeoJSON style coordiantes to Coordinate objects\n     * @param coordinates - coordinates to convert\n     * @example\n     *\n     * ```ts\n     * const coordinates = Coordinate.toCoordinates([[100,0], [101,1]]);\n     * ```\n     */\n    static toCoordinates(coordinates: CoordinateArray | CoordinateArray[] | CoordinateArray[][] | Coordinate | Coordinate[] | Coordinate[][]): Coordinate | Coordinate[] | Coordinate[][];\n    /**\n     * 使用差值与另一个坐标进行比较，判断是否临近\n     *\n     * @english\n     *\n     * Compare with another Coordinate with a delta\n     * @param p\n     * @param delta\n     */\n    closeTo(p: Coordinate, delta?: number): boolean;\n    /**\n     * 返回该坐标的经纬度绝对值的坐标对象（不会改变原始数据）\n     *\n     * @english\n     *\n     * Return abs value of the coordinate\n     * @returns abs Coordinate\n     */\n    abs(): Coordinate;\n    /**\n     * 类似于数学中的四舍五入，对坐标的 x 和 y 进行舍入，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Like math.round, rounding the coordinate's xy.\n     * @returns rounded coordinate\n     */\n    round(): Coordinate;\n    /**\n     * 对坐标的 x 和 y 向上取整，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Like math.ceil, ceil the coordinate's xy.\n     * @returns ceiled coordinate\n     */\n    ceil(): Coordinate;\n    /**\n     * 对坐标的 x 和 y 向下取整，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Like math.floor, floor the coordinate's xy.\n     * @returns floored coordinate\n     */\n    floor(): Coordinate;\n    /**\n     * 返回当前坐标的 copy\n     *\n     * @english\n     *\n     * Returns a copy of the coordinate\n     * @returns copy\n     */\n    copy(): Coordinate;\n    /**\n     * 坐标数字保留指定位数的小数\n     *\n     * @english\n     *\n     * Formats coordinate number using fixed-coordinate notation.\n     * @param n - The number of digits to appear after the decimal coordinate\n     * @returns fixed coordinate\n     */\n    toFixed(n: number): Coordinate;\n    /**\n     * 与传入坐标相加，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Returns the result of addition of another coordinate.\n     * @param x - coordinate to add\n     * @returns result\n     */\n    add(x: CoordinateLike): Coordinate;\n    /**\n     * 与传入坐标相加，返回一个新 Coordinate\n     *\n     * @english\n     *\n     * Returns the result of addition of another coordinate.\n     * @param x - coordinate to add\n     * @param y - coordinate to add\n     * @returns result\n     */\n    add(x: number, y: number): Coordinate;\n    /**\n     * 与传入坐标相减，返回一个新 Coordinate。\n     *\n     * @english\n     *\n     * Returns the result of subtraction of another coordinate.\n     * @param x - coordinate to add\n     * @returns result\n     */\n    sub(x: CoordinateLike): Coordinate;\n    /**\n     * 与传入坐标相减，返回一个新 Coordinate。\n     *\n     * @english\n     *\n     * Returns the result of subtraction of another coordinate.\n     * @param x - coordinate to add\n     * @param y - coordinate to add\n     * @returns result\n     */\n    sub(x: number, y: number): Coordinate;\n    /**\n     * Returns the result of multiplication of the current coordinate by the given number.\n     * @param ratio - ratio to multi\n     * @returns result\n     */\n    multi(ratio: number): Coordinate;\n    /**\n     * 与另外一个 coordinate 进行比较，以查看它们是否相等\n     *\n     * @english\n     *\n     * Compare with another coordinate to see whether they are equal.\n     * @param c - coordinate to compare\n     */\n    equals(c: Coordinate): boolean;\n}\nexport default Coordinate;\n"},{"path":"types/geo/CRS.d.ts","content":"import type { WithNull } from '../types/typings';\n/**\n * 表示由 [GeoJSON](http://geojson.org/geojson-spec.html#coordinate-reference-system-objects)定义的 CRS\n * @english\n *\n * Represent CRS defined by [GeoJSON]{@link http://geojson.org/geojson-spec.html#coordinate-reference-system-objects}\n *\n * @category geo\n */\ndeclare class CRS {\n    type: string;\n    properties: any;\n    /**\n     * @param type type of the CRS\n     * @param properties CRS's properties\n     */\n    constructor(type: string, properties: Record<string, any>);\n    /**\n     * 使用 maptalks 创建 [proj4](https://github.com/OSGeo/proj.4) 形式的 CRS\n     * @english\n     * Create a [proj4](https://github.com/OSGeo/proj.4) style CRS used by maptalks <br>\n     * @example\n     * {\n     *     \"type\"       : \"proj4\",\n     *     \"properties\" : {\n     *         \"proj\"   : \"+proj=longlat +datum=WGS84 +no_defs\"\n     *     }\n     * }\n     * var crs_wgs84 = CRS.createProj4(\"+proj=longlat +datum=WGS84 +no_defs\");\n     * @param proj a proj4 projection string.\n     */\n    static createProj4(proj: string): CRS;\n    /**\n     * 使用 maptalks 创建 [epsg](https://spatialreference.org/ref/epsg/) 形式的 CRS\n     * @english\n     * Create a [epsg](https://spatialreference.org/ref/epsg/) style CRS used by maptalks <br>\n     * @example\n     * var crs_wgs84 = CRS.createProj4(\"EPSG:4326\");\n     * @param code a proj4 projection string.\n     */\n    static fromProjectionCode(code: string): WithNull<CRS>;\n    /**\n     * 预定义的WGS84坐标参考系统（也称为EPSG:4326）。\n     * @english\n     * Predefined CRS of well-known WGS84 (aka EPSG:4326)\n     */\n    static WGS84: CRS;\n    /**\n     * CRS.WGS84 的别名\n     * @english\n     * Alias for CRS.WGS84\n     */\n    static EPSG4326: CRS;\n    /**\n     * 谷歌地图使用的投影坐标系统具有以下别名：'EPSG:3785'、'GOOGLE'、'EPSG:900913'。\n     * @english\n     * Projected Coordinate System used by google maps that has the following alias: 'EPSG:3785', 'GOOGLE', 'EPSG:900913'\n     */\n    static EPSG3857: CRS;\n    /**\n     * 一个代表简单的笛卡尔坐标系统。<br>\n     * 它直接映射x、y坐标，对于平面地图（例如室内地图、游戏地图）非常有用。\n     *\n     * @english\n     * A CRS represents a simple Cartesian coordinate system. <br>\n     * Maps x, y directly, is useful for maps of flat surfaces (e.g. indoor maps, game maps).\n     */\n    static IDENTITY: CRS;\n    /**\n     * 中国官方坐标系统（即EPSG:4490），在大多数情况下，可以认为与WGS84相同。\n     *\n     * @english\n     * Official coordinate system in China (aka EPSG:4490), in most cases, it can be considered the same with WGS84.\n     * @see  [7408](http://spatialreference.org/ref/sr-org/7408/)\n     */\n    static CGCS2000: CRS;\n    /**\n     * CRS.CGCS2000 的别名\n     *\n     * @english\n     * Alias for CRS.CGCS2000\n     */\n    static EPSG4490: CRS;\n    /**\n     * 百度地图使用的投影坐标系统。\n     *\n     * @english\n     * Projection used by [Baidu Map](http://map.baidu.com), a popular web map service in China.\n     */\n    static BD09LL: CRS;\n    /**\n     * 中国的大多数在线地图服务中所使用一种加密的坐标参考系统（CRS）。\n     *\n     * @english\n     * A encrypted CRS usded in the most online map services in China.\n     * @see [Restrictions_on_geographic_data_in_China](https://en.wikipedia.org/wiki/Restrictions_on_geographic_data_in_China)\n     */\n    static GCJ02: CRS;\n}\nexport default CRS;\n"},{"path":"types/geo/Extent.d.ts","content":"import Coordinate, { CoordinateLike } from './Coordinate';\nimport Point from './Point';\nimport Size from './Size';\nimport type PointExtent from './PointExtent';\nimport type { WithNull } from '../types/typings';\nexport type Projection = any;\nexport type Position = Point | Coordinate;\nexport type ArrayExtent = [number, number, number, number];\nexport type JsonExtent = {\n    xmin: number;\n    xmax: number;\n    ymin: number;\n    ymax: number;\n};\nexport type ExtentLike = Extent | JsonExtent | ArrayExtent;\nexport interface Constructable<T> {\n    new (p1?: WithNull<ExtentLike>, p?: Projection): T;\n    new (p1: Position, p2: Position, p?: Projection): T;\n    new (p1: number, p2: number, p3: number, p4: number, p?: Projection): T;\n}\n/**\n * 表示地图上的边界框，即具有最小和最大坐标的矩形地理区域。 <br>\n * 有多种方法可以创建范围：\n *\n * @english\n *\n * Represent a bounding box on the map, a rectangular geographical area with minimum and maximum coordinates. <br>\n * There are serveral ways to create a extent:\n * @category basic types\n * @example\n *\n * ```ts\n * //with 4 numbers: xmin, ymin, xmax and ymax\n * var extent = new Extent(100, 10, 120, 20);\n *\n * //with 2 coordinates\n * var extent = new Extent(new Coordinate(100, 10), new Coordinate(120, 20));\n *\n * //with a json object containing xmin, ymin, xmax and ymax\n * var extent = new Extent({xmin : 100, ymin: 10, xmax: 120, ymax:20});\n *\n * var extent1 = new Extent(100, 10, 120, 20);\n * //with another extent\n * var extent2 = new Extent(extent1);\n * ```\n */\ndeclare class Extent {\n    _clazz: typeof Coordinate | typeof Point;\n    _dirty: boolean;\n    projection: any;\n    xmin: WithNull<number>;\n    xmax: WithNull<number>;\n    ymin: WithNull<number>;\n    ymax: WithNull<number>;\n    pxmin: number;\n    pxmax: number;\n    pymin: number;\n    pymax: number;\n    left?: number;\n    right?: number;\n    top?: number;\n    bottom?: number;\n    constructor(p1?: WithNull<ExtentLike>, p?: Projection);\n    constructor(p1: Position, p2: Position, p?: Projection);\n    constructor(p1: number, p2: number, p3: number, p4: number, p?: Projection);\n    _initialize(p1: WithNull<ExtentLike>): void;\n    _initialize(p1: Position, p2: Position): void;\n    _initialize(p1: number, p2: number, p3: number, p4: number): void;\n    /**\n     * 与坐标或点相加, 会改变原数据\n     *\n     * @english\n     *\n     * Add the extent with a coordinate or a point.\n     * @returns a new extent\n     * @param p\n     */\n    _add(p: Extent): this;\n    _add(p: PointExtent): this;\n    _add(p: Position): this;\n    _add(p: number[]): this;\n    /**\n     * 与坐标或点相加, 返回一个新的 extent\n     *\n     * @english\n     *\n     * Add the extent with a coordinate or a point.\n     * @returns a new extent\n     * @param p\n     */\n    add(p: Extent): this;\n    add(p: PointExtent): this;\n    add(p: Position): this;\n    add(p: number[]): this;\n    /**\n     * 缩放当前 extent\n     *\n     * @english\n     *\n     * scale extent\n     *\n     * @param s\n     */\n    _scale(s: number): this;\n    /**\n     * 当前范围减去 coordinate、point 或者 extent（改变原数据）\n     *\n     * @english\n     *\n     * Substract the extent with a coordinate or a point.\n     * @param p\n     */\n    _sub(p: [number, number]): this;\n    _sub(p: Position): this;\n    _sub(p: Extent | PointExtent): this;\n    /**\n     * _sub 的别名\n     *\n     * @english\n     *\n     * Alias for _sub\n     * @param p\n     */\n    _substract(p: [number, number]): this;\n    _substract(p: Position): this;\n    _substract(p: Extent | PointExtent): this;\n    /**\n     * 当前范围减去 coordinate 或者 point\n     *\n     * @english\n     *\n     * Substract the extent with a coordinate or a point.\n     * @returns a new extent\n     * @param p\n     */\n    sub(p: [number, number]): this;\n    sub(p: Position): this;\n    sub(p: Extent | PointExtent): this;\n    /**\n     * sub 的别名\n     *\n     * @english\n     *\n     * Alias for sub\n     * @returns a new extent\n     * @param p\n     */\n    substract(p: [number, number]): this;\n    substract(p: Position): this;\n    substract(p: Extent | PointExtent): this;\n    /**\n     * 对 Extent 边界值进行四舍五入，返回一个新的 Extent\n     *\n     * @english\n     *\n     * Round the extent\n     * @returns rounded extent\n     */\n    round(): PointExtent | Extent;\n    /**\n     * 对当前 Extent 边界值进行四舍五入\n     *\n     * @english\n     *\n     * Round the extent\n     * @returns rounded extent\n     */\n    _round(): this;\n    /**\n     * 获取 Extent 的最小点\n     *\n     * @english\n     * Get the minimum point\n     * @params [out=undefined] - optional point to receive result\n     */\n    getMin(out?: Point): Point;\n    getMin(out?: Coordinate): Coordinate;\n    /**\n     * 获取 Extent 的最大点\n     *\n     * @english\n     * Get the maximum point\n     * @params [out=undefined] - optional point to receive result\n     */\n    getMax(out?: Point): Point;\n    getMax(out?: Coordinate): Coordinate;\n    /**\n     * 获取 Extent 的中心点\n     *\n     * @english\n     * Get center of the extent.\n     * @params [out=undefined] - optional point to receive result\n     */\n    getCenter(out?: Position): Position;\n    /**\n     * 检查 Extent 是否有效\n     *\n     * @english\n     * Whether the extent is valid\n     * @protected\n     */\n    isValid(): boolean;\n    /**\n     * 与另一个 extent 进行比较它们是否相等\n     *\n     * @english\n     *\n     * Compare with another extent to see whether they are equal.\n     * @param ext2 - extent to compare\n     */\n    equals(ext2: Extent | PointExtent): boolean;\n    /**\n     * 是否与另一个范围相交\n     * @english\n     *\n     * Whether it intersects with another extent\n     * @param ext2 - another extent\n     */\n    intersects(ext2: Extent | PointExtent): boolean;\n    /**\n     * 判断当前 extent 是否在其他 extent 范围内\n     * @english\n     *\n     * Whether the extent is within another extent\n     * @param extent - another extent\n     */\n    within(extent: Extent | PointExtent): boolean;\n    /**\n     * 该范围是否包含输入点\n     * @english\n     * Whether the extent contains the input point.\n     * @param c - input point\n     */\n    contains(c: CoordinateLike): boolean;\n    /**\n     * 获取Extent的宽度\n     *\n     * @english\n     * Get the width of the Extent\n     */\n    getWidth(): number;\n    /**\n     * 获取Extent的高度\n     *\n     * @english\n     * Get the height of the Extent\n     */\n    getHeight(): number;\n    /**\n     * 获取Extent的大小 - 高度和宽度构造的 Size 对象\n     *\n     * @english\n     * Get size of the Extent\n     */\n    getSize(): Size;\n    /**\n     * 设置 extent 的边界值\n     *\n     * @english\n     *\n     * set extent value\n     *\n     * @param xmin\n     * @param ymin\n     * @param xmax\n     * @param ymax\n     */\n    set(xmin: WithNull<number>, ymin: WithNull<number>, xmax: WithNull<number>, ymax: WithNull<number>): this;\n    __combine(extent: Position | Extent | PointExtent): number[];\n    /**\n     * 与其他 extent 合并\n     * @english\n     * Combine it with another extent to a larger extent.\n     * @param extent - extent/coordinate/point to combine into\n     * @returns extent combined\n     */\n    _combine(extent: Position | Extent | PointExtent): this;\n    /**\n     * 与其他 extent 合并到一个更大的 extent，返回一个新 extent\n     * @english\n     * Combine it with another extent to a larger extent.\n     * @param extent - extent/coordinate/point to combine into\n     * @returns extent combined\n     */\n    combine(extent: Position | Extent | PointExtent): any;\n    /**\n     * 获取当前 extent 与另一个 extent 的交集范围\n     *\n     * @english\n     *\n     * Gets the intersection extent of this and another extent.\n     * @param extent - another extent\n     * @returns intersection extent\n     */\n    intersection(extent: Extent | PointExtent): any;\n    /**\n     * 扩大 extent，返回一个新 Extent\n     * @english\n     *\n     * Expand the extent by distance\n     * @param distance  - distance to expand\n     * @returns a new extent expanded from\n     */\n    expand(distance: number | Size): PointExtent | Extent;\n    /**\n     * 扩大 extent\n     * @english\n     * Expand the extent by distance\n     * @param distance  - distance to expand\n     */\n    _expand(distance: number | Size): this;\n    /**\n     * 获取 extent 的 JSON 对象。\n     *\n     * @english\n     * Get extent's JSON object.\n     * @returns jsonObject\n     * @example\n     *\n     * ```ts\n     * // {xmin : 100, ymin: 10, xmax: 120, ymax:20}\n     * var json = extent.toJSON();\n     * ```\n     */\n    toJSON(): JsonExtent;\n    /**\n     * 获取extent矩形区域的坐标数组，包含5个坐标，第一个坐标与最后一个坐标相等。\n     * @english\n     * Get a coordinate array of extent's rectangle area, containing 5 coordinates in which the first equals with the last.\n     * @returns coordinates array\n     */\n    toArray(out?: Position[]): Position[];\n    /**\n     * 获取 extent 的 xmin、ymin、xmax、ymax 组成的字符串\n     *\n     * @english\n     *\n     * Get the string consisting of xmin, ymin, xmax, and ymax of extent\n     */\n    toString(): string;\n    /**\n     * 复制 extent\n     *\n     * @english\n     *\n     * Get a copy of the extent.\n     * @returns copy\n     */\n    copy(): PointExtent | Extent;\n    /**\n     * 转换到新的 extent\n     *\n     * @english\n     *\n     * Convert to a new extent\n     * @param fn convert function on each point\n     * @param out temp out\n     */\n    convertTo(fn: (p: Point) => Point, out?: Extent | PointExtent): Extent | PointExtent;\n    convertTo(fn: (p: Coordinate) => Coordinate, out?: Extent | PointExtent): Extent | PointExtent;\n    /**\n     * 计算给定 Extent 的投影范围\n     *\n     * @english\n     *\n     * Calculate the projected range of the given Extent\n     * @param ext extent\n     */\n    _project(ext: Extent | PointExtent): void;\n}\nexport default Extent;\n"},{"path":"types/geo/index.d.ts","content":"export { default as Coordinate } from './Coordinate';\nexport { default as CRS } from './CRS';\nexport { default as Extent } from './Extent';\nexport { default as Point } from './Point';\nexport { default as PointExtent } from './PointExtent';\nexport { default as Size } from './Size';\nexport { default as Transformation } from './transformation/Transformation';\nimport * as projection from './projection';\nimport * as measurer from './measurer';\nexport { projection, measurer };\n"},{"path":"types/geo/measurer/Common.d.ts","content":"import Coordinate from '../Coordinate';\ndeclare const common: {\n    /**\n     * 测量两点之间的距离\n     *\n     * @english\n     * Measure length between coordinate c1 and coordinate c2\n     * @param c1 coordinate\n     * @param c2 coordinate\n     * @returns length\n     */\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport type CommonMeasurer = typeof common;\n/**\n * 这提供了用于通用测量器的方法。 它是一个 mixin，不适合直接使用。\n * @english\n * This provides methods used for common measurer. It's a mixin and not meant to be used directly.\n * @mixin Common\n * @group measurer\n * @protected\n */\nexport default common;\n"},{"path":"types/geo/measurer/Identity.d.ts","content":"import Coordinate, { CoordinateJson } from '../Coordinate';\nimport type { WithNull } from '../../types/typings';\ndeclare const extended: {\n    /**\n     * the code of the measurer\n     */\n    measure: string;\n    /**\n     * 计算两个坐标之间的距离\n     *\n     * @english\n     * Measure the length between 2 coordinates.\n     * @param c1\n     * @param c2\n     */\n    measureLenBetween: (c1: Coordinate | CoordinateJson, c2: Coordinate | CoordinateJson) => number;\n    /**\n     * 测量给定闭合坐标的面积\n     *\n     * @english\n     * Measure the area closed by the given coordinates.\n     * @param coordinates\n     */\n    measureArea: (coordinates: (Coordinate | CoordinateJson)[]) => number;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c\n     * @param xDist\n     * @param yDist\n     * @param out\n     */\n    locate: (c: Coordinate | CoordinateJson, xDist: number, yDist: number, out?: Coordinate) => any;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标（这是一个私有方法）\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c     - source coordinate\n     * @param xDist     - x-axis distance\n     * @param yDist     - y-axis distance\n     * @private\n     */\n    _locate: (c: Coordinate, xDist: number, yDist: number) => WithNull<Coordinate>;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     *\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     */\n    rotate: (c: Coordinate | CoordinateJson, pivot: Coordinate, angle: number) => any;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     *\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     * @private\n     */\n    _rotate: (c: Coordinate, pivot: Coordinate, angle: number) => Coordinate;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport type IdentityMeasurerType = typeof extended;\n/**\n * Identity 的measurer，适用于笛卡尔坐标系\n * @english\n * Identity measurer, a measurer for Cartesian coordinate system.\n *\n * @category geo\n * @protected\n * @group measurer\n * @module Identity\n * {@inheritDoc measurer.Common}\n */\nexport default extended;\n"},{"path":"types/geo/measurer/index.d.ts","content":"/** @namespace measurer */\nimport Identity, { type IdentityMeasurerType } from './Identity';\nimport { type WGS84SphereType, type BaiduSphereType } from './Sphere';\nexport { Identity, IdentityMeasurerType };\nexport * from './Sphere';\n/**\n * 默认 measurer, [WGS84Sphere]{@link WGS84Sphere}\n * @english\n * Default measurer, [WGS84Sphere]{@link WGS84Sphere}\n *\n * @category geo\n * @protected\n * @group measurer\n * @module DEFAULT\n * {@inheritDoc measurer.WGS84Sphere}\n */\nexport declare const DEFAULT: {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n    };\n    measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n    measureArea(coordinates: import(\"src\").Coordinate[]): number;\n    _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n    _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n};\n/**\n * 带有测量功能的方法，不能直接初始化。\n * Measurer提供了地理计算的方法，例如长度和面积测量等。\n *\n * @english\n * Utilities with measurers. It is static and should not be initiated.<br>\n * Measurer provides methods for geographical computations such as length and area measuring, etc.\n * @module Measurer\n * @group measurer\n * @category geo\n */\nexport declare const Measurer: {\n    /**\n     * 获取量测计算的实例\n     *\n     * @english\n     * Get a measurer instance.\n     * @param name - code of the measurer: 'EPSG:4326', 'Identity', 'BAIDU'\n     * @returns a measurer object\n     * @function Measurer.getInstance\n     */\n    getInstance(name?: string): IdentityMeasurerType | WGS84SphereType | BaiduSphereType;\n};\n"},{"path":"types/geo/measurer/Sphere.d.ts","content":"import Coordinate, { type CoordinateJson } from '../Coordinate';\nimport type { WithNull } from '../../types/typings';\ntype CoordsLike = Coordinate | CoordinateJson;\n/**\n * 具有 Sphere 通用测量方法的辅助类。\n *\n * @english\n * A helper class with common measure methods for Sphere.\n * @group measurer\n * @private\n */\ndeclare class Sphere {\n    radius: number;\n    /**\n     * @param radius Sphere's radius\n     */\n    constructor(radius: number);\n    /**\n     * 计算两个坐标之间的距离\n     *\n     * @english\n     * Measure the length between 2 coordinates.\n     * @param c1\n     * @param c2\n     */\n    measureLenBetween(c1: CoordsLike, c2: CoordsLike): number;\n    /**\n     * 测量给定闭合坐标的面积\n     *\n     * @english\n     * Measure the area closed by the given coordinates.\n     * @param coordinates\n     */\n    measureArea(coordinates: CoordsLike[]): number;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c\n     * @param xDist\n     * @param yDist\n     * @param out\n     */\n    locate(c: CoordsLike, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c     - source coordinate\n     * @param xDist     - x-axis distance\n     * @param yDist     - y-axis distance\n     * @private\n     */\n    _locate(c: Coordinate, xDist: number, yDist: number): WithNull<Coordinate>;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     */\n    rotate(c: CoordsLike, pivot: Coordinate, angle: number): Coordinate;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     * @private\n     */\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n}\n/**\n * WGS84 椭球球体\n * @english\n * WGS84 Sphere measurer.\n * @category geo\n * @protected\n * @group measurer\n * @module WGS84Sphere\n * {@inheritDoc measurer.Common}\n */\nexport declare const WGS84Sphere: {\n    measure: string;\n    sphere: Sphere;\n    /**\n     * 计算两个坐标之间的距离\n     *\n     * @english\n     * Measure the length between 2 coordinates.\n     * @param c1\n     * @param c2\n     */\n    measureLenBetween(c1: CoordsLike, c2: CoordsLike): number;\n    /**\n     * 计算给定闭合坐标的面积\n     *\n     * @english\n     * Measure the area closed by the given coordinates.\n     * @param coordinates\n     */\n    measureArea(coordinates: Coordinate[]): number;\n    _locate(c: CoordsLike, xDist: number, yDist: number): any;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标。\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c - source coordinate\n     * @param xDist - x-axis distance\n     * @param yDist - y-axis distance\n     * @param out - out\n     */\n    locate(c: CoordsLike, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     */\n    rotate(c: CoordsLike, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\n/**\n * 百度地图所使用的椭球体\n *\n * @english\n * Baidu sphere measurer\n * @category geo\n * @protected\n * @group measurer\n * @module BaiduSphere\n * {@inheritDoc measurer.Common}\n */\nexport declare const BaiduSphere: {\n    measure: string;\n    sphere: Sphere;\n    /**\n     * 计算两个坐标之间的距离\n     *\n     * @english\n     * Measure the length between 2 coordinates.\n     * @param c1\n     * @param c2\n     */\n    measureLenBetween(c1: CoordsLike, c2: CoordsLike): number;\n    /**\n     * 计算给定闭合坐标的面积\n     *\n     * @english\n     * Measure the area closed by the given coordinates.\n     * @param coordinates\n     */\n    measureArea(coordinates: CoordsLike[]): number;\n    _locate(c: Coordinate, xDist: number, yDist: number): any;\n    /**\n     * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标。\n     * @english\n     * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.\n     * @param c - source coordinate\n     * @param xDist - x-axis distance\n     * @param yDist - y-axis distance\n     * @param out - out\n     */\n    locate(c: CoordsLike, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    /**\n     * 绕枢轴旋转给定角度的坐标\n     * @english\n     * Rotate a coordinate of given angle around pivot\n     * @param c  - source coordinate\n     * @param pivot - pivot\n     * @param angle - angle in degree\n     */\n    rotate(c: CoordsLike, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport type BaiduSphereType = typeof BaiduSphere;\nexport type WGS84SphereType = typeof WGS84Sphere;\nexport {};\n"},{"path":"types/geo/Point.d.ts","content":"import Position from './Position';\nexport type PointJson = {\n    x: number;\n    y: number;\n    z?: number;\n};\nexport type PointArray = [number, number] | [number, number, number];\nexport type PointLike = Point | PointJson | PointArray;\n/**\n * 2D 点实现\n * @english\n * Represents a 2d point.<br>\n * Can be created in serveral ways:\n *\n * @example\n *\n * ```ts\n *\n * var point = new Point(1000, 1000);\n *\n * var point = new Point([1000, 1000]);\n *\n * var point = new Point({ x:1000, y:1000 });\n * ```\n *\n * @category basic types\n */\ndeclare class Point extends Position {\n    /**\n     * 使用差值与另一个点进行比较，判断是否临近\n     *\n     * @english\n     *\n     * Compare with another point with a delta\n     * @param p\n     * @param delta\n     */\n    closeTo(p: Point, delta?: number): boolean;\n    /**\n     * 计算对应的单位向量\n     * 这意味着计算点到[0, 0]坐标的距离将等于1，并且从计算点到[0, 0]坐标的角度与之前相同\n     * @english\n     *\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @returns unit vector point\n     */\n    unit(): Point;\n    _unit(): this;\n    /**\n     * 计算一个垂直点，其中新的y坐标是旧的x坐标，而新的x坐标是旧的y坐标乘以-1。\n     *\n     * @english\n     *\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @returns perpendicular point\n     */\n    perp(): Point;\n    _perp(): this;\n    /**\n     * 获取这个点与另一个点之间的角度，单位为弧度\n     *\n     * @english\n     *\n     * Get the angle between this point and another point, in radians\n     * from mapbox/point-geometry\n     * @param b - the other point\n     * @returns angle\n     */\n    angleWith(b: Point): number;\n    /**\n     * 找到两个向量之间的角度\n     *\n     * @english\n     *\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin(θ) for θ.\n     * from mapbox/point-geometry\n     *\n     * @param x the x-coordinate\n     * @param y the y-coordinate\n     * @returns the angle in radians\n     */\n    angleWithSep(x: number, y: number): number;\n    _rotate(angle: number): this;\n    /**\n     * 围绕0,0原点旋转这个点，旋转角度a以弧度为单位\n     *\n     * @english\n     *\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * from mapbox/point-geometry\n     *\n     * @param a angle to rotate around, in radians\n     * @returns output point\n     */\n    rotate(a: number): Point;\n    /**\n     * 返回该点绝对值的 `Point` 对象（不会改变原始数据）\n     *\n     * @english\n     *\n     * Return abs value of the point\n     * @returns abs point\n     */\n    abs(): Point;\n    /**\n     * 类似于数学中的四舍五入，对点的 x 和 y 坐标进行舍入，返回一个新 Point\n     *\n     * @english\n     *\n     * Like math.round, rounding the point's xy.\n     * @returns rounded point\n     */\n    round(): Point;\n    /**\n     * 对点的 x 和 y 坐标向上取整，返回一个新 Point\n     *\n     * @english\n     *\n     * Like math.ceil, ceil the point's xy.\n     * @returns ceiled point\n     */\n    ceil(): Point;\n    /**\n     * 对点的 x 和 y 坐标向下取整，返回一个新 Point\n     *\n     * @english\n     *\n     * Like math.floor, floor the point's xy.\n     * @returns floored point\n     */\n    floor(): Point;\n    /**\n     * 返回当前点的 copy\n     *\n     * @english\n     *\n     * Returns a copy of the point\n     * @returns copy\n     */\n    copy(): Point;\n    /**\n     * 坐标数字保留指定位数的小数\n     *\n     * @english\n     *\n     * Formats point number using fixed-point notation.\n     * @param n - The number of digits to appear after the decimal point\n     * @returns fixed point\n     */\n    toFixed(n: number): Point;\n    /**\n     * 与传入坐标相加，返回一个新 Point\n     *\n     * @english\n     *\n     * Returns the result of addition of another coordinate.\n     * @param x - point to add\n     * @returns result\n     */\n    add(x: PointLike): Point;\n    /**\n     * 与传入坐标相加，返回一个新 Point\n     *\n     * @english\n     *\n     * Returns the result of addition of another coordinate.\n     * @param x - point to add\n     * @param y - point to add\n     * @returns result\n     */\n    add(x: number, y: number): Point;\n    /**\n     * 与传入坐标相减，返回一个新 Point。\n     *\n     * @english\n     *\n     * Returns the result of subtraction of another point.\n     * @param x - point to add\n     * @returns result\n     */\n    sub(x: PointLike): Point;\n    /**\n     * 与传入坐标相减，返回一个新 Point。\n     *\n     * @english\n     *\n     * Returns the result of subtraction of another point.\n     * @param x - point to add\n     * @param y - point to add\n     * @returns result\n     */\n    sub(x: number, y: number): Point;\n    /**\n     * Returns the result of multiplication of the current coordinate by the given number.\n     * @param ratio - ratio to multi\n     * @returns result\n     */\n    multi(ratio: number): Point;\n    /**\n     * 与另外一个 point 进行比较，以查看它们是否相等\n     *\n     * @english\n     *\n     * Compare with another point to see whether they are equal.\n     * @param c - point to compare\n     */\n    equals(c: Point): boolean;\n}\nexport default Point;\n"},{"path":"types/geo/PointExtent.d.ts","content":"import Extent, { ExtentLike, Position, Projection } from './Extent';\nimport type { WithNull } from '../types/typings';\n/**\n * 表示二维表面上的边界框，即具有最小点和最大点的矩形区域。 <br>\n * 有多种方法可以创建 PointExtent：\n *\n * @english\n * Represent a bounding box on 2d surface , a rectangular area with minimum and maximum points. <br>\n * There are serveral ways to create a PointExtent:\n * @category basic types\n * @example\n *\n * ```ts\n * // with 4 numbers\n * var extent = new PointExtent(100, 10, 120, 20);\n *\n * // with 2 points\n * var extent = new PointExtent(new Point(100, 10), new Point(120, 20));\n *\n * // with a json object containing xmin, ymin, xmax and ymax\n * var extent = new PointExtent({xmin : 100, ymin: 10, xmax: 120, ymax:20});\n *\n * var extent1 = new PointExtent(100, 10, 120, 20);\n * // with another extent\n * var extent2 = new PointExtent(extent1);\n * ```\n */\ndeclare class PointExtent extends Extent {\n    constructor(p1?: WithNull<ExtentLike>, p?: Projection);\n    constructor(p1: Position, p2: Position, p?: Projection);\n    constructor(p1: number, p2: number, p3: number, p4: number, p?: Projection);\n}\nexport default PointExtent;\n"},{"path":"types/geo/Position.d.ts","content":"import type Point from './Point';\nimport type { PointArray, PointJson } from './Point';\nimport type Coordinate from './Coordinate';\nimport type { CoordinateArray, CoordinateJson } from './Coordinate';\nimport type { WithUndef } from '../types/typings';\ntype NumberAble = number | string;\nexport type PositionJson<T> = {\n    x: T;\n    y: T;\n    z?: T;\n};\nexport type PositionArray<T> = [T, T] | [T, T, T];\nexport type PositionLike = Point | Coordinate | PositionJson<NumberAble> | PointJson | CoordinateJson;\n/**\n * `Point` 和 `Coordinate` 的抽象类\n * @english\n *\n * Abstract parent class for Point and Coordinate\n * @category basic types\n */\ndeclare abstract class Position {\n    x: number;\n    y: number;\n    z: WithUndef<number>;\n    constructor(x: PositionLike);\n    constructor(x: PositionArray<NumberAble>);\n    constructor(x: PointArray);\n    constructor(x: CoordinateArray);\n    constructor(x: NumberAble, y: NumberAble, z?: NumberAble);\n    /**\n     * 设置点或坐标的 x、y 值\n     *\n     * @english\n     *\n     * Set point or coordinate's x, y value\n     * @param x - x value\n     * @param y - y value\n     * @param z - z value\n     */\n    set(x: number, y: number, z?: number): this;\n    abstract abs(): Point | Coordinate;\n    /**\n     * 修改原数据的绝对值\n     *\n     * @english\n     * destructive abs\n     */\n    _abs(): this;\n    /**\n     * 对原数据的 x 和 y 四舍五入\n     *\n     * @english\n     * destructive round\n     */\n    _round(): this;\n    abstract round(): Point | Coordinate;\n    /**\n     * 对原数据的 x 和 y 进行向上取整\n     *\n     * @english\n     * destructive ceil\n     */\n    _ceil(): this;\n    abstract ceil(): Point | Coordinate;\n    /**\n     * 返回当前点与给定点之间的距离\n     *\n     * @english\n     *\n     * Returns the distance between the current and the given point.\n     * @param  point - another point\n     * @returns distance\n     */\n    distanceTo(point: Point | Coordinate): number;\n    /**\n     * 返回该点的大小：这是从 0,0 坐标到该点的 x 和 y 坐标的欧几里得距离\n     *\n     * @english\n     *\n     * Return the magnitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @returns magnitude\n     */\n    mag(): number;\n    /**\n     * 对原数据的 x 和 y 进行向下取整\n     *\n     * @english\n     * destructive floor\n     */\n    _floor(): this;\n    abstract floor(): Point | Coordinate;\n    abstract copy(): Point | Coordinate;\n    _add(x: PositionLike): this;\n    _add(x: number, y: number): this;\n    abstract add(x: any, y?: number): Point | Coordinate;\n    _sub(x: PositionLike): this;\n    _sub(x: number, y: number): this;\n    /**\n     * `_sub` 方法的别名\n     *\n     * @english\n     *\n     * Alias for _sub\n     *\n     * @param x\n     * @param y\n     */\n    _substract(x: PositionLike | number, y?: number): this;\n    abstract sub(x: any, y?: number): Point | Coordinate;\n    /**\n     * `sub` 方法的别名。\n     *\n     * @english\n     *\n     * Alias for sub\n     * @returns result\n     * @param x\n     * @param y\n     */\n    substract(x: PositionLike | number, y?: number): Coordinate | Point;\n    abstract multi(ratio: number): Point | Coordinate;\n    _multi(ratio: number): this;\n    /**\n     * 返回当前坐标除以给定数字\n     *\n     * @english\n     *\n     * Returns the result of division of the current point by the given number.\n     * @param n - number to div\n     * @returns result\n     */\n    div(n: number): Coordinate | Point;\n    /**\n     * 除以给定的数字\n     *\n     * @english\n     *\n     * div by the given number\n     * @param n\n     */\n    _div(n: number): this;\n    abstract equals(c: Point | Coordinate): boolean;\n    /**\n     * `Coordinate` / `Point`是否是 `NaN`\n     *\n     * @english\n     *\n     * Whether the coordinate is NaN\n     * @returns\n     */\n    _isNaN(): boolean;\n    /**\n     * `Coordinate` / `Point`是否为零\n     *\n     * @english\n     *\n     * Whether the coordinate/point is zero\n     */\n    isZero(): boolean;\n    /**\n     * 转换为数组形式\n     *\n     * @english\n     *\n     * Convert to a number array [x, y]\n     * @returns number array\n     */\n    toArray(): PositionArray<number>;\n    /**\n     * 坐标数字保留指定位数的小数\n     *\n     * @english\n     *\n     * Formats coordinate number using fixed-point notation.\n     * @param n - The number of digits to appear after the decimal point\n     * @returns fixed coordinate\n     */\n    abstract toFixed(n: number): Point | Coordinate;\n    /**\n     * 转换到 json 对象\n     *\n     * @english\n     * Convert to a json object {x : .., y : ..}\n     * @returns json\n     */\n    toJSON(): PositionJson<number>;\n}\nexport default Position;\n"},{"path":"types/geo/projection/etmerc.d.ts","content":"declare function pj_etmerc(P: any): void;\nexport default pj_etmerc;\n"},{"path":"types/geo/projection/index.d.ts","content":"/** @namespace projection */\nimport EPSG3857, { type EPSG3857ProjectionType } from './Projection.EPSG3857';\nimport type { EPSG4326ProjectionType } from './Projection.EPSG4326';\nimport type { EPSG9807ProjectionType } from './Projection.EPSG9807';\nimport type { BAIDUProjectionType } from './Projection.Baidu';\nimport type { UTMProjectionType } from './Projection.UTM';\nimport type { IdentityProjectionType } from './Projection.IDENTITY';\nexport { default as EPSG4326, EPSG4326ProjectionType } from './Projection.EPSG4326';\nexport { default as EPSG9807, EPSG9807ProjectionParams, EPSG9807ProjectionType } from './Projection.EPSG9807';\nexport { default as UTM, UTMProjectionParams, UTMProjectionType } from './Projection.UTM';\nexport { default as BAIDU, BAIDUProjectionType } from './Projection.Baidu';\nexport { default as IDENTITY, IdentityProjectionType } from './Projection.IDENTITY';\nexport { EPSG3857, EPSG3857ProjectionType };\nexport { default as Common, CommonProjectionType } from './Projection';\nexport type ProjectionType = EPSG3857ProjectionType | EPSG4326ProjectionType | EPSG9807ProjectionType | BAIDUProjectionType | UTMProjectionType | IdentityProjectionType;\n/**\n * 默认投影, [EPSG3857]{@link projection.EPSG3857}\n * @english\n * Default projection, [EPSG3857]{@link projection.EPSG3857}\n *\n * @category geo\n * @protected\n * @group projection\n * @module DEFAULT\n * {@inheritDoc projection.EPSG3857}\n */\nexport declare const DEFAULT: {\n    code: string;\n    is(code: string): boolean;\n    project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n    unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n    wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    code: string;\n    rad: number;\n    metersPerDegree: number;\n    maxLatitude: number;\n    project: (lnglat: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n    unproject: (pLnglat: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n} & {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n    };\n    measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n    measureArea(coordinates: import(\"src\").Coordinate[]): number;\n    _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n    _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n};\n"},{"path":"types/geo/projection/Projection.Baidu.d.ts","content":"import { type CommonProjectionType } from './Projection';\nimport Coordinate from '../Coordinate';\nimport { BaiduSphereType } from '../measurer';\ndeclare const ProjectionMethods: {\n    EARTHRADIUS: number;\n    MCBAND: number[];\n    LLBAND: number[];\n    MC2LL: number[][];\n    LL2MC: number[][];\n    convertMC2LL: (cB: Coordinate, out?: Coordinate) => Coordinate;\n    convertLL2MC: (T: Coordinate, out?: Coordinate) => Coordinate;\n    convertor: (cC: Coordinate, cD: number, out?: Coordinate) => Coordinate;\n    toRadians: (T: number) => number;\n    toDegrees: (T: number) => number;\n    getRange: (cC: number, cB: number, T: number) => number;\n    getLoop: (cC: number, cB: number, T: number) => number;\n};\ndeclare const BAIDUProjection: {\n    /**\n     * \"BAIDU\", Code of the projection\n     * @constant\n     */\n    code: string;\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n};\nexport type BAIDUProjectionType = CommonProjectionType & typeof BAIDUProjection & BaiduSphereType & typeof ProjectionMethods;\n/**\n * 百度地图所使用的投影 [Baidu Map]{@link http://map.baidu.com}\n *\n * @english\n * Projection used by [Baidu Map]{@link http://map.baidu.com}\n *\n * @category geo\n * @protected\n * @group projection\n * @name BAIDU\n * {@inheritDoc projection.Common}\n * {@inheritDoc BaiduSphere}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    /**\n     * \"BAIDU\", Code of the projection\n     * @constant\n     */\n    code: string;\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n} & {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n        _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n    };\n    measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n    measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number;\n    _locate(c: Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n} & {\n    EARTHRADIUS: number;\n    MCBAND: number[];\n    LLBAND: number[];\n    MC2LL: number[][];\n    LL2MC: number[][];\n    convertMC2LL: (cB: Coordinate, out?: Coordinate) => Coordinate;\n    convertLL2MC: (T: Coordinate, out?: Coordinate) => Coordinate;\n    convertor: (cC: Coordinate, cD: number, out?: Coordinate) => Coordinate;\n    toRadians: (T: number) => number;\n    toDegrees: (T: number) => number;\n    getRange: (cC: number, cB: number, T: number) => number;\n    getLoop: (cC: number, cB: number, T: number) => number;\n};\nexport default _default;\n"},{"path":"types/geo/projection/Projection.d.ts","content":"import Coordinate from '../Coordinate';\nimport Extent from '../Extent';\ndeclare const CommonProjection: {\n    code: string;\n    is(code: string): boolean;\n    /**\n     * 将地理坐标投影到投影坐标（二维坐标）\n     * @english\n     * Project a geographical coordinate to a projected coordinate (2d coordinate)\n     * @param p - coordinate to project\n     * @function projection.Common.project\n     */\n    project(p: Coordinate): Coordinate;\n    /**\n     * 将投影坐标转到地理坐标（二维坐标）\n     *\n     * @english\n     * Unproject a projected coordinate to a geographical coordinate (2d coordinate)\n     * @param p - coordinate to project\n     * @function projection.Common.unproject\n     */\n    unproject(p: Coordinate): Coordinate;\n    /**\n     * 批量将地理坐标投影到投影坐标\n     *\n     * @english\n     * Project a group of geographical coordinates to projected coordinates.\n     * @param coordinates - coordinates to project\n     * @function projection.Common.projectCoords\n     */\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    /**\n     * 批量将投影坐标转到地理坐标\n     *\n     * @english\n     * Unproject a group of projected coordinates to geographical coordinates.\n     * @param projCoords - projected coordinates to unproject\n     * @function projection.Common.unprojectCoords\n     */\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    /**\n     * 投影是否为球面\n     *\n     * @english\n     * Whether the projection is spherical\n     */\n    isSphere(): boolean;\n    /**\n     * 判断传入的投影坐标是否超出椭球体范围\n     *\n     * @english\n     * If the projected coord out of the sphere\n     * @param pcoord projected coord\n     * @return {Boolean}\n     */\n    isOutSphere(pcoord: Coordinate): boolean;\n    /**\n     * 限制投影坐标在球体中\n     *\n     * @english\n     * Wrap the projected coord in the sphere\n     * @param pcoord projected coord\n     * @returns wrapped projected coord\n     */\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): Extent;\n};\nexport type CommonProjectionType = typeof CommonProjection;\n/**\n * 投影公共方法\n * @english\n * Common Methods of Projections.\n * @protected\n * @group projection\n * @namespace Common\n */\nexport default CommonProjection;\n"},{"path":"types/geo/projection/Projection.EPSG3857.d.ts","content":"import { type CommonProjectionType } from './Projection';\nimport Coordinate from '../Coordinate';\nimport { type WGS84SphereType } from '../measurer';\ndeclare const EPSG3857Projection: {\n    /**\n     * \"EPSG:3857\", Code of the projection\n     * @constant\n     */\n    code: string;\n    rad: number;\n    metersPerDegree: number;\n    maxLatitude: number;\n    project: (lnglat: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (pLnglat: Coordinate, out?: Coordinate) => Coordinate;\n};\nexport type EPSG3857ProjectionType = CommonProjectionType & typeof EPSG3857Projection & WGS84SphereType;\n/**\n * Google 地图或 OSM 地图使用的常规投影，又名墨卡托投影。<br>\n * 这是地图的默认投影。\n *\n * @english\n * Well-known projection used by Google maps or Open Street Maps, aka Mercator Projection.<br>\n * It is map's default projection.\n *\n * @category geo\n * @protected\n * @group projection\n * @name EPSG3857\n * {@inheritDoc projection.Common}\n * {@inheritDoc measurer.WGS84Sphere}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    /**\n     * \"EPSG:3857\", Code of the projection\n     * @constant\n     */\n    code: string;\n    rad: number;\n    metersPerDegree: number;\n    maxLatitude: number;\n    project: (lnglat: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (pLnglat: Coordinate, out?: Coordinate) => Coordinate;\n} & {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n        _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n    };\n    measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n    measureArea(coordinates: Coordinate[]): number;\n    _locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport default _default;\n"},{"path":"types/geo/projection/Projection.EPSG4326.d.ts","content":"import { type CommonProjectionType } from './Projection';\nimport Coordinate from '../Coordinate';\nimport { type WGS84SphereType } from '../measurer';\ndeclare const EPSG4326Projection: {\n    /**\n     * \"EPSG:4326\", Code of the projection\n     * @constant\n     */\n    code: string;\n    aliases: string[];\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n};\nexport type EPSG4326ProjectionType = CommonProjectionType & typeof EPSG4326Projection & WGS84SphereType;\n/**\n * GIS 中常见的 CRS。 使用简单的等距矩形投影\n *\n * @english\n * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\n *\n * @category geo\n * @protected\n * @group projection\n * @name EPSG4326\n * {@inheritDoc projection.Common}\n * {@inheritDoc measurer.WGS84Sphere}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    /**\n     * \"EPSG:4326\", Code of the projection\n     * @constant\n     */\n    code: string;\n    aliases: string[];\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n} & {\n    measure: string;\n    sphere: {\n        radius: number;\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n        _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n    };\n    measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n    measureArea(coordinates: Coordinate[]): number;\n    _locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number): any;\n    locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n    _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n    rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport default _default;\n"},{"path":"types/geo/projection/Projection.EPSG9807.d.ts","content":"import { type CommonProjectionType } from './Projection';\nimport Coordinate from '../Coordinate';\nexport interface EPSG9807ProjectionParams {\n    falseEasting: number;\n    falseNorthing: number;\n    scaleFactor: number;\n    centralMeridian: number;\n    latitudeOfOrigin: number;\n    startLongtitude: number;\n    startLatitude: number;\n}\ndeclare const EPSG9807Projection: {\n    code: string;\n    aliases: string[];\n    centralMeridian: number;\n    create(params: Partial<EPSG9807ProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: Coordinate): Coordinate;\n        unproject(p: Coordinate): Coordinate;\n        projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n        unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: Coordinate): boolean;\n        wrapCoord(pcoord: Coordinate): Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        /**\n         * \"EPSG:9807\", Code of the projection\n         * @type {String}\n         * @constant\n         */\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: Coordinate, out?: Coordinate) => Coordinate;\n        unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n            measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number; /**\n             * \"EPSG:9807\", Code of the projection\n             * @type {String}\n             * @constant\n             */\n            locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n            _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n            rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n            _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        };\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: Coordinate[]): number;\n        _locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: Coordinate, c2: Coordinate) => number;\n    };\n};\nexport type EPSG9807ProjectionType = CommonProjectionType & typeof EPSG9807Projection;\n/**\n * 横轴墨卡托投影\n *\n * @english\n * Traverse Mercator Projection\n *\n * @category geo\n * @protected\n * @group projection\n * @name EPSG9807\n * {@inheritDoc projection.Common}\n * {@inheritDoc measurer.WGS84Sphere}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    code: string;\n    aliases: string[];\n    centralMeridian: number;\n    create(params: Partial<EPSG9807ProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: Coordinate): Coordinate;\n        unproject(p: Coordinate): Coordinate;\n        projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n        unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: Coordinate): boolean;\n        wrapCoord(pcoord: Coordinate): Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        /**\n         * \"EPSG:9807\", Code of the projection\n         * @type {String}\n         * @constant\n         */\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: Coordinate, out?: Coordinate) => Coordinate;\n        unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n            measureArea(coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]): number; /**\n             * \"EPSG:9807\", Code of the projection\n             * @type {String}\n             * @constant\n             */\n            locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): Coordinate;\n            _locate(c: Coordinate, xDist: number, yDist: number): Coordinate;\n            rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): Coordinate;\n            _rotate(c: Coordinate, pivot: Coordinate, angle: number): Coordinate;\n        };\n        measureLenBetween(c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate): number;\n        measureArea(coordinates: Coordinate[]): number;\n        _locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate): any;\n        _rotate(c: Coordinate, pivot: Coordinate, angle: number): any;\n        rotate(c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: Coordinate, c2: Coordinate) => number;\n    };\n};\nexport default _default;\n"},{"path":"types/geo/projection/Projection.IDENTITY.d.ts","content":"import Coordinate from '../Coordinate';\nimport { type CommonProjectionType } from './Projection';\nimport { type IdentityMeasurerType } from '../measurer';\ndeclare const IdentityProjection: {\n    /**\n     * \"IDENTITY\", Code of the projection\n     * @constant\n     */\n    code: string;\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n};\nexport type IdentityProjectionType = CommonProjectionType & typeof IdentityProjection & IdentityMeasurerType;\n/**\n * 基于笛卡尔坐标系的投影。<br>\n * 该投影直接映射 x、y，常用于平面地图（例如室内地图、游戏地图）。\n *\n * @english\n * A projection based on Cartesian coordinate system.<br>\n * This projection maps x, y directly, it is useful for maps of flat surfaces (e.g. indoor maps, game maps).\n *\n * @category geo\n * @protected\n * @group projection\n * @name IDENTITY\n * {@inheritDoc projection.Common}\n * {@inheritDoc measurer.Identity}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: Coordinate): Coordinate;\n    unproject(p: Coordinate): Coordinate;\n    projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: Coordinate): boolean;\n    wrapCoord(pcoord: Coordinate): Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    /**\n     * \"IDENTITY\", Code of the projection\n     * @constant\n     */\n    code: string;\n    project: (p: Coordinate, out?: Coordinate) => Coordinate;\n    unproject: (p: Coordinate, out?: Coordinate) => Coordinate;\n} & {\n    measure: string;\n    measureLenBetween: (c1: import(\"../Coordinate\").CoordinateJson | Coordinate, c2: import(\"../Coordinate\").CoordinateJson | Coordinate) => number;\n    measureArea: (coordinates: (import(\"../Coordinate\").CoordinateJson | Coordinate)[]) => number;\n    locate: (c: import(\"../Coordinate\").CoordinateJson | Coordinate, xDist: number, yDist: number, out?: Coordinate) => any;\n    _locate: (c: Coordinate, xDist: number, yDist: number) => Coordinate;\n    rotate: (c: import(\"../Coordinate\").CoordinateJson | Coordinate, pivot: Coordinate, angle: number) => any;\n    _rotate: (c: Coordinate, pivot: Coordinate, angle: number) => Coordinate;\n} & {\n    measureLength: (c1: Coordinate, c2: Coordinate) => number;\n};\nexport default _default;\n"},{"path":"types/geo/projection/Projection.UTM.d.ts","content":"import { type EPSG9807ProjectionType } from './Projection.EPSG9807';\nexport interface UTMProjectionParams {\n    zone: string;\n    south: boolean;\n}\ndeclare const UTMProjection: {\n    /**\n     * \"EPSG:4490\", Code of the projection\n     * @constant\n     */\n    code: string;\n    aliases: any[];\n    create(params: Partial<UTMProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n        wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n        unproject: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n            measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n            locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n            _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n            rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n            _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        };\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: import(\"src\").Coordinate[]): number;\n        _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n    };\n};\nexport type UTMProjectionType = EPSG9807ProjectionType & typeof UTMProjection;\n/**\n * Universal Traverse Mercator projection\n *\n * @class\n * @category geo\n * @protected\n * @memberOf projection\n * @name EPSG4490\n * {@inheritDoc projection.EPSG9807}\n */\ndeclare const _default: {\n    code: string;\n    is(code: string): boolean;\n    project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n    unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n    isSphere(): boolean;\n    isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n    wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n    getCircum(): Record<string, number>;\n    getSphereExtent(): import(\"src\").Extent;\n} & {\n    code: string;\n    aliases: string[];\n    centralMeridian: number;\n    create(params: Partial<import(\"./Projection.EPSG9807\").EPSG9807ProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n        wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n        unproject: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n            measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n            locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n            _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n            rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n            _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        };\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: import(\"src\").Coordinate[]): number;\n        _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n    };\n} & {\n    /**\n     * \"EPSG:4490\", Code of the projection\n     * @constant\n     */\n    code: string;\n    aliases: any[];\n    create(params: Partial<UTMProjectionParams>): {\n        code: string;\n        is(code: string): boolean;\n        project(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        unproject(p: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        projectCoords(coordinates: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][], antiMeridian?: boolean): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        unprojectCoords(projCoords: import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][]): import(\"src\").Coordinate[] | import(\"src\").Coordinate[][] | import(\"src\").Coordinate[][][];\n        isSphere(): boolean;\n        isOutSphere(pcoord: import(\"src\").Coordinate): boolean;\n        wrapCoord(pcoord: import(\"src\").Coordinate): import(\"src\").Coordinate;\n        getCircum(): Record<string, number>;\n        getSphereExtent(): import(\"src\").Extent;\n    } & {\n        code: string;\n        aliases: string[];\n        centralMeridian: number;\n        project: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n        unproject: (p: import(\"src\").Coordinate, out?: import(\"src\").Coordinate) => import(\"src\").Coordinate;\n    } & {\n        measure: string;\n        sphere: {\n            radius: number;\n            measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n            measureArea(coordinates: (import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate)[]): number;\n            locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): import(\"src\").Coordinate;\n            _locate(c: import(\"src\").Coordinate, xDist: number, yDist: number): import(\"src\").Coordinate;\n            rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n            _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): import(\"src\").Coordinate;\n        };\n        measureLenBetween(c1: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, c2: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate): number;\n        measureArea(coordinates: import(\"src\").Coordinate[]): number;\n        _locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number): any;\n        locate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, xDist: number, yDist: number, out?: import(\"src\").Coordinate): any;\n        _rotate(c: import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n        rotate(c: import(\"src/geo/Coordinate\").CoordinateJson | import(\"src\").Coordinate, pivot: import(\"src\").Coordinate, angle: number): any;\n    } & {\n        measureLength: (c1: import(\"src\").Coordinate, c2: import(\"src\").Coordinate) => number;\n    };\n};\nexport default _default;\n"},{"path":"types/geo/Size.d.ts","content":"import Point from './Point';\nexport type JsonSize = {\n    width: number;\n    height: number;\n};\nexport type ArraySize = [number, number];\n/**\n * A {@link Size} object\n *\n * @category basic types\n *\n * @example\n * ```ts\n * let size1 = new Size(100, 100);\n * let size2 = [100，100];\n * let size3 = { width: 100, height: 100 };\n * ```\n */\nexport type SizeLike = Size | JsonSize;\n/**\n * 表示一个大小的实现类\n *\n * @english\n * Represents a size.\n * @category basic types\n *\n * @example\n *\n * ```ts\n * const a1 = new Size(1, 2);\n * const a2 = new Size([1, 2]);\n * const a3 = new Size({ width: 1, height: 2 });\n * const a4 = new Size(a3);\n * ```\n */\ndeclare class Size {\n    width: number;\n    height: number;\n    /**\n     * @param width - width value\n     */\n    constructor(width: SizeLike);\n    /**\n     * @param width - width value\n     */\n    constructor(width: ArraySize);\n    /**\n     * @param width - width value\n     * @param height - height value\n     */\n    constructor(width: number, height: number);\n    /**\n     * 返回 `Size` 的拷贝\n     * @english\n     * Returns a copy of the size\n     */\n    copy(): Size;\n    /**\n     * @overload\n     *\n     * 返回当前`Size` 与另一个 `Size` 相加的结果\n     *\n     * @english\n     * Returns the result of addition of another size.\n     * @param x - Size\n     * @returns result\n     */\n    add(x: Size): Size;\n    /**\n     * @overload\n     *\n     * 返回当前`Size` 的 xy 与传入的 xy 相加的结果\n     *\n     * @english\n     * Returns the result of addition of another size.\n     * @param x - x\n     * @param y - y\n     * @returns result\n     */\n    add(x: number, y: number): Size;\n    /**\n     * 与另一个 `Size` 进行比较，以判断它们是否相等。\n     *\n     * @english\n     * Compare with another size to see whether they are equal.\n     * @param size - size to compare\n     */\n    equals(size: Size): boolean;\n    /**\n     * 返回当前大小与给定数字相乘的结果，返回一个新的 Size 对象\n     * @english\n     * Returns the result of multiplication of the current size by the given number.\n     * @param ratio - ratio to multi\n     * @returns result\n     */\n    multi(ratio: number): Size;\n    /**\n     * 返回当前大小与给定数字相乘的结果\n     * @english\n     * Returns the result of multiplication of the current size by the given number.\n     * @param ratio - ratio to multi\n     * @returns result\n     */\n    _multi(ratio: number): this;\n    _round(): this;\n    /**\n     * 将当前 `Size` 对象转为一个点对象 {@link Point}\n     * @english\n     * Converts the size object to a {@link Point}\n     * @returns point\n     */\n    toPoint(): Point;\n    /**\n     * 将 `Size` 对象转换为数组\n     * @english\n     * Converts the size object to an array [width, height]\n     */\n    toArray(): ArraySize;\n    /**\n     * 将 `Size` 实例对象转换为 包含 `width` 和 `height` 的 json 对象\n     * @english\n     * Convert the size object to a json object {width : ., height : .}\n     * @returns json\n     */\n    toJSON(): JsonSize;\n}\nexport default Size;\n"},{"path":"types/geo/transformation/Transformation.d.ts","content":"import Coordinate from '../Coordinate';\nimport Point from '../Point';\n/**\n * 投影坐标和基础二维点系统之间的转换。\n * 内部使用的核心类，用于将地图（通常是地理）坐标映射到 2d 点\n *\n * @english\n * Transformation between projected coordinates and base 2d point system.\n * A core class used internally for mapping map's (usually geographical) coordinates to 2d points.<br>\n *\n * @category geo\n * @protected\n */\ndeclare class Transformation {\n    matrix: number[];\n    /**\n     * The base 2d point system is a fixed system that is consistent with HTML coordinate system: on X-Axis, left is smaller and right is larger; on Y-Axis, top is smaller and bottom is larger. <br>\n     * As map's coordinates may not be in the same order(e.g. on a mercator projected earth, top is larger and bottom is smaller), <br>\n     * transformation provides mapping functions to map arbitrary coordinates system to the fixed 2d point system. <br>\n     * How to transform is decided by the constructor parameters which is a 4 number array [a, b, c, d]:<br>\n     * a : the order scale of X-axis values 1 means right is larger and -1 means the reverse, left is larger;<br>\n     * b : the order scale of Y-axis values 1 means bottom is larger and -1 means the reverse, top is larger;<br>\n     * c : x of the origin point of the projected coordinate system <br>\n     * d : y of the origin point of the projected coordinate system <br>\n     * e.g.: Transformation parameters for Google map: [1, -1, -20037508.34, 20037508.34] <br>\n     * @param  matrix transformation array\n     */\n    constructor(matrix: number[]);\n    /**\n     * 将投影坐标变换为二维点，\n     * 变换/非变换方法中的参数scale用于在地图的不同缩放级别上缩放结果2d点。\n     *\n     * @english\n     * Transform a projected coordinate to a 2d point. <br>\n     * Parameter scale in transform/untransform method is used to scale the result 2d points on map's different zoom levels.\n     * @param coordinates - projected coordinate to transform\n     * @param scale - transform scale\n     * @param out - tmp point\n     * @returns 2d point.\n     */\n    transform(coordinates: Coordinate, scale: number, out?: Point): Point;\n    /**\n     * 将 2d 点变换为投影坐标。\n     *\n     * @english\n     *\n     * Transform a 2d point to a projected coordinate.\n     * @param point - 2d point\n     * @param scale - transform scale\n     * @param out tmp coordinates\n     * @returns projected coordinate.\n     */\n    untransform(point: Point, scale: number, out?: Coordinate): Coordinate;\n}\nexport default Transformation;\n"},{"path":"types/geometry/ArcCurve.d.ts","content":"import Curve, { CurveOptionsType } from './Curve';\n/**\n * @classdesc\n * Circle Arc Curve\n * @category geometry\n * @extends Curve\n * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve\n * @param {Object} [options=null]   - construct options defined in [ArcCurve]{@link ArcCurve#options}\n * @example\n * var curve = new ArcCurve(\n *     [\n *         [121.47083767181408,31.214448123476995],\n *         [121.4751292062378,31.215475523000404],\n *         [121.47869117980943,31.211916269810335]\n *     ],\n *     {\n *         arcDegree : 120,\n *         symbol : {\n *             'lineWidth' : 5\n *         }\n *     }\n * ).addTo(layer);\n */\ndeclare class ArcCurve extends Curve {\n    _toJSON(options: any): any;\n    _paintOn(ctx: CanvasRenderingContext2D, points: any, lineOpacity: number): void;\n    static fromJSON(json: any): ArcCurve;\n}\nexport default ArcCurve;\nexport type ArcCurveOptionsType = CurveOptionsType & {\n    arcDegree?: number;\n};\n"},{"path":"types/geometry/CenterMixin.d.ts","content":"import { MixinConstructor } from '../core/Mixin';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport { CommonProjectionType } from '../geo/projection';\nimport type { Map } from '../map';\n/**\n * 基于几何图形的通用方法\n * @english\n * Common methods for geometry classes that base on a center, e.g. Marker, Circle, Ellipse , etc\n * @mixin CenterMixin\n */\nexport default function <T extends MixinConstructor>(Base: T): {\n    new (...args: any[]): {\n        _coordinates: Coordinate;\n        _pcenter: Coordinate;\n        _dirtyCoords: boolean;\n        getMap?(): Map;\n        _getProjection?(): CommonProjectionType;\n        onPositionChanged?(): void;\n        _verifyProjection?(): void;\n        _clearCache?(): void;\n        /**\n         * 获取几何图形的中心点\n         * @english\n         * Get geometry's center\n         * @return {Coordinate} - center of the geometry\n         * @function CenterMixin.getCoordinates\n         */\n        getCoordinates(): Coordinate;\n        /**\n         * 设置几何图形的中心点\n         * @english\n         * Set a new center to the geometry\n         * @param {Coordinate|Number[]} coordinates - new center\n         * @return {Geometry} this\n         * @fires Geometry#positionchange\n         * @function CenterMixin.setCoordinates\n         */\n        setCoordinates(coordinates: Coordinate | Array<number>): any;\n        _getCenter2DPoint(res?: number): Point;\n        _getPrjCoordinates(): Coordinate;\n        _setPrjCoordinates(pcenter: Coordinate): void;\n        _updateCache(): void;\n        _clearProjection(): void;\n        _computeCenter(): Coordinate | null;\n    };\n} & T;\n"},{"path":"types/geometry/Circle.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\nimport Point from '../geo/Point';\nimport { CommonProjectionType } from '../geo/projection';\nimport Polygon, { PolygonOptionsType, RingCoordinates, RingsCoordinates } from './Polygon';\ndeclare const Circle_base: {\n    new (...args: any[]): {\n        _coordinates: Coordinate;\n        _pcenter: Coordinate;\n        _dirtyCoords: boolean;\n        getMap?(): import(\"src\").Map;\n        _getProjection?(): {\n            code: string;\n            is(code: string): boolean;\n            project(p: Coordinate): Coordinate;\n            unproject(p: Coordinate): Coordinate;\n            projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            isSphere(): boolean;\n            isOutSphere(pcoord: Coordinate): boolean;\n            wrapCoord(pcoord: Coordinate): Coordinate;\n            getCircum(): Record<string, number>;\n            getSphereExtent(): Extent;\n        };\n        onPositionChanged?(): void;\n        _verifyProjection?(): void;\n        _clearCache?(): void;\n        getCoordinates(): Coordinate;\n        setCoordinates(coordinates: number[] | Coordinate): any;\n        _getCenter2DPoint(res?: number): Point;\n        _getPrjCoordinates(): Coordinate;\n        _setPrjCoordinates(pcenter: Coordinate): void;\n        _updateCache(): void;\n        _clearProjection(): void;\n        _computeCenter(): Coordinate;\n    };\n} & typeof Polygon;\n/**\n * @classdesc\n * Represents a Circle Geometry. <br>\n * @category geometry\n * @extends Polygon\n * @mixes Geometry.Center\n * @example\n * var circle = new Circle([100, 0], 1000, {\n *     id : 'circle0',\n *     properties : {\n *         foo : 'bar'\n *     }\n * });\n * @mixes CenterMixin\n */\nexport declare class Circle extends Circle_base {\n    _radius: number;\n    static fromJSON(json: Record<string, any>): Circle;\n    /**\n     * @param {Coordinate} center - center of the circle\n     * @param {Number} radius           - radius of the circle, in meter\n     * @param {Object} [options=null]   - construct options defined in [Circle]{@link Circle#options}\n     */\n    constructor(coordinates: Coordinate | Array<number>, radius: number, options?: CircleOptionsType);\n    /**\n     * 获取圆形的半径\n     * @english\n     * Get radius of the circle\n     * @return {Number}\n     */\n    getRadius(): number;\n    /**\n     * 给圆形设置新的半径\n     * @english\n     * Set a new radius to the circle\n     * @param {Number} radius - new radius\n     * @return {Circle} this\n     * @fires Circle#shapechange\n     */\n    setRadius(radius: number): this;\n    /**\n     * 获取作为多边形的圆的外壳，外壳点数由[options.numberOfShellPoints决定\n     * @english\n     * Gets the shell of the circle as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Circle#options}\n     * @return {Coordinate[]} - shell coordinates\n     */\n    getShell(): RingCoordinates;\n    /**\n     * 圆没有任何孔，总是返回null\n     * @english\n     * Circle won't have any holes, always returns null\n     * @return {Object[]} an empty array\n     */\n    getHoles(): RingsCoordinates;\n    animateShow(): any;\n    _containsPoint(point: Point, tolerance?: number): boolean;\n    _computePrjExtent(projection: CommonProjectionType): Extent;\n    _computeExtent(measurer: any): Extent;\n    _getMinMax(measurer: any): [Coordinate, Coordinate, Coordinate, Coordinate];\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        coordinates: any;\n    };\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        coordinates: number[];\n        radius: number;\n    };\n}\nexport default Circle;\nexport type CircleOptionsType = PolygonOptionsType & {\n    numberOfShellPoints?: number;\n};\n"},{"path":"types/geometry/ConnectorLine.d.ts","content":"import LineString, { LineStringOptionsType } from './LineString';\nimport Geometry from './Geometry';\nimport ArcCurve, { ArcCurveOptionsType } from './ArcCurve';\nimport { type Map } from '../map';\nimport Coordinate from '../geo/Coordinate';\ndeclare const ConnectorLine_base: {\n    new (...args: any[]): {\n        options: ConnectableOptionsType;\n        _connSource: Geometry;\n        _connTarget: Geometry;\n        getMap?(): Map;\n        getCoordinates?(): Coordinate[];\n        setCoordinates?(coordinates: Coordinate[]): any;\n        hide?(): any;\n        show?(): any;\n        remove?(): any;\n        /**\n         * 获取连接线的源\n         * @english\n         * Gets the source of the connector line.\n         * @return {Geometry|control.Control|UIComponent}\n         * @function Connectable.getConnectSource\n         */\n        getConnectSource(): Geometry;\n        /**\n         * 设置连接线的源\n         * @english\n         * Sets the source to the connector line.\n         * @param {Geometry|control.Control|UIComponent} src\n         * @return {ConnectorLine} this\n         * @function Connectable.setConnectSource\n         */\n        setConnectSource(src: Geometry): any;\n        /**\n         * 获取连接线的目标\n         * @english\n         * Gets the target of the connector line.\n         * @return {Geometry|control.Control|UIComponent}\n         * @function Connectable.getConnectTarget\n         */\n        getConnectTarget(): Geometry;\n        /**\n         * 设置连接线目标\n         * @english\n         * Sets the target to the connector line.\n         * @param {Geometry|control.Control|UIComponent} target\n         * @return {ConnectorLine} this\n         * @function Connectable.setConnectTarget\n         */\n        setConnectTarget(target: Geometry): any;\n        _updateCoordinates(): void;\n        onAdd(): void;\n        onRemove(): void;\n        _showConnect(): void;\n        _registerEvents(): void;\n    };\n    _hasConnectors(geometry: any): boolean;\n    _getConnectors(geometry: any): any;\n} & typeof LineString;\n/**\n * 直线连接线几何图形可以将几何图形或ui组件相互连接。\n * @english\n * A straight connector line geometry can connect geometries or ui components with each other. <br>\n *\n * @category geometry\n * @extends LineString\n * @example\n * var src = new Marker([0,0]).addTo(layer),\n *     dst = new Marker([1,0]).addTo(layer),\n *     line = new ConnectorLine(src, dst, {\n *         showOn : 'always', //'moving', 'click', 'mouseover', 'always'\n *         arrowStyle : 'classic',\n *         arrowPlacement : 'vertex-last', //vertex-first, vertex-last, vertex-firstlast, point\n *         symbol: {\n *           lineColor: '#34495e',\n *           lineWidth: 2\n *        }\n *     }).addTo(layer);\n * @mixes connectorLineMixin\n */\ndeclare class ConnectorLine extends ConnectorLine_base {\n    /**\n     * @param {Geometry|control.Control|UIComponent} src     - source to connect\n     * @param {Geometry|control.Control|UIComponent} target  - target to connect\n     * @param {Object} [options=null]  - construct options defined in [ConnectorLine]{@link ConnectorLine#options}\n     */\n    constructor(src: Geometry, target: Geometry, options?: ConnectorLineOptionsType);\n}\ndeclare const ArcConnectorLine_base: {\n    new (...args: any[]): {\n        options: ConnectableOptionsType;\n        _connSource: Geometry;\n        _connTarget: Geometry;\n        getMap?(): Map;\n        getCoordinates?(): Coordinate[];\n        setCoordinates?(coordinates: Coordinate[]): any;\n        hide?(): any;\n        show?(): any;\n        remove?(): any;\n        /**\n         * 获取连接线的源\n         * @english\n         * Gets the source of the connector line.\n         * @return {Geometry|control.Control|UIComponent}\n         * @function Connectable.getConnectSource\n         */\n        getConnectSource(): Geometry;\n        /**\n         * 设置连接线的源\n         * @english\n         * Sets the source to the connector line.\n         * @param {Geometry|control.Control|UIComponent} src\n         * @return {ConnectorLine} this\n         * @function Connectable.setConnectSource\n         */\n        setConnectSource(src: Geometry): any;\n        /**\n         * 获取连接线的目标\n         * @english\n         * Gets the target of the connector line.\n         * @return {Geometry|control.Control|UIComponent}\n         * @function Connectable.getConnectTarget\n         */\n        getConnectTarget(): Geometry;\n        /**\n         * 设置连接线目标\n         * @english\n         * Sets the target to the connector line.\n         * @param {Geometry|control.Control|UIComponent} target\n         * @return {ConnectorLine} this\n         * @function Connectable.setConnectTarget\n         */\n        setConnectTarget(target: Geometry): any;\n        _updateCoordinates(): void;\n        onAdd(): void;\n        onRemove(): void;\n        _showConnect(): void;\n        _registerEvents(): void;\n    };\n    _hasConnectors(geometry: any): boolean;\n    _getConnectors(geometry: any): any;\n} & typeof ArcCurve;\n/**\n * 弧形曲线连接线几何图形可以将几何图形或ui组件相互连接\n * @english\n * An arc curve connector line geometry can connect geometries or ui components with each other. <br>\n *\n * @category geometry\n * @extends ArcCurve\n * @example\n * var src = new Marker([0,0]).addTo(layer),\n *     dst = new Marker([1,0]).addTo(layer),\n *     line = new ArcConnectorLine(src, dst, {\n *         arcDegree : 120,\n *         showOn : 'always', //'moving', 'click', 'mouseover', 'always'\n *         arrowStyle : 'classic',\n *         arrowPlacement : 'vertex-last', //vertex-first, vertex-last, vertex-firstlast, point\n *         symbol: {\n *           lineColor: '#34495e',\n *           lineWidth: 2\n *        }\n *     }).addTo(layer);\n * @mixes connectorLineMixin\n */\ndeclare class ArcConnectorLine extends ArcConnectorLine_base {\n    /**\n     * @param {Geometry|control.Control|UIComponent} src     - source to connect\n     * @param {Geometry|control.Control|UIComponent} target  - target to connect\n     * @param {Object} [options=null]  - construct options defined in [ConnectorLine]{@link ConnectorLine#options}\n     */\n    constructor(src: Geometry, target: Geometry, options?: ArcConnectorLineOptionsType);\n}\nexport { ConnectorLine, ArcConnectorLine };\nexport type ConnectableOptionsType = {\n    showOn?: 'always' | 'moving' | 'click' | 'mouseover';\n};\nexport type ConnectorLineOptionsType = LineStringOptionsType & ConnectableOptionsType;\nexport type ArcConnectorLineOptionsType = ArcCurveOptionsType & ConnectableOptionsType;\n"},{"path":"types/geometry/CubicBezierCurve.d.ts","content":"import Curve, { CurveOptionsType } from './Curve';\n/**\n * 三次贝塞尔曲线\n * @english\n * Cubic Bezier Curve\n * @category geometry\n * @extends Curve\n * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve\n * @param {Object} [options=null]   - construct options defined in [CubicBezierCurve]{@link CubicBezierCurve#options}\n * @example\n * var curve = new CubicBezierCurve(\n *     [\n *         [121.47083767181408,31.214448123476995],\n *         [121.4751292062378,31.215475523000404],\n *         [121.47869117980943,31.211916269810335]\n *     ],\n *     {\n *         symbol : {\n *             'lineWidth' : 5\n *         }\n *     }\n * ).addTo(layer);\n */\ndeclare class CubicBezierCurve extends Curve {\n    static fromJSON(json: any): CubicBezierCurve;\n    _toJSON(options: any): any;\n    _paintOn(ctx: CanvasRenderingContext2D, points: any, lineOpacity: number): void;\n    _getArrowPoints(arrows: any[], segments: [], lineWidth: number, arrowStyle: any, tolerance: any): any;\n}\nexport default CubicBezierCurve;\nexport type CubicBezierCurveOptionsType = CurveOptionsType;\n"},{"path":"types/geometry/Curve.d.ts","content":"import LineString, { LineStringOptionsType } from './LineString';\n/**\n * 曲线样式LineString，所有曲线的抽象父类。\n * @english\n * Curve style LineString, an abstract parent class for all the curves.\n * @category geometry\n * @abstract\n * @extends LineString\n * @param {Coordinate[]|Number[][]} coordinates - coordinates of the line string\n * @param {Object} [options=null] - construct options defined in [LineString]{@link LineString#options}\n * @property {Boolean} [options.enableSimplify=false] - whether to simplify path before rendering\n * @property {Boolean} [options.enableClip=false] - whether to clip curve with map's current extent\n */\ndeclare class Curve extends LineString {\n    _arc(ctx: CanvasRenderingContext2D, points: any, lineOpacity: number): void;\n    _quadraticCurve(ctx: CanvasRenderingContext2D, points: any): void;\n    _bezierCurve(ctx: CanvasRenderingContext2D, points: any): void;\n    _getCurveArrowPoints(arrows: any[], segments: [], lineWidth: number, arrowStyle: any, tolerance: any, step: number): void;\n}\nexport default Curve;\nexport type CurveOptionsType = LineStringOptionsType & {\n    enableSimplify?: boolean;\n    enableClip?: boolean;\n};\n"},{"path":"types/geometry/editor/GeometryEditor.d.ts","content":"import Class from '../../core/Class';\nimport EditHandle from '../../renderer/edit/EditHandle';\nimport { GeometryEditOptionsType } from '../ext/Geometry.Edit';\ntype GeometryEvents = {\n    'symbolchange': any;\n    'dragstart': any;\n    'dragend': any;\n    'positionchange shapechange': any;\n};\ndeclare const GeometryEditor_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Class;\n/**\n * 内部使用的几何图形编辑器\n * @english\n * Geometry editor used internally for geometry editing.\n * @category geometry\n * @protected\n * @extends Class\n * @mixes Eventable\n */\ndeclare class GeometryEditor extends GeometryEditor_base {\n    _geometry: any;\n    private _originalSymbol;\n    private _shadowLayer;\n    private _shadow;\n    private _geometryDraggble;\n    private _history;\n    private _historyPointer;\n    private _editOutline;\n    private _refreshHooks;\n    private _updating;\n    editing: boolean;\n    options: GeometryEditOptionsType;\n    /**\n     * @param {Geometry} geometry geometry to edit\n     * @param {Object} [opts=null] options\n     * @param {Object} [opts.symbol=null] symbol of being edited.\n     */\n    constructor(geometry: any, opts: GeometryEditOptionsType);\n    /**\n     * 获取地图对象\n     * @english\n     * Get map\n     * @return {Map} map\n     */\n    getMap(): any;\n    /**\n     * 准备编辑\n     * @english\n     * Prepare to edit\n     */\n    prepare(): void;\n    _prepareEditStageLayer(): void;\n    /**\n     * 开始编辑\n     * @english\n     * Start to edit\n     */\n    start(): void;\n    /**\n     * 停止编辑\n     * @english\n     * Stop editing\n     */\n    stop(): void;\n    /**\n     * 编辑器是否在编辑\n     * @english\n     * Whether the editor is editing\n     * @return {Boolean}\n     */\n    isEditing(): boolean;\n    _getGeometryEvents(): GeometryEvents;\n    _switchGeometryEvents(oper: any): void;\n    _onGeoSymbolChange(param: any): void;\n    _onMarkerDragEnd(): void;\n    /**\n     * 创建几何图形的矩形轮廓\n     * @english\n     * create rectangle outline of the geometry\n     * @private\n     */\n    _createOrRefreshOutline(): any;\n    _createCenterHandle(): void;\n    _createHandleInstance(containerPoint: any, opts: any): EditHandle;\n    createHandle(containerPoint: any, opts: any): EditHandle;\n    /**\n     * 为几何图形创建可以调整大小的事件\n     * @english\n     * create resize handles for geometry that can resize.\n     * @param {Array} blackList handle indexes that doesn't display, to prevent change a geometry's coordinates\n     * @param {fn} onHandleMove callback\n     * @private\n     */\n    _createResizeHandles(blackList: Array<any>, onHandleMove: any, onHandleUp: any): any;\n    /**\n     * 创建标记编辑器\n     * @english\n     * Create marker editor\n     * @private\n     */\n    createMarkerEditor(): void;\n    /**\n     * 创建圆形编辑器\n     * @english\n     * Create circle editor\n     * @private\n     */\n    createCircleEditor(): void;\n    /**\n     * 创建椭圆或者矩形编辑器\n     * @english\n     * editor of ellipse or rectangle\n     * @private\n     */\n    createEllipseOrRectEditor(): void;\n    /**\n     * 创建多边形编辑器\n     * @english\n     * Editor for polygon\n     * @private\n     */\n    createPolygonEditor(): void;\n    _refresh(): void;\n    _hideContext(): void;\n    _addRefreshHook(fn: any): void;\n    _update(method: any, ...args: any): void;\n    _updateCoordFromShadow(ignoreRecord?: any): void;\n    _recordHistory(method: any, ...args: any): void;\n    cancel(): GeometryEditor;\n    /**\n     * 获取视图历史记录中的上一个地图视图\n     * @english\n     * Get previous map view in view history\n     * @return {Object} map view\n     */\n    undo(): any;\n    /**\n     * 获取视图历史记录中的下一个地图视图\n     * @english\n     * Get next view in view history\n     * @return {Object} map view\n     */\n    redo(): any;\n    _exeAndReset(record: any): void;\n    _onDragStart(): void;\n    _onDragEnd(): void;\n    _exeHistory(record: any): void;\n}\nexport default GeometryEditor;\n"},{"path":"types/geometry/editor/TextEditable.d.ts","content":"import TextMarker from '../../geometry/TextMarker';\nimport UIMarker from '../../ui/UIMarker';\n/**\n * Mixin methods for text editing.\n * @mixin TextEditable\n */\ndeclare const TextEditable: {\n    /**\n     * 开始编辑文本，每当点击地图时，编辑将自动结束\n     * @english\n     * Start to edit the text, editing will be ended automatically whenever map is clicked.\n     *\n     * @return {TextMarker} this\n     * @fires TextMarker#edittextstart\n     */\n    startEditText(): TextMarker;\n    /**\n     * 结束编辑\n     * @english\n     * End text edit.\n     *\n     * @return {TextMarker} this\n     * @fires TextMarker#edittextend\n     */\n    endEditText(): any;\n    /**\n     * 是否正在编辑文本\n     * @english\n     * Whether the text is being edited.\n     *\n     * @return {Boolean}\n     */\n    isEditingText(): boolean;\n    /**\n     * 获取正在编辑的文本对象\n     * @english\n     * Get the text editor which is an [ui.UIMarker]{@link ui.UIMarker}\n     * @return {ui.UIMarker} text editor\n     */\n    getTextEditor(): UIMarker;\n    _prepareEditor(): void;\n    _getEditorOffset(): object;\n    _createEditor(): HTMLElement;\n    _setCursorToLast(obj: any): void;\n};\nexport default TextEditable;\n"},{"path":"types/geometry/Ellipse.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Polygon, { PolygonOptionsType, RingCoordinates, RingsCoordinates } from './Polygon';\nimport Point from '../geo/Point';\nimport Extent from '../geo/Extent';\ndeclare const Ellipse_base: {\n    new (...args: any[]): {\n        _coordinates: Coordinate;\n        _pcenter: Coordinate;\n        _dirtyCoords: boolean;\n        getMap?(): import(\"src\").Map;\n        _getProjection?(): {\n            code: string;\n            is(code: string): boolean;\n            project(p: Coordinate): Coordinate;\n            unproject(p: Coordinate): Coordinate;\n            projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            isSphere(): boolean;\n            isOutSphere(pcoord: Coordinate): boolean;\n            wrapCoord(pcoord: Coordinate): Coordinate;\n            getCircum(): Record<string, number>;\n            getSphereExtent(): Extent;\n        };\n        onPositionChanged?(): void;\n        _verifyProjection?(): void;\n        _clearCache?(): void;\n        getCoordinates(): Coordinate;\n        setCoordinates(coordinates: number[] | Coordinate): any;\n        _getCenter2DPoint(res?: number): Point;\n        _getPrjCoordinates(): Coordinate;\n        _setPrjCoordinates(pcenter: Coordinate): void;\n        _updateCache(): void;\n        _clearProjection(): void;\n        _computeCenter(): Coordinate;\n    };\n} & typeof Polygon;\n/**\n * 表示椭圆几何体\n * @english\n * Represents a Ellipse Geometry. <br>\n * @category geometry\n * @extends Polygon\n * @mixes CenterMixin\n * @example\n * var ellipse = new Ellipse([100, 0], 1000, 500, {\n *     id : 'ellipse0'\n * });\n */\nexport declare class Ellipse extends Ellipse_base {\n    width: number;\n    height: number;\n    options: EllipseOptionsType;\n    static fromJSON(json: Record<string, any>): Ellipse;\n    /**\n     * @param {Coordinate} center  - center of the ellipse\n     * @param {Number} width  - width of the ellipse, in meter\n     * @param {Number} height - height of the ellipse, in meter\n     * @param {Object}  [options=null] - construct options defined in [Ellipse]{@link Ellipse#options}\n     */\n    constructor(coordinates: Coordinate | Array<number>, width: number, height: number, options?: EllipseOptionsType);\n    /**\n     * 获取椭圆的宽度\n     * @english\n     * Get ellipse's width\n     * @return {Number}\n     */\n    getWidth(): number;\n    /**\n     * 设置椭圆的宽度\n     * Set new width to ellipse\n     * @param {Number} width - new width\n     * @fires Ellipse#shapechange\n     * @return {Ellipse} this\n     */\n    setWidth(width: number): this;\n    /**\n     * 获取椭圆高度\n     * @english\n     * Get ellipse's height\n     * @return {Number}\n     */\n    getHeight(): number;\n    /**\n     * 设置椭圆高度\n     * @english\n     * Set new height to ellipse\n     * @param {Number} height - new height\n     * @fires Ellipse#shapechange\n     * @return {Ellipse} this\n     */\n    setHeight(height: number): this;\n    /**\n     * 获取作为多边形的椭圆的外壳，外壳点数由决定\n     * @english\n     * Gets the shell of the ellipse as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Circle#options}\n     * @return {Coordinate[]} - shell coordinates\n     */\n    getShell(): RingCoordinates;\n    _getShell(): RingCoordinates;\n    _getPrjShell(): RingCoordinates;\n    /**\n     * 椭圆没有任何孔，总是返回null\n     * @english\n     * Ellipse won't have any holes, always returns null\n     * @return {Object[]} an empty array\n     */\n    getHoles(): RingsCoordinates;\n    animateShow(): any;\n    _containsPoint(point: Point, tolerance?: number): boolean;\n    _computePrjExtent(): Extent;\n    _computeExtent(): any;\n    _getMinMax(measurer: any): [Coordinate, Coordinate, Coordinate, Coordinate];\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        coordinates: any;\n    };\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        coordinates: number[];\n        width: number;\n        height: number;\n    };\n}\nexport default Ellipse;\nexport type EllipseOptionsType = PolygonOptionsType & {\n    numberOfShellPoints?: number;\n    debug?: boolean;\n};\n"},{"path":"types/geometry/ext/Geometry.Animation.d.ts","content":"import { AnimationOptionsType, Frame, Player } from '../../core/Animation';\ntype AnimationStyles = {\n    [key: string]: any;\n};\ndeclare module \"../Geometry\" {\n    interface Geometry {\n        _animPlayer: Player;\n        animate(styles: AnimationStyles, options?: AnimationOptionsType | ((frame: Frame) => void), step?: (frame: Frame) => void): Player;\n    }\n}\nexport {};\n"},{"path":"types/geometry/ext/Geometry.Drag.d.ts","content":"import Handler from '../../handler/Handler';\n/**\n * 几何图形的拖动处理程序\n * @english\n * Drag handler for geometries.\n * @category handler\n * @extends Handler\n * @ignore\n */\ndeclare class GeometryDragHandler extends Handler {\n    container: any;\n    private _dragHandler;\n    private _shadow;\n    private _dragStageLayer;\n    private _shadowConnectors;\n    private _lastCoord;\n    private _lastPoint;\n    private _startParam;\n    private _moved;\n    private _isDragging;\n    /**\n     * @param  {Geometry} target geometry target to drag\n     */\n    constructor(target: any);\n    addHooks(): void;\n    removeHooks(): void;\n    _prepareDragHandler(): void;\n    _prepareShadow(): void;\n    _updateShadowSymbol(shadow: any, target: any): void;\n    _prepareShadowConnectors(): void;\n    _onTargetUpdated(): void;\n    _prepareDragStageLayer(): void;\n    _startDrag(param: any): void;\n    _dragging(param: any): void;\n    _endDrag(param?: any): void;\n    isDragging(): boolean;\n    _updateTargetAndRemoveShadow(eventParam: any): void;\n    _correctCoord(coord: any): any;\n}\ndeclare module \"../Geometry\" {\n    interface Geometry {\n        isDragging(): boolean;\n    }\n}\nexport default GeometryDragHandler;\n"},{"path":"types/geometry/ext/Geometry.Edit.d.ts","content":"export type GeometryEditSymbolType = {\n    'markerType': string;\n    'markerFill': string;\n    'markerLineColor': string;\n    'markerLineWidth': number;\n    'markerWidth': number;\n    'markerHeight': number;\n    'opacity': number;\n};\nexport type GeometryEditOptionsType = {\n    symbol?: {\n        [key: string]: any;\n    };\n    fixAspectRatio?: boolean;\n    centerHandleSymbol?: GeometryEditSymbolType;\n    vertexHandleSymbol?: GeometryEditSymbolType;\n    newVertexHandleSymbol?: GeometryEditSymbolType;\n    removeVertexOn?: string;\n    collision?: boolean;\n    collisionBufferSize?: number;\n    vertexZIndex?: number;\n    newVertexZIndex?: number;\n};\ndeclare module \"../Geometry\" {\n    interface Geometry {\n        startEdit(opts?: GeometryEditOptionsType): this;\n        endEdit(): this;\n        redoEdit(): this;\n        undoEdit(): this;\n        cancelEdit(): this;\n        isEditing(): boolean;\n    }\n}\n"},{"path":"types/geometry/ext/Geometry.Events.d.ts","content":"declare module \"../Geometry\" {\n    interface Geometry {\n        _onEvent(event: MouseEvent | TouchEvent, type?: string): void;\n    }\n}\nexport {};\n"},{"path":"types/geometry/ext/Geometry.InfoWindow.d.ts","content":"import InfoWindow, { InfoWindowOptionsType } from '../../ui/InfoWindow';\nimport type Coordinate from '../../geo/Coordinate';\ndeclare module \"../Geometry\" {\n    interface Geometry {\n        _infoWindow: InfoWindow;\n        setInfoWindow(options: InfoWindowOptionsType): this;\n        getInfoWindow(): InfoWindow;\n        openInfoWindow(coordinate?: Coordinate): this;\n        closeInfoWindow(): this;\n        removeInfoWindow(): this;\n        _bindInfoWindow(): this;\n        _unbindInfoWindow(): this;\n    }\n}\n"},{"path":"types/geometry/ext/Geometry.JSON.d.ts","content":"export {};\n"},{"path":"types/geometry/GeoJSON.d.ts","content":"/**\n * GeoJSON工具类\n * @english\n * GeoJSON utilities\n * @category geometry\n */\ndeclare const GeoJSON: {\n    /**\n     * 将一个或多个GeoJSON对象转换为几何体\n     * @english\n     * Convert one or more GeoJSON objects to geometry\n     * @param  {String|Object|Object[]} geoJSON - GeoJSON objects or GeoJSON string\n     * @param  {Function} [foreachFn=undefined] - callback function for each geometry\n     * @return {Geometry|Geometry[]} a geometry array when input is a FeatureCollection\n     * @example\n     * var collection = {\n     *      \"type\": \"FeatureCollection\",\n     *      \"features\": [\n     *          { \"type\": \"Feature\",\n     *            \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.0, 0.5]},\n     *            \"properties\": {\"prop0\": \"value0\"}\n     *           },\n     *           { \"type\": \"Feature\",\n     *             \"geometry\": {\n     *                 \"type\": \"LineString\",\n     *                 \"coordinates\": [\n     *                     [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]\n     *                 ]\n     *             },\n     *             \"properties\": {\n     *                 \"prop0\": \"value0\",\n     *                 \"prop1\": 0.0\n     *             }\n     *           },\n     *           { \"type\": \"Feature\",\n     *             \"geometry\": {\n     *                 \"type\": \"Polygon\",\n     *                 \"coordinates\": [\n     *                     [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n     *                       [100.0, 1.0], [100.0, 0.0] ]\n     *                 ]\n     *             },\n     *             \"properties\": {\n     *                 \"prop0\": \"value0\",\n     *                 \"prop1\": {\"this\": \"that\"}\n     *             }\n     *          }\n     *      ]\n     *  }\n     *  // A geometry array.\n     *  const geometries = GeoJSON.toGeometry(collection, geometry => { geometry.config('draggable', true); });\n     */\n    toGeometry: (geoJSON: any, foreachFn?: any) => any;\n    /**\n     * async将一个或多个GeoJSON对象转换为几何体\n     * @english\n    * async Convert one or more GeoJSON objects to geometry\n    * @param  {String|Object|Object[]} geoJSON - GeoJSON objects or GeoJSON string\n    * @param  {Function} [foreachFn=undefined] - callback function for each geometry\n    * @param  {Number} [countPerTime=2000] - Number of graphics converted per time\n    * @return {Promise}\n    * @example\n    *  GeoJSON.toGeometryAsync(geoJSON).then(geos=>{\n    *    console.log(geos);\n    * })\n    * */\n    toGeometryAsync(geoJSON: any, foreachFn: any, countPerTime?: number): any;\n    /**\n     * 转换单个GeoJSON对象\n     * @english\n     * Convert single GeoJSON object\n     * @param  {Object} geoJSONObj - a GeoJSON object\n     * @return {Geometry}\n     * @private\n     */\n    _convert: (json: any, foreachFn?: any) => any;\n    _isGeoJSON(json: any): boolean;\n    /**\n     * 正在请求一个大容量的geojson文件。解决主线程阻塞问题\n     * @english\n    * Requesting a large volume geojson file.Solve the problem of main thread blocking\n    * @param  {String} url - GeoJSON file path\n    * @param  {Number} [countPerTime=2000] - Number of graphics converted per time\n    * @return {Promise}\n    * @example\n    *  GeoJSON.fetch('https://abc.com/file.geojson',2000).then(geojson=>{\n    *    console.log(geojson);\n    * })\n    * */\n    fetch(url: any, countPerTime?: number): any;\n};\nexport default GeoJSON;\n"},{"path":"types/geometry/Geometry.d.ts","content":"import Class from '../core/Class';\nimport { BaseEventParamsType } from '../core/Eventable';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport Extent from '../geo/Extent';\nimport PointExtent from '../geo/PointExtent';\nimport Painter from '../renderer/geometry/Painter';\nimport CollectionPainter from '../renderer/geometry/CollectionPainter';\nimport { SizeLike } from '../geo/Size';\nimport type { ProjectionType } from '../geo/projection';\nimport OverlayLayer, { addGeometryFitViewOptions } from '../layer/OverlayLayer';\nimport GeometryCollection from './GeometryCollection';\nimport type { Map } from '../map';\nimport { WithNull } from '../types/typings';\nimport { InfoWindowOptionsType } from '../ui/InfoWindow';\ndeclare const Geometry_base: {\n    new (...args: any[]): {\n        _jsonType?: string;\n        getJSONType(): string;\n    };\n    registerJSONType(type: string): void;\n    getJSONClass(type: string): {\n        new (...args: any[]): {\n            _eventMap?: Record<string, {\n                handler: import(\"../core/Eventable\").HandlerFn;\n                context: any;\n            }[]>;\n            _eventParent?: any;\n            _eventTarget?: any;\n            on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            addEventListener(...args: any[]): any;\n            once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            removeEventListener(...args: any[]): any;\n            listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n            getListeningEvents(): string[];\n            copyEventListeners(target: any): any;\n            fire(eventType: string, param?: BaseEventParamsType): any;\n            _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n            _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n            _clearListeners(eventType: string): void;\n            _clearAllListeners(): void;\n            _setEventParent(parent: any): any;\n            _setEventTarget(target: any): any;\n            _fire(eventType: string, param: BaseEventParamsType): any;\n        };\n    } & {\n        new (...args: any[]): {\n            _handlers?: import(\"src\").Handler[];\n            addHandler(name: any, handlerClass: any): any;\n            removeHandler(name: any): any;\n            _clearHandlers(): void;\n        };\n    } & typeof Class;\n} & {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: BaseEventParamsType): any;\n    };\n} & {\n    new (...args: any[]): {\n        _handlers?: import(\"src\").Handler[];\n        addHandler(name: any, handlerClass: any): any;\n        removeHandler(name: any): any;\n        _clearHandlers(): void;\n    };\n} & typeof Class;\n/**\n * 所有几何图形的基类。\n * 它定义了所有几何图形类共享的通用方法。\n * 它是抽象的，不打算被实例化而是被扩展。\n * @english\n * Base class for all the geometries. <br/>\n * It defines common methods that all the geometry classes share. <br>\n * It is abstract and not intended to be instantiated but extended.\n *\n * @category geometry\n * @abstract\n * @extends Class\n * @mixes Eventable\n * @mixes Handlerable\n * @mixes JSONAble\n * @mixes ui.Menuable\n */\nexport declare class Geometry extends Geometry_base {\n    options: GeometryOptionsType;\n    type: string;\n    _layer: OverlayLayer;\n    _angle: number;\n    _pivot: Coordinate;\n    _id: string;\n    properties: Record<string, any>;\n    _symbol: any;\n    _symbolUpdated: any;\n    _compiledSymbol: any;\n    _symbolHash: any;\n    _textDesc: any;\n    _eventSymbolProperties: any;\n    _sizeSymbol: any;\n    _internalId: number;\n    _extent: Extent;\n    _fixedExtent: PointExtent;\n    _extent2d: PointExtent;\n    _externSymbol: any;\n    _parent: Geometry | GeometryCollection;\n    _silence: boolean;\n    _projCode: string;\n    _painter: Painter;\n    _maskPainter: CollectionPainter | Painter;\n    _dirtyCoords: any;\n    _pcenter: Coordinate;\n    _coordinates: any;\n    _infoWinOptions: InfoWindowOptionsType;\n    _minAlt: number;\n    _maxAlt: number;\n    _isCheck?: boolean;\n    _cPoint?: any;\n    _inCurrentView?: boolean;\n    isPoint?: boolean;\n    _paintAsPath?: () => any;\n    _getPaintParams?: (disableSimplify?: boolean) => any[];\n    _simplified?: boolean;\n    getHoles?(): Array<Array<Coordinate>>;\n    __connectors: Array<Geometry>;\n    getShell?(): Array<Coordinate>;\n    getGeometries?(): Geometry[];\n    getCoordinates?(): Coordinate | Array<Coordinate> | Array<Array<Coordinate>> | Array<Array<Array<Coordinate>>>;\n    setCoordinates?(coordinate: any): this;\n    _computeCenter?(T: any): Coordinate;\n    _computeExtent?(T: any): Extent;\n    onRemove?(): void;\n    _computeGeodesicLength?(T: any): number;\n    _computeGeodesicArea?(T: any): number;\n    getRotateOffsetAngle?(): number;\n    _computePrjExtent?(T: null | ProjectionType): Extent;\n    _updateCache?(): void;\n    onAdd?(): void;\n    constructor(options: GeometryOptionsType);\n    static fromJSON(json: {\n        [key: string]: any;\n    } | Array<{\n        [key: string]: any;\n    }>): Geometry | Array<Geometry>;\n    /**\n     * 获取几何图形第一个坐标点\n     * @english\n     * Returns the first coordinate of the geometry.\n     *\n     * @return {Coordinate} First Coordinate\n     */\n    getFirstCoordinate(): Coordinate;\n    /**\n     * 获取几何图形最后一个坐标点\n     * @english\n     * Returns the last coordinate of the geometry.\n     *\n     * @return {Coordinate} Last Coordinate\n     */\n    getLastCoordinate(): Coordinate;\n    /**\n     * 将几何图形添加到指定图层上\n     * @english\n     * Adds the geometry to a layer\n     * @param {Layer} layer    - layer add to\n     * @param {Boolean} [fitview=false] - automatically set the map to a fit center and zoom for the geometry\n     * @return {Geometry} this\n     * @fires Geometry#add\n     */\n    addTo(layer: OverlayLayer, fitview?: boolean | addGeometryFitViewOptions): this;\n    /**\n     * 获取几何图形所在的图层\n     * @english\n     * Get the layer which this geometry added to.\n     * @returns {Layer} - layer added to\n     */\n    getLayer(): OverlayLayer;\n    /**\n     * 获取几何图形所在的地图对象\n     * @english\n     * Get the map which this geometry added to\n     * @returns {Map} - map added to\n     */\n    getMap(): Map | null;\n    /**\n     * 获取几何图形的id\n     * @english\n     * Gets geometry's id. Id is set by setId or constructor options.\n     * @returns {String|Number} geometry的id\n     */\n    getId(): string;\n    /**\n     * 给几何图形设置id\n     * @english\n     * Set geometry's id.\n     * @param {String} id - new id\n     * @returns {Geometry} this\n     * @fires Geometry#idchange\n     */\n    setId(id: string): this;\n    /**\n     * 获取几何图形的属性\n     * @english\n     * Get geometry's properties. Defined by GeoJSON as [feature's properties]{@link http://geojson.org/geojson-spec.html#feature-objects}.\n     *\n     * @returns {Object} properties\n     */\n    getProperties(): {\n        [key: string]: any;\n    } | null;\n    /**\n     * 给几何图形设置新的属性\n     * Set a new properties to geometry.\n     * @param {Object} properties - new properties\n     * @returns {Geometry} this\n     * @fires Geometry#propertieschange\n     */\n    setProperties(properties: {\n        [key: string]: any;\n    }): this;\n    /**\n     * 获取几何图形的类型,例如“点”,\"线\"\n     * @english\n     * Get type of the geometry, e.g. \"Point\", \"LineString\"\n     * @returns {String} type of the geometry\n     */\n    getType(): string;\n    /**\n     * 获取几何图形的样式\n     * @english\n     * Get symbol of the geometry\n     * @returns {Object} geometry's symbol\n     */\n    getSymbol(): any;\n    /**\n     * 给几何图形设置样式\n     * @english\n     * Set a new symbol to style the geometry.\n     * @param {Object} symbol - new symbol\n     * @see {@tutorial symbol Style a geometry with symbols}\n     * @return {Geometry} this\n     * @fires Geometry#symbolchange\n     */\n    setSymbol(symbol: any): this;\n    /**\n     * 获取样式的哈希值\n     * @english\n     * Get symbol's hash code\n     * @return {String}\n     */\n    getSymbolHash(): string;\n    /**\n     * 更新几何图形当前的样式\n     * @english\n     * Update geometry's current symbol.\n     *\n     * @param  {Object | Array} props - symbol properties to update\n     * @return {Geometry} this\n     * @fires Geometry#symbolchange\n     * @example\n     * var marker = new Marker([0, 0], {\n     *  // if has markerFile , the priority of the picture is greater than the vector and the path of svg\n     *  // svg image type:'path';vector type:'cross','x','diamond','bar','square','rectangle','triangle','ellipse','pin','pie'\n     *    symbol : {\n     *       markerType : 'ellipse',\n     *       markerWidth : 20,\n     *       markerHeight : 30\n     *    }\n     * });\n     * // update symbol's markerWidth to 40\n     * marker.updateSymbol({\n     *     markerWidth : 40\n     * });\n     */\n    updateSymbol(props: any): this;\n    /**\n     * 如果几何图形有文本内容，就获取它\n     * @english\n     * Get geometry's text content if it has\n     * @returns {String}\n     */\n    getTextContent(): any;\n    getTextDesc(): any;\n    /**\n     * 获取几何图形中心点\n     * @english\n     * Get the geographical center of the geometry.\n     *\n     * @returns {Coordinate}\n     */\n    getCenter(): Coordinate;\n    /**\n     * 获取几何图形的包围盒范围\n     * @english\n     * Get the geometry's geographical extent\n     *\n     * @returns {Extent} geometry's extent\n     */\n    getExtent(): Extent;\n    /**\n     * 获取几何图形的屏幕像素范围\n     * @english\n     * Get geometry's screen extent in pixel\n     *\n     * @returns {PointExtent}\n     */\n    getContainerExtent(out?: PointExtent): PointExtent;\n    _getFixedExtent(): PointExtent;\n    get2DExtent(): PointExtent;\n    /**\n     * 获取几何体的像素大小，不同缩放级别的像素大小可能会有所不同。\n     * @english\n     * Get pixel size of the geometry, which may vary in different zoom levels.\n     *\n     * @returns {Size}\n     */\n    getSize(): SizeLike;\n    /**\n     * 几何体是否包含输入容器点\n     * @english\n     * Whehter the geometry contains the input container point.\n     *\n     * @param  {Point|Coordinate} point - input container point or coordinate\n     * @param  {Number} [t=undefined] - tolerance in pixel\n     * @return {Boolean}\n     * @example\n     * var circle = new Circle([0, 0], 1000)\n     *     .addTo(layer);\n     * var contains = circle.containsPoint(new maptalks.Point(400, 300));\n     */\n    containsPoint(containerPoint: Point, t?: number): boolean;\n    _containsPoint(containerPoint: Point, t?: number): boolean;\n    /**\n     * 显示几何图形\n     * @english\n     * Show the geometry.\n     *\n     * @return {Geometry} this\n     * @fires Geometry#show\n     */\n    show(): this;\n    /**\n     * 隐藏几何图形\n     * @english\n     * Hide the geometry\n     *\n     * @return {Geometry} this\n     * @fires Geometry#hide\n     */\n    hide(): this;\n    /**\n     * 几何图形是否可见\n     * @english\n     * Whether the geometry is visible\n     *\n     * @returns {Boolean}\n     */\n    isVisible(): boolean;\n    /**\n     * symbol是否可见\n     * @english\n     * Whether the geometry symbol is visible\n     *\n     * @returns {Boolean}\n     */\n    symbolIsVisible(): boolean;\n    /**\n     * 获取几何图形所在层级，默认是0\n     * @english\n     * Get zIndex of the geometry, default is 0\n     * @return {Number} zIndex\n     */\n    getZIndex(): number;\n    /**\n     * 给几何图形设置新的层级并触发zindexchange事件（将导致层对几何体进行排序并进行渲染）\n     * @english\n     * Set a new zIndex to Geometry and fire zindexchange event (will cause layer to sort geometries and render)\n     * @param {Number} zIndex - new zIndex\n     * @return {Geometry} this\n     * @fires Geometry#zindexchange\n     */\n    setZIndex(zIndex: number): this;\n    /**\n     * 仅将新的zIndex设置为Geometry，而不触发zindexchange事件\n     * 当需要更新许多几何图形的zIndex时，可以用来提高性能\n     * 当更新了N个几何体时，可以将setZIndexSilently与（N-1）个几何体一起使用，并将setZIendex与要排序和渲染的层的最后一个几何体一同使用。\n     * @english\n     * Only set a new zIndex to Geometry without firing zindexchange event. <br>\n     * Can be useful to improve perf when a lot of geometries' zIndex need to be updated. <br>\n     * When updated N geometries, You can use setZIndexSilently with (N-1) geometries and use setZIndex with the last geometry for layer to sort and render.\n     * @param {Number} zIndex - new zIndex\n     * @return {Geometry} this\n     */\n    setZIndexSilently(zIndex: number): this;\n    /**\n     * 将几何图形至于顶层\n     * @english\n     * Bring the geometry on the top\n     * @return {Geometry} this\n     * @fires Geometry#zindexchange\n     */\n    bringToFront(): this;\n    /**\n     * 将几何图形置于底层\n     * @english\n     * Bring the geometry to the back\n     * @return {Geometry} this\n     * @fires Geometry#zindexchange\n     */\n    bringToBack(): this;\n    /**\n     * 按给定偏移平移或移动几何体\n     * @english\n     * Translate or move the geometry by the given offset.\n     *\n     * @param  {Coordinate} offset - translate offset\n     * @return {Geometry} this\n     * @fires Geometry#positionchange\n     * @fires Geometry#shapechange\n     */\n    /**\n     * Translate or move the geometry by the given offset.\n     *\n     * @param  {Number} x - x offset\n     * @param  {Number} y - y offset\n     * @return {Geometry} this\n     * @fires Geometry#positionchange\n     * @fires Geometry#shapechange\n     */\n    translate(x: number | Coordinate, y?: number): this;\n    /**\n     * 闪烁几何图形，按一定的内部显示和隐藏计数次数。\n     * @english\n     * Flash the geometry, show and hide by certain internal for times of count.\n     *\n     * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)\n     * @param {Number} [count=4]          - flash times\n     * @param {Function} [cb=null]        - callback function when flash ended\n     * @param {*} [context=null]          - callback context\n     * @return {Geometry} this\n     */\n    flash(interval: number, count: number, cb: () => void, context: any): this;\n    /**\n     * 返回不包含事件侦听器的几何体的副本。\n     * @english\n     * Returns a copy of the geometry without the event listeners.\n     * @returns {Geometry} copy\n     */\n    copy(): Geometry;\n    /**\n     * 将其自身从图层中移除（如果有的话）。\n     * @english\n     * remove itself from the layer if any.\n     * @returns {Geometry} this\n     * @fires Geometry#removestart\n     * @fires Geometry#remove\n     */\n    remove(): this;\n    /**\n     * 将几何对象导出成geojson对象\n     * @english\n     * Exports [geometry]{@link http://geojson.org/geojson-spec.html#feature-objects} out of a GeoJSON feature.\n     * @return {Object} GeoJSON Geometry\n     */\n    toGeoJSONGeometry(): {\n        [key: string]: any;\n    };\n    /**\n     * 导出geojson对象中的一个feature\n     * @english\n     * Exports a GeoJSON feature.\n     * @param {Object} [opts=null]              - export options\n     * @param {Boolean} [opts.geometry=true]    - whether export geometry\n     * @param {Boolean} [opts.properties=true]  - whether export properties\n     * @returns {Object} GeoJSON Feature\n     */\n    toGeoJSON(opts?: {\n        [key: string]: any;\n    }): {\n        [key: string]: any;\n    };\n    /**\n     * 从几何体中导出一个配置文件json。\n     * 除了导出特性对象，概要文件json还包含符号、构造选项和信息窗口信息。\n     * 配置文件json可以存储在其他地方，稍后用于重现几何图形\n     * 由于函数的序列化问题，概要文件json中不包括事件侦听器和上下文菜单\n     * @english\n     * Export a profile json out of the geometry. <br>\n     * Besides exporting the feature object, a profile json also contains symbol, construct options and infowindow info.<br>\n     * The profile json can be stored somewhere else and be used to reproduce the geometry later.<br>\n     * Due to the problem of serialization for functions, event listeners and contextmenu are not included in profile json.\n     * @example\n     *     // an example of a profile json.\n     * var profile = {\n            \"feature\": {\n                  \"type\": \"Feature\",\n                  \"id\" : \"point1\",\n                  \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.0, 0.5]},\n                  \"properties\": {\"prop0\": \"value0\"}\n            },\n            //construct options.\n            \"options\":{\n                \"draggable\" : true\n            },\n            //symbol\n            \"symbol\":{\n                \"markerFile\"  : \"http://foo.com/icon.png\",\n                \"markerWidth\" : 20,\n                \"markerHeight\": 20\n            },\n            //infowindow info\n            \"infowindow\" : {\n                \"options\" : {\n                    \"style\" : \"black\"\n                },\n                \"title\" : \"this is a infowindow title\",\n                \"content\" : \"this is a infowindow content\"\n            }\n        };\n     * @param {Object}  [options=null]          - export options\n     * @param {Boolean} [opts.geometry=true]    - whether export feature's geometry\n     * @param {Boolean} [opts.properties=true]  - whether export feature's properties\n     * @param {Boolean} [opts.options=true]     - whether export construct options\n     * @param {Boolean} [opts.symbol=true]      - whether export symbol\n     * @param {Boolean} [opts.infoWindow=true]  - whether export infowindow\n     * @return {Object} profile json object\n     */\n    toJSON(options?: {\n        [key: string]: any;\n    }): {\n        [key: string]: any;\n    };\n    /**\n     * 获取几何图形的地理长度\n     * @english\n     * Get the geographic length of the geometry.\n     * @returns {Number} geographic length, unit is meter\n     */\n    getLength(): number;\n    /**\n     * 获取几何图形的面积\n     * @english\n     * Get the geographic area of the geometry.\n     * @returns {Number} geographic area, unit is sq.meter\n     */\n    getArea(): number;\n    /**\n     * 按给定角度围绕轴心点旋转几何体\n     * @english\n     * Rotate the geometry of given angle around a pivot point\n     * @param {Number} angle - angle to rotate in degree\n     * @param {Coordinate} [pivot=null]  - optional, will be the geometry's center by default\n     * @returns {Geometry} this\n     */\n    rotate(angle: number, pivot?: Coordinate): this;\n    _rotatePrjCoordinates(coordinates: Coordinate | Array<Coordinate>): Coordinate | Coordinate[];\n    isRotated(): boolean;\n    /**\n     * 获取连线的连接点\n     * @english\n     * Get the connect points for [ConnectorLine]{@link ConnectorLine}\n     * @return {Coordinate[]} connect points\n     * @private\n     */\n    _getConnectPoints(): Coordinate[];\n    _initOptions(options: GeometryOptionsType): void;\n    _bindLayer(layer: OverlayLayer): void;\n    _prepareSymbol(symbol: any): any;\n    _checkAndCopySymbol(symbol: any): any;\n    _getSymbol(): any;\n    /**\n     * 将外部符号设置为几何体，例如VectorLayer的setStyle中的样式\n     * @english\n     * Sets a external symbol to the geometry, e.g. style from VectorLayer's setStyle\n     * @private\n     * @param {Object} symbol - external symbol\n     */\n    _setExternSymbol(symbol: any): this;\n    _getInternalSymbol(): any;\n    _getPrjExtent(): Extent;\n    _unbind(): void;\n    _getInternalId(): number;\n    _setInternalId(id: number): void;\n    _getMeasurer(): any;\n    _getProjection(): WithNull<ProjectionType>;\n    _verifyProjection(): void;\n    _getExternalResources(): string[];\n    _getPainter(): any;\n    _getMaskPainter(): CollectionPainter | Painter;\n    _removePainter(): void;\n    _paint(extent?: Extent): void;\n    _clearCache(): void;\n    _clearProjection(): void;\n    _repaint(): void;\n    onHide(): void;\n    onShapeChanged(): void;\n    onPositionChanged(): void;\n    onSymbolChanged(): void;\n    _genSizeSymbol(): void;\n    _getSizeSymbol(symbol: any): any;\n    _getCompiledSymbol(): any;\n    onConfig(conf: any): void;\n    /**\n     * 将父对象设置为几何体，通常是“多重多边形”、“几何集合”等\n     * @english\n     * Set a parent to the geometry, which is usually a MultiPolygon, GeometryCollection, etc\n     * @param {GeometryCollection} geometry - parent geometry\n     * @private\n     */\n    _setParent(geometry?: Geometry | GeometryCollection): void;\n    _getParent(): any;\n    _fireEvent(eventName: string, param?: BaseEventParamsType): void;\n    _toJSON(options?: any): any;\n    _exportGraphicOptions(options: any): any;\n    _exportGeoJSONGeometry(): any;\n    _exportProperties(): any;\n    _hitTestTolerance(): number;\n    _getAltitude(): number | number[] | number[][];\n    getAltitude(): number | number[] | number[][];\n    hasAltitude(): boolean;\n    setAltitude(alt: number): this;\n    _genMinMaxAlt(): void;\n    getMinAltitude(): number;\n    getMaxAltitude(): number;\n    _clearAltitudeCache(): Geometry;\n}\nexport type GeometryOptionsType = {\n    id?: string;\n    visible?: boolean;\n    interactive?: boolean;\n    editable?: boolean;\n    cursor?: string;\n    antiMeridian?: boolean;\n    defaultProjection?: string;\n    measure?: string;\n    draggable?: boolean;\n    dragShadow?: boolean;\n    dragOnAxis?: string;\n    dragOnScreenAxis?: boolean;\n    zIndex?: number;\n    symbol?: any;\n    properties?: {\n        [key: string]: any;\n    };\n};\nexport default Geometry;\n"},{"path":"types/geometry/GeometryCollection.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport PointExtent from '../geo/PointExtent';\nimport Extent from '../geo/Extent';\nimport Geometry, { GeometryOptionsType } from './Geometry';\nimport * as projections from '../geo/projection';\nimport Point from '../geo/Point';\nimport { GeometryEditOptionsType } from './ext/Geometry.Edit';\ntype ProjectionCommon = typeof projections.Common;\n/**\n * @classdesc\n * Represents a GeometryCollection.\n * @category geometry\n * @extends Geometry\n * @example\n * var marker = new Marker([0, 0]),\n *     line = new LineString([[0, 0], [0, 1]]),\n *     polygon = new Polygon([[0, 0], [0, 1], [1, 3]]);\n * var collection = new GeometryCollection([marker, line, polygon])\n *     .addTo(layer);\n */\ndeclare class GeometryCollection extends Geometry {\n    _geometries: Geometry[];\n    _pickGeometryIndex: number;\n    _originalSymbol: any;\n    _draggbleBeforeEdit: any;\n    _editing: boolean;\n    /**\n     * @param {Geometry[]} geometries - GeometryCollection's geometries\n     * @param {Object} [options=null] - options defined in [nGeometryCollection]{@link GeometryCollection#options}\n     */\n    constructor(geometries?: Geometry[], opts?: GeometryOptionsType);\n    getContainerExtent(out?: PointExtent): PointExtent;\n    /**\n     * 将多个几何图形设置到几何图形集合\n     * @english\n     * Set new geometries to the geometry collection\n     * @param {Geometry[]} geometries\n     * @return {GeometryCollection} this\n     * @fires GeometryCollection#shapechange\n     */\n    setGeometries(_geometries: Geometry[]): this;\n    /**\n     * 获取几何集合中的几何图形们\n     * @english\n     * Get geometries of the geometry collection\n     * @return {Geometry[]} geometries\n     */\n    getGeometries(): Geometry[];\n    /**\n     * 按顺序对集合中存在的每个几何体执行一次提供的回调。\n     * @english\n     * Executes the provided callback once for each geometry present in the collection in order.\n     * @param  {Function} fn             - a callback function\n     * @param  {*} [context=undefined]   - callback's context\n     * @return {GeometryCollection} this\n     */\n    forEach(fn: (geo: Geometry, index: number) => void, context?: any): this;\n    /**\n     * 创建一个几何集合类，这个集合类的所有元素都通过所提供的函数实现的测试\n     * @english\n     * Creates a GeometryCollection with all elements that pass the test implemented by the provided function.\n     * @param  {Function} fn      - Function to test each geometry\n     * @param  {*} [context=undefined]    - Function's context\n     * @return {GeometryCollection} A GeometryCollection with all elements that pass the test\n     * @example\n     * var filtered = collection.filter(['==', 'foo', 'bar]);\n     * @example\n     * var filtered = collection.filter(geometry => geometry.getProperties().foo === 'bar');\n     */\n    filter(fn?: (geo: Geometry) => boolean, context?: any): GeometryCollection;\n    /**\n     * 按给定偏移平移或移动几何体集合。\n     * @english\n     * Translate or move the geometry collection by the given offset.\n     * @param  {Coordinate} offset - translate offset\n     * @return {GeometryCollection} this\n     */\n    translate(offset: Coordinate): this;\n    /**\n     * 几何图形集合是否为空\n     * @english\n     * Whether the geometry collection is empty\n     * @return {Boolean}\n     */\n    isEmpty(): boolean;\n    /**\n     * 移除本身，如果图层含有的话\n     * @english\n     * remove itself from the layer if any.\n     * @returns {Geometry} this\n     * @fires GeometryCollection#removestart\n     * @fires GeometryCollection#remove\n     * @fires GeometryCollection#removeend\n     */\n    remove(): any;\n    /**\n     * 显示几何集合\n     * @english\n     * Show the geometry collection.\n     * @return {GeometryCollection} this\n     * @fires GeometryCollection#show\n     */\n    show(): this;\n    /**\n     * 隐藏几何集合\n     * @english\n     * Hide the geometry collection.\n     * @return {GeometryCollection} this\n     * @fires GeometryCollection#hide\n     */\n    hide(): this;\n    onConfig(config?: string | Record<string, any>): void;\n    getSymbol(): any;\n    setSymbol(s?: any): this;\n    _setExternSymbol(symbol: any): this;\n    /**\n     * 绑定几何几何到一个图层\n     * @english\n     * bind this geometry collection to a layer\n     * @param  {Layer} layer\n     * @private\n     */\n    _bindLayer(): void;\n    _bindGeometriesToLayer(): void;\n    /**\n     * 检查几何图形的类型是否有效\n     * @english\n     * Check whether the type of geometries is valid\n     * @param  {Geometry[]} geometries - geometries to check\n     * @private\n     */\n    _checkGeometries(geometries: Geometry[]): Geometry[];\n    _checkGeo(geo: Geometry): boolean;\n    _updateCache(): void;\n    _removePainter(): void;\n    _computeCenter(projection: null | ProjectionCommon): Coordinate;\n    _containsPoint(point: Point, t?: number): boolean;\n    _hitTestTolerance(): number;\n    _computeExtent(projection: null | ProjectionCommon): Extent;\n    _computePrjExtent(projection: null | ProjectionCommon): Extent;\n    _computeGeodesicLength(projection: null | ProjectionCommon): number;\n    _computeGeodesicArea(projection: null | ProjectionCommon): number;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        geometries: any[];\n    };\n    _toJSON(options?: any): any;\n    _clearProjection(): void;\n    /**\n     * 如果通过[ConnectorLine]连接，则获取连接点\n     * @english\n     * Get connect points if being connected by [ConnectorLine]{@link ConnectorLine}\n     * @private\n     * @return {Coordinate[]}\n     */\n    _getConnectPoints(): Coordinate[];\n    _getExternalResources(): any;\n    startEdit(opts?: GeometryEditOptionsType): this;\n    endEdit(): this;\n    isEditing(): boolean;\n}\nexport default GeometryCollection;\n"},{"path":"types/geometry/index.d.ts","content":"import Geometry from './Geometry';\nimport Marker from './Marker';\nimport LineString from './LineString';\nimport Polygon from './Polygon';\nimport MultiPoint from './MultiPoint';\nimport MultiLineString from './MultiLineString';\nimport MultiPolygon from './MultiPolygon';\nimport GeometryCollection from './GeometryCollection';\nimport GeoJSON from './GeoJSON';\nimport Circle from './Circle';\nimport Ellipse from './Ellipse';\nimport Rectangle from './Rectangle';\nimport Sector from './Sector';\nimport Curve from './Curve';\nimport ArcCurve from './ArcCurve';\nimport CubicBezierCurve from './CubicBezierCurve';\nimport QuadBezierCurve from './QuadBezierCurve';\nimport TextMarker from './TextMarker';\nimport TextBox from './TextBox';\nimport Label from './Label';\nimport { ConnectorLine, ArcConnectorLine } from './ConnectorLine';\nexport type Geometries = ArcCurve | Circle | ConnectorLine | ArcConnectorLine | CubicBezierCurve | Curve | Ellipse | Geometry | GeometryCollection | Label | LineString | Marker | MultiLineString | MultiPoint | MultiPolygon | Polygon | QuadBezierCurve | Rectangle | Sector | TextBox | TextMarker;\nexport type PathLikeGeometries = Curve | ArcCurve | CubicBezierCurve | QuadBezierCurve | LineString | MultiLineString | ConnectorLine | Rectangle | Polygon | MultiPolygon | Circle | Sector | Ellipse;\nexport { ArcCurve, Circle, ConnectorLine, ArcConnectorLine, CubicBezierCurve, Curve, Ellipse, GeoJSON, Geometry, GeometryCollection, Label, LineString, Marker, MultiLineString, MultiPoint, MultiPolygon, Polygon, QuadBezierCurve, Rectangle, Sector, TextBox, TextMarker };\n"},{"path":"types/geometry/Label.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport { TextSymbol, VectorMarkerSymbol } from '../symbol';\nimport TextMarker, { TextMarkerOptionsType } from './TextMarker';\n/**\n * @classdesc\n * Represents point type geometry for text labels.<br>\n * A label is used to draw text (with a box background if specified) on a particular coordinate.\n * @category geometry\n * @extends TextMarker\n * @mixes TextEditable\n * @example\n * var label = new maptalks.Label('label with a box',\n    [0, 0],\n    {\n      'draggable' : true,\n      'boxStyle' : {\n        'padding' : [12, 8],\n        'verticalAlignment' : 'top',\n        'horizontalAlignment' : 'right',\n        'minWidth' : 300,\n        'minHeight' : 200,\n        'symbol' : {\n          'markerType' : 'square',\n          'markerFill' : 'rgb(135,196,240)',\n          'markerFillOpacity' : 0.9,\n          'markerLineColor' : '#34495e',\n          'markerLineWidth' : 1\n        }\n      },\n      'textSymbol': {\n        'textFaceName' : 'monospace',\n        'textFill' : '#34495e',\n        'textHaloFill' : '#fff',\n        'textHaloRadius' : 4,\n        'textSize' : 18,\n        'textWeight' : 'bold',\n        'textVerticalAlignment' : 'top'\n      }\n    });\n */\ndeclare class Label extends TextMarker {\n    options: any;\n    /**\n     * @param {String} content                 - Label's text content\n     * @param {Coordinate} coordinates         - coordinates\n     * @param {Object} [options=null]          - construct options defined in [Label]{@link Label#options}\n     */\n    constructor(content: string, coordinates: Coordinate | Array<number>, options?: LabelOptionsType);\n    /**\n     * 获取标注的边框样式\n     * @english\n     * Get label's box style\n     * @return {Object}\n     */\n    getBoxStyle(): BoxStyle;\n    /**\n     * 设置标注的边框样式\n     * @english\n     * Set a new box style to the label\n     * @param {Object}\n     * @returns {Label} this\n     */\n    setBoxStyle(style: BoxStyle): this;\n    /**\n     * 获取标注的文本样式\n     * Get label's text symbol\n     * @return {Object}\n     */\n    getTextSymbol(): TextSymbol;\n    /**\n     * 给标注设置新的文本样式\n     * @english\n     * Set a new text symbol to the label\n     * @param {Object} symbol\n     * @returns {Label} this\n     */\n    setTextSymbol(symbol: TextSymbol): this;\n    static fromJSON(json: {\n        [key: string]: any;\n    }): Label;\n    _canEdit(): boolean;\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        content: string;\n    };\n    _refresh(): void;\n    _getBoxSize(symbol: any): any;\n}\nexport default Label;\ntype BoxStyle = {\n    padding?: [number, number];\n    verticalAlignment?: 'top' | 'middle' | 'bottom';\n    horizontalAlignment?: 'left' | 'middle' | 'right';\n    minWidth?: number;\n    minHeight?: number;\n    symbol?: VectorMarkerSymbol;\n};\nexport type LabelOptionsType = TextMarkerOptionsType & {\n    textSymbol?: TextSymbol;\n    boxStyle?: BoxStyle;\n};\n"},{"path":"types/geometry/LineString.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Path, { PathOptionsType } from './Path';\nimport Extent from '../geo/Extent';\nimport { AnySymbol, LineSymbol } from '../symbol';\n/**\n * 表示LineString类型的Geometry。\n * @english\n * Represents a LineString type Geometry.\n * @category geometry\n * @extends Path\n * @example\n * var line = new LineString(\n *     [\n *         [121.45942, 31.24123],\n *         [121.46371, 31.24226],\n *         [121.46727, 31.23870],\n *         [121.47019, 31.24145]\n *     ]\n * ).addTo(layer);\n */\nexport declare class LineString extends Path {\n    /**\n     * @param {Coordinate[]|Number[][]} coordinates - coordinates of the line string\n     * @param {Object} [options=null] - construct options defined in [LineString]{@link LineString#options}\n     */\n    constructor(coordinates: LineStringCoordinatesType, options?: LineStringOptionsType);\n    getOutline(): any;\n    /**\n     * 给线段设置坐标\n     * @english\n     * Set new coordinates to the line string\n     * @param {Coordinate[]|Number[][]} coordinates - new coordinates\n     * @fires LineString#shapechange\n     * @return {LineString} this\n     */\n    setCoordinates(coordinates: Array<Coordinate> | Array<Array<number>>): this;\n    /**\n     * 获取线段的坐标\n     * @english\n     * Get coordinates of the line string\n     * @return {Coordinate[]|Number[][]} coordinates\n     */\n    getCoordinates(): Coordinate[];\n    /**\n     * 获取具有给定范围的线串的交点的中心\n     * @english\n     * Get center of linestring's intersection with give extent\n     * @example\n     *  const extent = map.getExtent();\n     *  const center = line.getCenterInExtent(extent);\n     * @param {Extent} extent\n     * @return {Coordinate} center, null if line doesn't intersect with extent\n     */\n    getCenterInExtent(extent: Extent): Coordinate;\n    _computeGeodesicLength(measurer: any): number;\n    _computeGeodesicArea(): number;\n}\nexport default LineString;\nexport type LineStringCoordinatesType = Array<Coordinate> | Array<Array<number>>;\nexport type LineStringOptionsType = PathOptionsType & {\n    arrowStyle?: 'classic' | [number, number];\n    arrowPlacement?: 'vertex-first' | 'vertex-last' | 'vertex-firstlast' | 'point';\n    symbol?: LineSymbol | Array<AnySymbol>;\n};\n"},{"path":"types/geometry/Marker.d.ts","content":"import Extent from '../geo/Extent';\nimport PointExtent from '../geo/PointExtent';\nimport Geometry, { GeometryOptionsType } from './Geometry';\nimport { AnyMarkerSymbol } from '../symbol';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\ndeclare const Marker_base: {\n    new (...args: any[]): {\n        _coordinates: Coordinate;\n        _pcenter: Coordinate;\n        _dirtyCoords: boolean;\n        getMap?(): import(\"src\").Map;\n        _getProjection?(): {\n            code: string;\n            is(code: string): boolean;\n            project(p: Coordinate): Coordinate;\n            unproject(p: Coordinate): Coordinate;\n            projectCoords(coordinates: Coordinate[] | Coordinate[][] | Coordinate[][][], antiMeridian?: boolean): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            unprojectCoords(projCoords: Coordinate[] | Coordinate[][] | Coordinate[][][]): Coordinate[] | Coordinate[][] | Coordinate[][][];\n            isSphere(): boolean;\n            isOutSphere(pcoord: Coordinate): boolean;\n            wrapCoord(pcoord: Coordinate): Coordinate;\n            getCircum(): Record<string, number>;\n            getSphereExtent(): Extent;\n        };\n        onPositionChanged?(): void;\n        _verifyProjection?(): void;\n        _clearCache?(): void;\n        getCoordinates(): Coordinate;\n        setCoordinates(coordinates: number[] | Coordinate): any;\n        _getCenter2DPoint(res?: number): Point;\n        _getPrjCoordinates(): Coordinate;\n        _setPrjCoordinates(pcenter: Coordinate): void;\n        _updateCache(): void;\n        _clearProjection(): void;\n        _computeCenter(): Coordinate;\n    };\n} & typeof Geometry;\n/**\n * @classdesc\n * Represents a Point type Geometry.\n * @category geometry\n * @extends Geometry\n * @mixes CenterMixin\n * @example\n * var marker = new Marker([100, 0], {\n *     'id' : 'marker0',\n *     'symbol' : {\n *         'markerFile'  : 'foo.png',\n *         'markerWidth' : 20,\n *         'markerHeight': 20,\n *     },\n *     'properties' : {\n *         'foo' : 'value'\n *     }\n * });\n */\nexport declare class Marker extends Marker_base {\n    isPoint: boolean;\n    /**\n     * @param {Coordinate} coordinates      - coordinates of the marker\n     * @param {Object} [options=null]       - construct options defined in [Marker]{@link Marker#options}\n     */\n    constructor(coordinates: MarkerCoordinatesType, options?: MarkerOptionsType);\n    getOutline(): Marker;\n    setSymbol(symbol: AnyMarkerSymbol): this;\n    _getSizeSymbol(symbol: any): any;\n    _setExternSymbol(symbol: any): this;\n    _isDynamicSize(): boolean;\n    _getFixedExtent(): PointExtent;\n    _isVectorMarker(): boolean;\n    /**\n     * 可以编辑，只能编辑带有矢量符号、矢量路径符号或图像符号的标记。\n     * @english\n     * Can be edited, only marker with a vector symbol, vector path symbol or a image symbol can be edited.\n     * @return {Boolean}\n     * @private\n     */\n    _canEdit(): boolean;\n    _containsPoint(point: Point, t?: number): boolean;\n    _computeExtent(): Extent;\n    _computePrjExtent(): Extent;\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _getSprite(resources: any, canvasClass: any): any;\n}\nexport default Marker;\nexport type MarkerCoordinatesType = Coordinate | Array<number>;\nexport type MarkerOptionsType = GeometryOptionsType & {\n    hitTestForEvent?: boolean;\n    collision?: boolean;\n    symbol?: AnyMarkerSymbol | Array<AnyMarkerSymbol>;\n};\n"},{"path":"types/geometry/MultiGeometry.d.ts","content":"import GeometryCollection from './GeometryCollection';\nimport { GeometryOptionsType, type Geometry } from './Geometry';\nimport { MultiPathsCoordinates, PathCoordinates, PathsCoordinates } from './Path';\nimport { MarkerCoordinatesType } from './Marker';\nimport { LineStringCoordinatesType } from './LineString';\nimport { PolygonCoordinatesType } from './Polygon';\n/**\n * MultiPoint、MultiLineString和MultiPolygon的父类\n * @english\n * The parent class for MultiPoint, MultiLineString and MultiPolygon\n * @category geometry\n * @abstract\n * @extends {GeometryCollection}\n */\ntype MultiGeometryCoordinates = PathCoordinates | PathsCoordinates | MultiPathsCoordinates;\ntype SingleGeometryCreateCoordinates = MarkerCoordinatesType | LineStringCoordinatesType | PolygonCoordinatesType;\nexport type MultiGeometryCreateCoordinates = Array<SingleGeometryCreateCoordinates>;\ntype MultiGeometryData = Array<SingleGeometryCreateCoordinates | Geometry>;\ntype GeometryClass<T> = (new (coordinates: SingleGeometryCreateCoordinates, options: Record<string, any>) => T);\ndeclare class MultiGeometry extends GeometryCollection {\n    GeometryType: GeometryClass<Geometry>;\n    /**\n     * @param  {Class} geoType      Type of the geometry\n     * @param  {String} type        type in String, e.g. \"MultiPoint\", \"MultiLineString\"\n     * @param  {Geometry[]} data    data\n     * @param  {Object} [options=null] configuration options\n     */\n    constructor(geoType: GeometryClass<Geometry>, type: string, data: MultiGeometryData, options?: GeometryOptionsType);\n    /**\n     * 获取集合中得坐标\n     * @english\n     * Get coordinates of the collection\n     * @return {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates\n     */\n    getCoordinates(): MultiGeometryCoordinates;\n    /**\n     * 设置集合得坐标\n     * @english\n     * Set new coordinates to the collection\n     * @param {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates\n     * @returns {Geometry} this\n     * @fires maptalk.Geometry#shapechange\n     */\n    setCoordinates(coordinates: MultiGeometryCreateCoordinates): this;\n    _initData(data: MultiGeometryData): void;\n    _checkGeo(geo: Geometry): boolean;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        coordinates: any;\n    };\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n    };\n}\nexport default MultiGeometry;\n"},{"path":"types/geometry/MultiLineString.d.ts","content":"import MultiPath from './MultiPath';\nimport { LineStringCoordinatesType, LineStringOptionsType } from './LineString';\n/**\n * @classdesc\n * Represents a Geometry type of MultiLineString\n * @category geometry\n * @extends MultiGeometry\n * @example\n * var multiLineString = new MultiLineString(\n *      [\n *          [\n *              [121.5289450479131, 31.2420083925986],\n *              [121.52860172515919, 31.238926401171824]\n *          ],\n *          [\n *              [121.53091915374796, 31.241898323208233],\n *              [121.53104789978069, 31.23859618183896]\n *          ],\n *          [\n *               [121.5324641061405, 31.241898323208233],\n *               [121.53242119079626, 31.239146546752256]\n *           ]\n *       ],\n *       {\n *           symbol:{\n *               'lineColor' : '#000000',\n *               'lineWidth' : 5,\n *               'lineOpacity' : 1\n *           },\n *          draggable:true\n *      }\n * ).addTo(layer);\n */\ndeclare class MultiLineString extends MultiPath {\n    /**\n     * @param {Number[][][]|Coordinate[][]|LineString[]} data - construct data, coordinates or an array of linestrings\n     * @param {Object} [options=null]           - options defined in [MultiLineString]{@link MultiLineString#options}\n     */\n    constructor(data: Array<LineStringCoordinatesType>, options?: LineStringOptionsType);\n}\nexport default MultiLineString;\n"},{"path":"types/geometry/MultiPath.d.ts","content":"import MultiGeometry from './MultiGeometry';\nimport Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\n/**\n * @classdesc\n * An abstract class for MultiPolygon and MultiLineString\n * @category geometry\n * @extends MultiGeometry\n */\ndeclare class MultiPath extends MultiGeometry {\n    /**\n     * 获取（MultiLineString或MultiPolygon）与给定范围的交点的中心\n     * @english\n     * Get center of (MultiLineString or MultiPolygon)'s intersection with give extent\n     * @example\n     *  const extent = map.getExtent();\n     *  const center = geometry.getCenterInExtent(extent);\n     * @param {Extent} extent\n     * @return {Coordinate} center, null if line doesn't intersect with extent\n     */\n    getCenterInExtent(extent: Extent): null | Coordinate;\n}\nexport default MultiPath;\n"},{"path":"types/geometry/MultiPoint.d.ts","content":"import MultiGeometry from './MultiGeometry';\nimport { MarkerCoordinatesType, MarkerOptionsType } from './Marker';\nimport Coordinate from '../geo/Coordinate';\n/**\n * @classdesc\n * Represents a Geometry type of MultiPoint.\n * @category geometry\n * @extends MultiGeometry\n * @example\n * var multiPoint = new MultiPoint(\n *     [\n *         [121.5080881906138, 31.241128104458117],\n *         [121.50804527526954, 31.237238340103413],\n *         [121.5103728890997, 31.23888972560888]\n *     ]\n * ).addTo(layer);\n */\ndeclare class MultiPoint extends MultiGeometry {\n    /**\n     * @param {Number[][]|Coordinate[]|Marker[]} data - construct data, coordinates or an array of markers\n     * @param {Object} [options=null] - options defined in [nMultiPoint]{@link MultiPoint#options}\n     */\n    constructor(data: Array<MarkerCoordinatesType>, opts?: MarkerOptionsType);\n    /**\n     * 找到给定坐标的最近点\n     * @english\n     * Find the closet point to the give coordinate\n     * @param {Coordinate} coordinate coordinate\n     * @returns {Coordinate} coordinate\n     */\n    findClosest(coordinate: Coordinate): Coordinate;\n}\nexport default MultiPoint;\n"},{"path":"types/geometry/MultiPolygon.d.ts","content":"import MultiPath from './MultiPath';\nimport { PolygonCoordinatesType, PolygonOptionsType } from './Polygon';\n/**\n * @classdesc\n * Represents a Geometry type of MultiPolygon\n * @category geometry\n * @extends MultiGeometry\n * @example\n * var multiPolygon = new MultiPolygon(\n *       [\n *           [\n *               [\n *                   [121.55074604278596, 31.242008515751614],\n *                   [121.55074604278596, 31.23914637638951],\n *                   [121.55349262481711, 31.23914637638951],\n *                   [121.55349262481711, 31.24134802974913],\n *                   [121.5518618417361, 31.241384723537074],\n *                   [121.55074604278596, 31.242008515751614]\n *               ]\n *           ],\n *           [\n *               [\n *                   [121.5543080163576, 31.241054478932387],\n *                   [121.5543938470461, 31.240100432478293],\n *                   [121.55555256134048, 31.240173821009137],\n *                   [121.55542381530773, 31.240981091085693],\n *                   [121.5543080163576, 31.241054478932387]\n *               ]\n *           ]\n *\n *       ],\n *       {\n *           symbol:{\n *               'lineColor' : '#000000',\n *               'lineWidth' : 2,\n *               'lineDasharray' : null,//线形\n *               'lineOpacity' : 1,\n *               'polygonFill' : 'rgb(255, 0, 0)',\n *               'polygonOpacity' : 0.8\n *           },\n *           draggable:true\n * }).addTo(layer);\n */\ndeclare class MultiPolygon extends MultiPath {\n    /**\n     * @param {Number[][][][]|Coordinate[][][]|Polygon[]} data - construct data, coordinates or an array of polygons\n     * @param {Object} [options=null]           - options defined in [MultiPolygon]{@link MultiPolygon#options}\n     */\n    constructor(data: Array<PolygonCoordinatesType>, opts?: PolygonOptionsType);\n}\nexport default MultiPolygon;\n"},{"path":"types/geometry/Path.d.ts","content":"import { AnimationOptionsType, Frame, Player } from '../core/Animation';\nimport Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\nimport Geometry, { GeometryOptionsType } from './Geometry';\nimport Point from '../geo/Point';\nimport { CommonProjectionType } from '../geo/projection';\nimport { FillSymbol, LineSymbol } from '../symbol';\ntype animateShowCallback = (frame: Frame, currentCoord: Coordinate) => void;\nexport type PathCoordinates = Array<Coordinate>;\nexport type PathsCoordinates = Array<PathCoordinates>;\nexport type MultiPathsCoordinates = Array<PathsCoordinates>;\n/**\n * 一个抽象类Path，包含Path几何类的常用方法，例如LineString、Polygon\n * @english\n * An abstract class Path containing common methods for Path geometry classes, e.g. LineString, Polygon\n * @abstract\n * @category geometry\n * @extends Geometry\n */\nexport declare class Path extends Geometry {\n    _coordinates: Coordinate[];\n    _showPlayer: Player;\n    _animIdx: number;\n    _animLenSoFar: number;\n    _animTailRatio: number;\n    _prjAniShowCenter: Coordinate;\n    _aniShowCenter: Coordinate;\n    _tempCoord: Coordinate;\n    _tempPrjCoord: Point;\n    _simplified: boolean;\n    _prjCoords: Array<Coordinate>;\n    hasHoles?(): boolean;\n    _getPrjHoles?(): Array<Array<Coordinate>>;\n    /**\n     * 动画展示线条\n     * @english\n     * Show the linestring with animation\n     * @param  {Object} [options=null] animation options\n     * @param  {Number} [options.duration=1000] duration\n     * @param  {String} [options.easing=out] animation easing\n     * @param  {Function} [cb=null] callback function in animation, function parameters: frame, currentCoord\n     * @example\n     *  line.animateShow({\n     *    duration : 2000,\n     *    easing : 'linear'\n     *  }, function (frame, currentCoord) {\n     *    //frame is the animation frame\n     *    //currentCoord is current coordinate of animation\n     *  });\n     * @return {LineString}         this\n     */\n    animateShow(options?: (AnimationOptionsType | animateShowCallback), cb?: animateShowCallback): Player | undefined;\n    _drawAnimShowFrame(t: number, duration: number, length: number, coordinates: Coordinate[], prjCoords: Array<Coordinate>): Coordinate;\n    _getCenterInExtent(extent: Extent, coordinates: Coordinate[], clipFn: any): Coordinate;\n    /**\n     * 将投影坐标转换为视点\n     * @english\n     * Transform projected coordinates to view points\n     * @param  {Coordinate[]} prjCoords           - projected coordinates\n     * @param  {Boolean} disableSimplify          - whether to disable simplify\\\n     * @param  {Number} zoom                      - 2d points' zoom level\n     * @returns {Point[]}\n     * @private\n     */\n    _getPath2DPoints(prjCoords: PathCoordinates | PathsCoordinates, disableSimplify: boolean, res?: number): Point | Array<Point> | Array<Array<Point>>;\n    _shouldSimplify(): boolean;\n    _setPrjCoordinates(prjPoints: PathCoordinates): void;\n    _getPrjCoordinates(): PathCoordinates;\n    _updateCache(): void;\n    _clearProjection(): void;\n    _projectCoords(points: PathCoordinates | PathsCoordinates): PathCoordinates | PathsCoordinates;\n    _unprojectCoords(prjPoints: PathCoordinates | PathsCoordinates): PathCoordinates | PathsCoordinates;\n    _computeCenter(): null | Coordinate;\n    _computeExtent(_?: any): Extent;\n    _computePrjExtent(_?: any): Extent;\n    _get2DLength(): number;\n    _hitTestTolerance(): number;\n    _coords2Extent(coords: PathsCoordinates, proj?: CommonProjectionType): Extent;\n}\nexport default Path;\nexport type PathOptionsType = GeometryOptionsType & {\n    'smoothness'?: boolean;\n    'enableClip'?: boolean;\n    'enableSimplify'?: boolean;\n    'simplifyTolerance'?: number;\n    'symbol'?: FillSymbol | LineSymbol;\n};\n"},{"path":"types/geometry/Polygon.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Path, { PathCoordinates, PathOptionsType, PathsCoordinates } from './Path';\nimport Extent from '../geo/Extent';\nimport { AnySymbol, FillSymbol } from '../symbol';\nimport { LineStringCoordinatesType } from './LineString';\n/**\n * @classdesc\n * Geometry class for polygon type\n * @category geometry\n * @extends Path\n * @example\n * var polygon = new Polygon(\n *      [\n *          [\n *              [121.48053653961283, 31.24244899384889],\n *              [121.48049362426856, 31.238559229494186],\n *              [121.49032123809872, 31.236210614999653],\n *              [121.49366863494917, 31.242926029397037],\n *              [121.48577221160967, 31.243880093267567],\n *              [121.48053653961283, 31.24244899384889]\n *          ]\n *      ]\n *  ).addTo(layer);\n */\nexport type PolygonCoordinatesType = Array<Array<Coordinate>> | Array<Array<number>>;\nexport type RingCoordinates = PathCoordinates;\nexport type RingsCoordinates = PathsCoordinates;\nexport declare class Polygon extends Path {\n    _holes: RingsCoordinates;\n    _prjHoles: RingsCoordinates;\n    _prjShell: RingCoordinates;\n    _getShell?(): RingCoordinates;\n    /**\n     * @param {Number[][]|Number[][][]|Coordinate[]|Coordinate[][]} coordinates - coordinates, shell coordinates or all the rings.\n     * @param {Object} [options=null] - construct options defined in [Polygon]{@link Polygon#options}\n     */\n    constructor(coordinates: PolygonCoordinatesType | LineStringCoordinatesType, options?: PolygonOptionsType);\n    getOutline(): null | Polygon;\n    /**\n     * 设置多边形坐标\n     * @english\n     * Set coordinates to the polygon\n     *\n     * @param {Number[][]|Number[][][]|Coordinate[]|Coordinate[][]} coordinates - new coordinates\n     * @return {Polygon} this\n     * @fires Polygon#shapechange\n     */\n    setCoordinates(coordinates: PolygonCoordinatesType | LineStringCoordinatesType): this;\n    /**\n     * 获取多边形坐标\n     * @english\n     * Gets polygons's coordinates\n     *\n     * @returns {Coordinate[][]}\n     */\n    getCoordinates(): RingsCoordinates;\n    /**\n     * 获取具有给定范围的线串的交点的中心\n     * @english\n     * Get center of linestring's intersection with give extent\n     * @example\n     *  const extent = map.getExtent();\n     *  const center = line.getCenterInExtent(extent);\n     * @param {Extent} extent\n     * @return {Coordinate} center, null if line doesn't intersect with extent\n     */\n    getCenterInExtent(extent: Extent): Coordinate;\n    /**\n     * 获取多边形的外壳坐标\n     * @english\n     * Gets shell's coordinates of the polygon\n     *\n     * @returns {Coordinate[]}\n     */\n    getShell(): RingCoordinates;\n    /**\n     * 获取多边形的洞的坐标（如果有）。\n     * @english\n     * Gets holes' coordinates of the polygon if it has.\n     * @returns {Coordinate[][]}\n     */\n    getHoles(): RingsCoordinates;\n    /**\n     * 判断多边形是否带有洞\n     * @english\n     * Whether the polygon has any holes inside.\n     *\n     * @returns {Boolean}\n     */\n    hasHoles(): boolean;\n    _projectRings(): void;\n    _setPrjCoordinates(prjCoords: RingCoordinates): void;\n    _cleanRing(ring: RingCoordinates): void;\n    /**\n     * 检查环是否有效\n     * @english\n     * Check if ring is valid\n     * @param  {*} ring ring to check\n     * @return {Boolean} is ring a closed one\n     * @private\n     */\n    _checkRing(ring: RingCoordinates): boolean;\n    /**\n     * 如果第一个坐标与最后一个坐标相等，则删除最后一个座标。\n     * @english\n     * If the first coordinate is equal with the last one, then remove the last coordinates.\n     * @private\n     */\n    _trimRing(ring: RingCoordinates): RingCoordinates;\n    /**\n     * 如果第一个坐标与最后一个不同，则复制第一个坐标并添加到环中。\n     * @english\n     * If the first coordinate is different with the last one, then copy the first coordinates and add to the ring.\n     * @private\n     */\n    _copyAndCloseRing(ring: RingCoordinates): RingCoordinates;\n    _getPrjShell(): RingCoordinates;\n    _getPrjHoles(): RingsCoordinates;\n    _computeGeodesicLength(measurer: any): number;\n    _computeGeodesicArea(measurer: any): number;\n    _updateCache(): void;\n    _clearCache(): any;\n    _clearProjection(): void;\n}\nexport default Polygon;\nexport type PolygonOptionsType = PathOptionsType & {\n    'symbol'?: FillSymbol | Array<AnySymbol>;\n};\n"},{"path":"types/geometry/QuadBezierCurve.d.ts","content":"import Curve, { CurveOptionsType } from './Curve';\n/**\n * @classdesc\n * Quadratic Bezier Curve\n * @category geometry\n * @extends Curve\n * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve\n * @example\n * var curve = new QuadBezierCurve(\n *     [\n *         [121.47083767181408,31.214448123476995],\n *         [121.4751292062378,31.215475523000404],\n *         [121.47869117980943,31.211916269810335]\n *     ],\n *     {\n *         symbol : {\n *             'lineWidth' : 5\n *         }\n *     }\n * ).addTo(layer);\n */\ndeclare class QuadBezierCurve extends Curve {\n    static fromJSON(json: any): QuadBezierCurve;\n    _toJSON(options: any): any;\n    _paintOn(ctx: CanvasRenderingContext2D, points: any, lineOpacity: number): void;\n    _getArrowPoints(arrows: any[], segments: [], lineWidth: number, arrowStyle: any, tolerance: any): void;\n}\nexport default QuadBezierCurve;\nexport type QuadBezierCurveOptionsType = CurveOptionsType;\n"},{"path":"types/geometry/Rectangle.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\nimport Point from '../geo/Point';\nimport { CommonProjectionType } from '../geo/projection';\nimport Polygon, { PolygonOptionsType, RingCoordinates, RingsCoordinates } from './Polygon';\n/**\n * @classdesc\n * Represents a Rectangle geometry.\n * @category geometry\n * @extends Polygon\n * @example\n * var rectangle = new Rectangle([100, 0], 1000, 500, {\n *     id : 'rectangle0'\n * });\n */\nexport declare class Rectangle extends Polygon {\n    _coordinates: Coordinate;\n    _width: number;\n    _height: number;\n    _pnw: any;\n    static fromJSON(json: any): Rectangle;\n    /**\n     * @param {Coordinate} coordinates  - northwest of the rectangle\n     * @param {Number} width                     - width of the rectangle, in meter\n     * @param {Number} height                    - height of the rectangle, in meter\n     * @param {Object} [options=null]            - options defined in [Rectangle]{@link Rectangle#options}\n     */\n    constructor(coordinates: Coordinate | Array<number>, width: number, height: number, opts?: RectangleOptionsType);\n    /**\n     * Get coordinates of rectangle's northwest\n     * @return {Coordinate}\n     */\n    getCoordinates(): Coordinate;\n    /**\n     * Set a new coordinate for northwest of the rectangle\n     * @param {Coordinate} nw - coordinates of new northwest\n     * @return {Rectangle} this\n     * @fires Rectangle#positionchange\n     */\n    setCoordinates(nw: Coordinate | Array<number>): this;\n    /**\n     * Get rectangle's width\n     * @return {Number}\n     */\n    getWidth(): number;\n    /**\n     * Set new width to the rectangle\n     * @param {Number} width - new width\n     * @fires Rectangle#shapechange\n     * @return {Rectangle} this\n     */\n    setWidth(width: number): this;\n    /**\n     * Get rectangle's height\n     * @return {Number}\n     */\n    getHeight(): number;\n    /**\n     * Set new height to rectangle\n     * @param {Number} height - new height\n     * @fires Rectangle#shapechange\n     * @return {Rectangle} this\n     */\n    setHeight(height: number): this;\n    /**\n     * Gets the shell of the rectangle as a polygon\n     * @return {Coordinate[]} - shell coordinates\n     */\n    getShell(): Coordinate[];\n    _getShell(): RingCoordinates;\n    /**\n     * Rectangle won't have any holes, always returns null\n     * @return {Object[]} an empty array\n     */\n    getHoles(): RingsCoordinates;\n    animateShow(): this;\n    _getPrjCoordinates(): Coordinate;\n    _setPrjCoordinates(pnw: any): void;\n    _getPrjShell(): RingCoordinates;\n    _updateCache(): void;\n    _clearProjection(): void;\n    _computeCenter(measurer?: any): Coordinate;\n    _containsPoint(point: Point, tolerance?: number): boolean;\n    _computePrjExtent(projection: CommonProjectionType): Extent;\n    _computeExtent(measurer?: any): Extent;\n    _getSouthEast(measurer: any): Coordinate;\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _exportGeoJSONGeometry(): {\n        type: string;\n        coordinates: any;\n    };\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        coordinates: number[];\n        width: number;\n        height: number;\n    };\n}\nexport default Rectangle;\nexport type RectangleOptionsType = PolygonOptionsType;\n"},{"path":"types/geometry/Sector.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Extent from '../geo/Extent';\nimport Point from '../geo/Point';\nimport Circle, { CircleOptionsType } from './Circle';\nimport { RingCoordinates } from './Polygon';\n/**\n * @classdesc\n * Represents a sector Geometry.\n * @category geometry\n * @extends Circle\n * @example\n * var sector = new Sector([100, 0], 1000, 30, 120, {\n *     id : 'sector0'\n * });\n */\nexport declare class Sector extends Circle {\n    startAngle: number;\n    endAngle: number;\n    static fromJSON(json: Record<string, any>): Sector;\n    /**\n     * @param {Coordinate} center - center of the sector\n     * @param {Number} radius           - radius of the sector, in meter\n     * @param {Number} startAngle       - start angle of the sector, in degree\n     * @param {Number} endAngle         - end angle of the sector, in degree\n     * @param {Object} [options=null]   - construct options defined in [Sector]{@link Sector#options}\n     */\n    constructor(coordinates: Coordinate | Array<number>, radius: number, startAngle: number, endAngle: number, opts?: SectorOptionsType);\n    /**\n     * Get the sector's start angle\n     * @return {Number}\n     */\n    getStartAngle(): number;\n    /**\n     * Set a new start angle to the sector\n     * @param {Number} startAngle\n     * @return {Sector} this\n     * @fires Sector#shapechange\n     */\n    setStartAngle(startAngle: number): this;\n    /**\n     * Get the sector's end angle\n     * @return {Number}\n     */\n    getEndAngle(): number;\n    /**\n     * Set a new end angle to the sector\n     * @param {Number} endAngle\n     * @return {Sector} this\n     * @fires Sector#shapechange\n     */\n    setEndAngle(endAngle: number): this;\n    _correctAngles(): [number, number];\n    /**\n     * Gets the shell of the sector as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Sector#options}\n     * @return {Coordinate[]} - shell coordinates\n     */\n    getShell(): RingCoordinates;\n    _getShell(): RingCoordinates;\n    getRotateOffsetAngle(): number;\n    _getPrjShell(): RingCoordinates;\n    _computePrjExtent(): Extent;\n    _containsPoint(point: Point, tolerance?: number): boolean;\n    _computeGeodesicLength(): number;\n    _computeGeodesicArea(): number;\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        subType: string;\n        coordinates: number[];\n        radius: number;\n        startAngle: number;\n        endAngle: number;\n    };\n}\nexport default Sector;\nexport type SectorOptionsType = CircleOptionsType & {\n    numberOfShellPoints?: number;\n};\n"},{"path":"types/geometry/TextBox.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport TextMarker, { TextMarkerOptionsType } from './TextMarker';\nimport { TextSymbol, VectorMarkerSymbol } from '../symbol';\nimport { GeometryEditOptionsType } from './ext/Geometry.Edit';\n/**\n * @classdesc\n * Represents point type geometry for text boxes.<br>\n * A TextBox is used to draw a box with text inside on a particular coordinate.\n * @category geometry\n * @extends TextMarker\n * @mixes TextEditable\n * @example\n * var textbox = new maptalks.TextBox('This is a textbox',\n    [0, 0], 200, 90,\n    {\n      'draggable' : true,\n      'textStyle' : {\n        'wrap' : true,\n        'padding' : [12, 8],\n        'verticalAlignment' : 'top',\n        'horizontalAlignment' : 'right',\n        'symbol' : {\n          'textFaceName' : 'monospace',\n          'textFill' : '#34495e',\n          'textHaloFill' : '#fff',\n          'textHaloRadius' : 4,\n          'textSize' : 18,\n          'textWeight' : 'bold'\n        }\n      },\n      'boxSymbol': {\n        // box's symbol\n        'markerType' : 'square',\n        'markerFill' : 'rgb(135,196,240)',\n        'markerFillOpacity' : 0.9,\n        'markerLineColor' : '#34495e',\n        'markerLineWidth' : 1\n      }\n    });\n */\ndeclare class TextBox extends TextMarker {\n    options: TextBoxOptionsType;\n    _width: number;\n    _height: number;\n    _oldWidth: any;\n    _oldHeight: any;\n    /**\n     * @param {String} content                 - TextBox's text content\n     * @param {Coordinate} coordinates         - coordinates\n     * @param {Number} width                   - width in pixel\n     * @param {Number} height                  - height in pixel\n     * @param {Object} [options=null]          - construct options defined in [TextBox]{@link TextBox#options}\n     */\n    constructor(content: string, coordinates: Coordinate | Array<number>, width: number, height: number, options?: TextBoxOptionsType);\n    /**\n     * 获取文本框得宽度\n     * @english\n     * Get textbox's width\n     * @return {Number}\n     */\n    getWidth(): number;\n    /**\n     * 设置文本框得宽度\n     * @english\n     * Set new width to textbox\n     * @param {Number} width\n     * returns {TextBox} this\n     */\n    setWidth(width: number): this;\n    /**\n     * 获取文本框高度\n     * @english\n     * Get textbox's height\n     * @return {Number}\n     */\n    getHeight(): number;\n    /**\n     * 设置文本框高度\n     * @english\n     * Set new height to textbox\n     * @param {Number} height\n     * returns {TextBox} this\n     */\n    setHeight(height: number): this;\n    /**\n     * 获取文本框边框样式\n     * @english\n     * Get textbox's boxSymbol\n     * @return {Object} boxsymbol\n     */\n    getBoxSymbol(): VectorMarkerSymbol;\n    /**\n     * 设置文本框边框样式\n     * @english\n     * Set a new box symbol to textbox\n     * @param {Object} symbol\n     * returns {TextBox} this\n     */\n    setBoxSymbol(symbol: VectorMarkerSymbol): this;\n    /**\n     * 获取文本框文本样式\n     * @english\n     * Get textbox's text style\n     * @return {Object}\n     */\n    getTextStyle(): TextStyle | null;\n    /**\n     * 设置文本框文本样式\n     * @english\n     * Set a new text style to the textbox\n     * @param {Object} style new text style\n     * returns {TextBox} this\n     */\n    setTextStyle(style: TextStyle): this;\n    static fromJSON(json: {\n        [key: string]: any;\n    }): TextBox;\n    _toJSON(options: any): {\n        feature: {\n            [key: string]: any;\n        };\n        width: number;\n        height: number;\n        subType: string;\n        content: string;\n    };\n    _refresh(): void;\n    startEdit(opts: GeometryEditOptionsType): this;\n    endEdit(): this;\n}\nexport default TextBox;\ntype TextStyle = {\n    wrap?: boolean;\n    padding?: [number, number];\n    verticalAlignment?: 'top' | 'middle' | 'bottom';\n    horizontalAlignment?: 'left' | 'middle' | 'right';\n    symbol?: TextSymbol;\n};\nexport type TextBoxOptionsType = TextMarkerOptionsType & {\n    boxSymbol?: VectorMarkerSymbol;\n    textStyle?: TextStyle;\n};\n"},{"path":"types/geometry/TextMarker.d.ts","content":"/// <reference types=\"node\" />\nimport { AnyAaaaRecord } from 'dns';\nimport { TextSymbol, VectorMarkerSymbol } from '../symbol';\nimport Marker, { MarkerOptionsType } from './Marker';\n/**\n * @classdesc\n * Base class for  the Text marker classes, a marker which has text and background box. <br>\n * It is abstract and not intended to be instantiated.\n * @category geometry\n * @abstract\n * @extends Marker\n */\ndeclare class TextMarker extends Marker {\n    _content: string;\n    _refreshing: boolean;\n    _refresh?(): void;\n    getTextStyle?(): any;\n    setTextStyle?(tyle?: any): any;\n    setTextSymbol?(style?: any): any;\n    setBoxStyle?(style?: any): any;\n    getBoxStyle?(): any;\n    setBoxSymbol?(style?: any): any;\n    /**\n     * 获取标签的文本内容\n     * @english\n     * Get text content of the label\n     * @returns {String}\n     */\n    getContent(): string;\n    /**\n     * 给标签设置文本内容\n     * @english\n     * Set a new text content to the label\n     * @return {Label} this\n     * @fires Label#contentchange\n     */\n    setContent(content: string): this;\n    onAdd(): void;\n    toJSON(): {\n        [key: string]: any;\n    };\n    setSymbol(symbol: any): this;\n    _parseSymbol(symbol: any): any;\n    _getTextSize(symbol: any): any;\n    _getInternalSymbol(): AnyAaaaRecord;\n    _getDefaultTextSymbol(): TextSymbol;\n    _getDefaultBoxSymbol(): VectorMarkerSymbol;\n    _getDefaultPadding(): [number, number];\n}\nexport default TextMarker;\nexport type TextMarkerOptionsType = MarkerOptionsType;\n"},{"path":"types/GlobalConfig.d.ts","content":"/**\n * global config\n * idle/worker etc\n */\ndeclare const GlobalConfig: {\n    isTest: boolean;\n    idleLog: boolean;\n    idleTimeRemaining: number;\n    idleForceTimeThreshold: number;\n    idleTimeout: number;\n    workerCount: number;\n    taskCountPerWorkerMessage: number;\n    maxFPS: number;\n};\nexport default GlobalConfig;\n"},{"path":"types/handler/Drag.d.ts","content":"import Handler from './Handler';\nimport Point from '../geo/Point';\n/**\n * Drag handler\n * @category handler\n * @protected\n * @extends Handler\n */\ndeclare class DragHandler extends Handler {\n    options: DragOptionsType;\n    _onMouseDown: (e: any) => any;\n    moved: boolean;\n    startPos: Point;\n    interupted: boolean;\n    addHooks(): void;\n    removeHooks(): void;\n    constructor(dom: HTMLElement, options?: DragOptionsType);\n    enable(): this;\n    disable(): this;\n    onMouseDown(event: DragEventType): void;\n    onMouseMove(event: DragEventType): void;\n    onMouseUp(event: DragEventType): void;\n    _offEvents(): void;\n}\nexport default DragHandler;\ntype DragOptionsType = {\n    rightclick?: boolean;\n    cancelOn?: (e: DragEventType) => boolean;\n    ignoreMouseleave?: boolean;\n};\ntype DragEventType = MouseEvent | TouchEvent;\n"},{"path":"types/handler/Handler.d.ts","content":"declare class Base {\n}\ndeclare const Handler_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any; /**\n             * 启用Handler\n             *\n             * @english\n             * Enables the handler\n             */\n        }[]>; /**\n         * 检查Handler是否启用\n         *\n         * @english\n         * Returns true if the handler is enabled.\n         */\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Base;\n/**\n * 所有交互Handler类的基类\n *\n * @english\n * Base class for all the interaction handlers\n * @category handler\n * @abstract\n * @protected\n */\ndeclare abstract class Handler extends Handler_base {\n    target: any;\n    dom?: HTMLElement;\n    _enabled: boolean;\n    constructor(target: any);\n    abstract addHooks(): void;\n    abstract removeHooks(): void;\n    /**\n     * 启用Handler\n     *\n     * @english\n     * Enables the handler\n     */\n    enable(): this;\n    /**\n     * 停用Handler\n     *\n     * @english\n     * Disables the handler\n     */\n    disable(): this;\n    /**\n     * 检查Handler是否启用\n     *\n     * @english\n     * Returns true if the handler is enabled.\n     */\n    enabled(): boolean;\n    /**\n     * 从target上移除Handler\n     *\n     * @english\n     * remove handler from target\n     */\n    remove(): void;\n}\nexport default Handler;\n"},{"path":"types/handler/Handlerable.d.ts","content":"import { MixinConstructor } from \"../core/Mixin\";\nimport Handler from \"./Handler\";\n/**\n * A mixin, to enable a class with [interaction handlers]{@link Handler}\n * @protected\n * @category handler\n * @mixin Handlerable\n */\nexport default function <T extends MixinConstructor>(Base: T): {\n    new (...args: any[]): {\n        _handlers?: Handler[];\n        /**\n         * Register a handler\n         * @param {String} name       - name of the handler\n         * @param {Handler}           - handler class\n         * @return {*} this\n         * @protected\n         * @function Handerable.addHandler\n         */\n        addHandler(name: any, handlerClass: any): any;\n        /**\n         * Removes a handler\n         * @param {String} name       - name of the handler\n         * @return {*} this\n         * @protected\n         * @function Handerable.removeHandler\n         */\n        removeHandler(name: any): any;\n        _clearHandlers(): void;\n    };\n} & T;\n"},{"path":"types/index.d.ts","content":"export { default as GlobalConfig } from './GlobalConfig';\nexport * from './core/ResourceProxy';\nexport * from './core/Constants';\nexport { default as Browser } from './core/Browser';\nimport * as Util from './core/util';\nimport * as DomUtil from './core/util/dom';\nimport * as StringUtil from './core/util/strings';\nimport * as MapboxUtil from './core/mapbox';\nimport * as MicroTask from './core/MicroTask';\nexport { Util, DomUtil, StringUtil, MapboxUtil, MicroTask };\nexport { default as LRUCache } from './core/util/LRUCache';\nexport { default as Ajax } from './core/Ajax';\nexport { default as Canvas } from './core/Canvas';\nexport { default as Class } from './core/Class';\nexport { default as Eventable } from './core/Eventable';\nexport { GlobalEvent } from './core/GlobalEvent';\nexport { default as JSONAble } from './core/JSONAble';\nexport { default as CollisionIndex } from './core/CollisionIndex';\nexport { default as Handlerable } from './handler/Handlerable';\nexport { default as Handler } from './handler/Handler';\nexport { default as DragHandler } from './handler/Drag';\nexport * from './geo';\nimport { Map } from './map';\nexport { Map };\nexport { MapTool, DrawTool, AreaTool, DistanceTool } from './map/tool';\nexport { default as SpatialReference } from './map/spatial-reference/SpatialReference';\n/** @namespace ui */\nimport * as ui from './ui';\n/** @namespace control */\nimport * as control from './control';\nexport { ui, control };\nexport * from './layer';\nexport * from './geometry';\nimport './geometry/editor/GeometryEditor';\nimport './geometry/editor/TextEditable';\nimport './geometry/ext/Geometry.Animation';\nimport './geometry/ext/Geometry.Drag';\nimport './geometry/ext/Geometry.Edit';\nimport './geometry/ext/Geometry.Events';\nimport './geometry/ext/Geometry.InfoWindow';\nimport './geometry/ext/Geometry.JSON';\n/**\n * @namespace renderer\n */\nimport * as renderer from './renderer';\nexport { renderer };\nimport './renderer/geometry';\nimport * as symbolizer from './renderer/geometry/symbolizers';\n/** @namespace animation */\nimport * as animation from './core/Animation';\nexport { symbolizer, animation };\nexport { animate } from './core/Animation';\nexport { registerWorkerAdapter } from './core/worker/Worker';\nimport Actor from './core/worker/Actor';\n/**\n * @namespace worker\n */\ndeclare const worker: {\n    Actor: typeof Actor;\n};\nexport { worker };\n"},{"path":"types/lang/translator.d.ts","content":"import Class from '../core/Class';\nexport interface ILanguage {\n    distancetool: Distancetool;\n    areatool: Areatool;\n}\ninterface Distancetool {\n    start: string;\n    units: Units;\n}\ninterface Areatool {\n    units: Units;\n}\ninterface Units {\n    mile: string;\n    feet: string;\n    kilometer: string;\n    meter: string;\n}\nexport type Lang = 'zh-CN' | 'es-MX' | 'en-US';\n/**\n *  Maptalks text's language\n*/\nexport declare class TranslatorError extends Error {\n    constructor(msg: string);\n}\ndeclare class Translator extends Class {\n    languages: {\n        [key: string]: ILanguage;\n    };\n    nodes: ILanguage;\n    constructor(lang: Lang);\n    /**\n     *  Method to update the language of maptalks\n     *  @param {string} lang - Available Langs (zh-CN, en-US, es-MX)\n     *  @example setLang('zh-CN')\n    */\n    setLang(lang: Lang): void;\n    _validateNestedProps(nestedProps: string[]): void;\n    /**\n     *  method to return the text of the current language available on lang json's\n     *  @param {string} textNode - Accesible property with the current language text.\n     *  @return {string} Text to show in screen\n     *  @example document.write(translate('areatool.units.kilometer'))\n    */\n    translate(textNode?: string | null): string;\n}\nexport default Translator;\n"},{"path":"types/layer/CanvasLayer.d.ts","content":"import CanvasLayerRenderer from '../renderer/layer/canvaslayer/CanvasLayerRenderer';\nimport Layer, { LayerOptionsType } from './Layer';\n/**\n * 一个带有HTML5 2D canvas的layer\n * CanvasLayer为canvas操作提供了一些接口方法\n * 你可以直接使用CanvasLayer,但不能通过JSON序列化/反序列化实现CanvasLayer\n * 更推荐使用子类扩展CanvasLayer，并在子类中实现canvas绘画\n *\n * @english\n * A layer with a HTML5 2D canvas context.<br>\n * CanvasLayer provides some interface methods for canvas context operations. <br>\n * You can use it directly, but can't serialize/deserialize a CanvasLayer with JSON in this way. <br>\n * It is more recommended to extend it with a subclass and implement canvas paintings inside the subclass.\n * @example\n *  var layer = new CanvasLayer('canvas');\n *\n *  layer.prepareToDraw = function (context) {\n *      var size = map.getSize();\n *      return [size.width, size.height]\n *  };\n *\n *  layer.draw = function (context, width, height) {\n *      context.fillStyle = \"#f00\";\n *      context.fillRect(0, 0, w, h);\n *  };\n *  layer.addTo(map);\n * @category layer\n * @extends Layer\n * @param {String|Number} id - layer's id\n * @param {Object} options - options defined in [options]{@link CanvasLayer#options}\n */\ndeclare class CanvasLayer extends Layer {\n    isCanvasRender(): boolean;\n    /**\n     * 准备画布的接口函数\n     *\n     * @engilsh\n     * An optional interface function called only once before the first draw, useful for preparing your canvas operations.\n     * @param  {CanvasRenderingContext2D } context - CanvasRenderingContext2D of the layer canvas.\n     * @return {Object[]} objects that will be passed to function draw(context, ..) as parameters.\n     */\n    prepareToDraw(): void;\n    /**\n     * 绘制something的接口函数\n     *\n     * @engilsh\n     * The required interface function to draw things on the layer canvas.\n     * @param  {CanvasRenderingContext2D} context - CanvasRenderingContext2D of the layer canvas.\n     * @param  {*} params.. - parameters returned by function prepareToDraw(context).\n     */\n    draw(...params: any[]): void;\n    /**\n     * map交互绘制接口\n     * 默认情况调用draw()\n     * 如果你知道如何提升绘制性能可以重新此方法\n     *\n     * @english\n     * An optional interface function to draw while map is interacting.\n     * By default, it will call draw method instead.\n     * You can override this method if you are clear with what to draw when interacting to improve performance.\n     * @param  {CanvasRenderingContext2D} context - CanvasRenderingContext2D of the layer canvas.\n     * @param  {*} params.. - parameters returned by function prepareToDraw(context).\n     */\n    /**\n     * 重绘\n     *\n     * @english\n     * Redraw the layer\n     * @return this\n     */\n    redraw(): this;\n    /**\n     * 播放\n     *\n     * @english\n     * Start animation\n     * @return this\n     */\n    play(): this;\n    /**\n     * 暂停\n     *\n     * @english\n     * Pause the animation\n     * @return this\n     */\n    pause(): this;\n    /**\n     * 是否正在播放\n     *\n     * @english\n     * If the animation is playing\n     * @return\n     */\n    isPlaying(): boolean;\n    /**\n     * 清空画布\n     *\n     * @engilsh\n     * Clear layer's canvas\n     * @return this\n     */\n    clearCanvas(): this;\n    /**\n     * 要求map不触发任何事件下重绘canvas\n     *\n     * @engilsh\n     * Ask the map to redraw the layer canvas without firing any event.\n     * @return this\n     */\n    requestMapToRender(): this;\n    /**\n     * 要求map触发layerload事件重绘canvas\n     *\n     * @engilsh\n     * Ask the map to redraw the layer canvas and fire layerload event\n     * @return this\n     */\n    completeRender(): this;\n    /**\n     * canvas创建完成后的回调函数\n     *\n     * @english\n     * Callback function when layer's canvas is created. <br>\n     * Override it to do anything needed.\n     */\n    onCanvasCreate(): this;\n    /**\n     * map zoomstart事件回调\n     *\n     * @engilsh\n     * The event callback for map's zoomstart event.\n     * @param  {Object} param - event parameter\n     */\n    onZoomStart(): void;\n    /**\n     * map zooming事件回调\n     *\n     * @engilsh\n     * The event callback for map's zooming event.\n     * @param  {Object} param - event parameter\n     */\n    onZooming(): void;\n    /**\n     * map zoomend事件回调\n     *\n     * @engilsh\n     * The event callback for map's zoomend event.\n     * @param  {Object} param - event parameter\n     */\n    onZoomEnd(): void;\n    /**\n     * map movestart事件回调\n     *\n     * @engilsh\n     * The event callback for map's movestart event.\n     * @param  {Object} param - event parameter\n     */\n    onMoveStart(): void;\n    /**\n     * map moving事件回调\n     *\n     * @engilsh\n     * The event callback for map's moving event.\n     * @param  {Object} param - event parameter\n     */\n    onMoving(): void;\n    /**\n     * map moveend事件回调\n     *\n     * @engilsh\n     * The event callback for map's moveend event.\n     * @param  {Object} param - event parameter\n     */\n    onMoveEnd(): void;\n    /**\n     * map resize事件回调\n     *\n     * @engilsh\n     * The event callback for map's resize event.\n     * @param  {Object} param - event parameter\n     */\n    onResize(): void;\n    /**\n     * double buffer的回调函数\n     * 默认情况下just draws and return，如果你需要在绘制之前处理canvas，可以重写改函数\n     *\n     * @engilsh\n     * The callback function to double buffer. <br>\n     * In default, it just draws and return, and you can override it if you need to process the canvas image before drawn.\n     * @param  {CanvasRenderingContext2D} bufferContext CanvasRenderingContext2D of double buffer of the layer canvas.\n     * @param  {CanvasRenderingContext2D} context CanvasRenderingContext2D of the layer canvas.\n     */\n    doubleBuffer(bufferContext: CanvasRenderingContext2D): CanvasLayer;\n    _getRenderer(): CanvasLayerRenderer;\n}\nexport default CanvasLayer;\nexport type CanvasLayerOptionsType = LayerOptionsType & {\n    doubleBuffer?: boolean;\n    animation?: boolean;\n    fps?: number | string;\n};\n"},{"path":"types/layer/ImageLayer.d.ts","content":"import CanvasRenderer from '../renderer/layer/CanvasRenderer';\nimport Extent from '../geo/Extent';\nimport Layer, { LayerOptionsType } from './Layer';\nimport { PointExtent } from '../geo';\n/**\n * images layer,可指定图像地理位置及透明的\n *\n * @english\n * @classdesc\n * A layer used to display images, you can specify each image's geographic extent and opacity\n * @category layer\n * @extends Layer\n * @param id - tile layer's id\n * @param images=null - images\n * @param options=null - options defined in [ImageLayer]{@link ImageLayer#options}\n * @example\n * new ImageLayer(\"images\", [{\n        url : 'http://example.com/foo.png',\n        extent: [xmin, ymin, xmax, ymax],\n        opacity : 1\n    }])\n */\ndeclare class ImageLayer extends Layer {\n    _images: Array<ImageItem>;\n    _imageData: Array<ImageDataItem>;\n    constructor(id: string, images?: ImageLayerOptionsType | Array<ImageItem>, options?: ImageLayerOptionsType);\n    onAdd(): void;\n    /**\n     * 设置图像并重新绘制\n     *\n     * @english\n     * Set images and redraw\n     * @param images - new images\n     * @return this\n     */\n    setImages(images: Array<ImageItem>): this;\n    /**\n     * 获取图像\n     *\n     * @english\n     * Get images\n     * @return\n     */\n    getImages(): Array<ImageItem>;\n    _prepareImages(images: Array<ImageItem>): void;\n    getRenderer(): ImageLayerCanvasRenderer;\n}\nexport declare class ImageLayerCanvasRenderer extends CanvasRenderer {\n    _imageLoaded: boolean;\n    isDrawable(): boolean;\n    checkResources(): any;\n    retireImage(image: ImageType): void;\n    refreshImages(): void;\n    draw(timestamp?: number, context?: any): void;\n    _drawImages(timestamp?: number, context?: any): void;\n    _drawImage(image: ImageType, extent: PointExtent, opacity: number): void;\n    drawOnInteracting(event?: any, timestamp?: number, context?: any): void;\n}\ndeclare const ImageLayerGLRenderer_base: {\n    new (...args: any[]): {\n        gl: import(\"src/renderer/types\").TileRenderingContext;\n        canvas: import(\"src/renderer/types\").TileRenderingCanvas;\n        canvas2?: import(\"src/renderer/types\").TileRenderingCanvas;\n        _debugInfoCanvas?: import(\"src/renderer/types\").TileRenderingCanvas;\n        program?: import(\"src/renderer/types\").TileRenderingProgram; /**\n         * 设置图像并重新绘制\n         *\n         * @english\n         * Set images and redraw\n         * @param images - new images\n         * @return this\n         */\n        _layerAlt: number;\n        _layerAltitude: number;\n        layer?: any;\n        texBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        _debugBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        posBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        _imageBuffers?: import(\"src/renderer/types\").TileImageBuffer[];\n        _buffers?: import(\"src/renderer/types\").TileImageBuffer[];\n        _textures?: WebGLTexture[];\n        getMap?(): import(\"src\").Map;\n        drawGLImage(image: import(\"src/renderer/types\").TileImageType, x: number, y: number, w: number, h: number, scale: number, opacity: number, debugInfo?: string, baseColor?: number[]): void;\n        drawDebug(uMatrix: import(\"src/core/util/mat4\").Matrix4InOut, x: number, y: number, w: number, h: number, debugInfo: string): void;\n        bufferTileData(x: number, y: number, w: number, h: number, buffer?: import(\"src/renderer/types\").TileImageBuffer): import(\"src/renderer/types\").TileImageBuffer;\n        createCanvas2(): void;\n        createGLContext(): void;\n        resizeGLCanvas(): void;\n        clearGLCanvas(): void;\n        disposeImage(image: import(\"src/renderer/types\").TileImageType): void;\n        _createTexture(image: import(\"src/renderer/types\").TileImageType): WebGLTexture;\n        getTexture(): WebGLTexture;\n        saveTexture(texture: WebGLTexture): void;\n        loadTexture(image: import(\"src/renderer/types\").TileImageType): WebGLTexture;\n        getImageBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        saveImageBuffer(buffer: import(\"src/renderer/types\").TileImageBuffer): void;\n        loadImageBuffer(data: Int16Array | Float32Array, glBuffer: import(\"src/renderer/types\").TileImageBuffer): import(\"src/renderer/types\").TileImageBuffer;\n        createImageBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        removeGLCanvas(): void;\n        createBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        enableVertexAttrib(attributes: import(\"src/renderer/types\").VertexAttrib): void;\n        createProgram(vert: string, frag: string): import(\"src/renderer/types\").TileRenderingProgram;\n        useProgram(program: import(\"src/renderer/types\").TileRenderingProgram): any;\n        enableSampler(sampler: string, texIdx?: number): WebGLUniformLocation;\n        _initUniforms(program: import(\"src/renderer/types\").TileRenderingProgram, uniforms: string[]): void;\n        _getUniform(program: import(\"src/renderer/types\").TileRenderingProgram, uniformName: string): WebGLUniformLocation;\n        set8(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Float32Array;\n        set8Int(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Int16Array;\n    };\n} & typeof ImageLayerCanvasRenderer;\nexport declare class ImageLayerGLRenderer extends ImageLayerGLRenderer_base {\n    drawOnInteracting(event: any, timestamp: number, context: any): void;\n    _prepareGLContext(): void;\n    _drawImages(timestamp?: number, parentContext?: any): void;\n    isDrawable(): boolean;\n    _drawImage(image: ImageType, extent: PointExtent, opacity: number): void;\n    createContext(): void;\n    resizeCanvas(canvasSize: any): void;\n    clearCanvas(): void;\n    retireImage(image: ImageType): void;\n    onRemove(): void;\n}\nexport default ImageLayer;\nexport type ImageItem = {\n    url: string;\n    extent: Extent | [number, number, number, number];\n    opacity?: number;\n};\nexport type ImageDataItem = ImageItem & {\n    extent2d: PointExtent;\n};\nexport type ImageType = HTMLImageElement | ImageBitmap;\ndeclare enum depthFuncEnum {\n    'never' = 0,\n    '<' = 1,\n    '=' = 2,\n    '<=' = 3,\n    ' >' = 4,\n    '!=' = 5,\n    '>=' = 6,\n    'always' = 7\n}\nexport type ImageLayerOptionsType = LayerOptionsType & {\n    crossOrigin?: string;\n    renderer?: 'canvas' | 'gl' | 'dom';\n    alphaTest?: boolean;\n    depthMask?: boolean;\n    depthFunc?: keyof typeof depthFuncEnum;\n};\n"},{"path":"types/layer/index.d.ts","content":"import Layer from './Layer';\nimport TileLayer from './tile/TileLayer';\nimport GroupTileLayer from './tile/GroupTileLayer';\nimport WMSTileLayer from './tile/WMSTileLayer';\nimport CanvasTileLayer from './tile/CanvasTileLayer';\nimport ImageLayer from './ImageLayer';\nimport OverlayLayer from './OverlayLayer';\nimport VectorLayer from './VectorLayer';\nimport CanvasLayer from './CanvasLayer';\nimport ParticleLayer from './ParticleLayer';\nimport TileSystem from './tile/tileinfo/TileSystem';\nimport TileConfig from './tile/tileinfo/TileConfig';\nexport { Layer, TileLayer, GroupTileLayer, WMSTileLayer, CanvasTileLayer, ImageLayer, OverlayLayer, VectorLayer, CanvasLayer, ParticleLayer, TileSystem, TileConfig };\n"},{"path":"types/layer/Layer.d.ts","content":"import Class from '../core/Class';\nimport CanvasRenderer from '../renderer/layer/CanvasRenderer';\nimport CollisionIndex from '../core/CollisionIndex';\nimport type { Map } from '../map';\nimport type { Marker, MultiPolygon, Polygon } from '../geometry';\nimport { CommonProjectionType } from '../geo/projection';\ndeclare const Layer_base: {\n    new (...args: any[]): {\n        _jsonType?: string;\n        getJSONType(): string;\n    };\n    registerJSONType(type: string): void;\n    getJSONClass(type: string): {\n        new (...args: any[]): {\n            _eventMap?: Record<string, {\n                handler: import(\"../core/Eventable\").HandlerFn;\n                context: any;\n            }[]>;\n            _eventParent?: any;\n            _eventTarget?: any;\n            on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            addEventListener(...args: any[]): any;\n            once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n            removeEventListener(...args: any[]): any;\n            listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n            getListeningEvents(): string[];\n            copyEventListeners(target: any): any;\n            fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n            _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n            _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n            _clearListeners(eventType: string): void;\n            _clearAllListeners(): void;\n            _setEventParent(parent: any): any;\n            _setEventTarget(target: any): any;\n            _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n        };\n    } & {\n        new (...args: any[]): {};\n        registerRenderer<T extends typeof Class>(name: string, clazz: T): any & typeof Class;\n        getRendererClass(name: string): Class;\n    } & typeof Class;\n} & {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & {\n    new (...args: any[]): {};\n    registerRenderer<T extends typeof Class>(name: string, clazz: T): any & typeof Class;\n    getRendererClass(name: string): Class;\n} & typeof Class;\n/**\n * layers的基础类，定义了所有layers公共方法。\n * 抽象类，不做实例化打算\n *\n * @english\n * @classdesc\n * Base class for all the layers, defines common methods that all the layer classes share. <br>\n * It is abstract and not intended to be instantiated.\n *\n * @category layer\n * @abstract\n * @extends Class\n * @mixes Eventable\n * @mixes JSONAble\n * @mixes Renderable\n */\ndeclare class Layer extends Layer_base {\n    _canvas: HTMLCanvasElement;\n    _renderer: CanvasRenderer;\n    _id: string;\n    _zIndex: number;\n    _drawTime: number;\n    map: Map;\n    _mask: Polygon | MultiPolygon | Marker;\n    _loaded: boolean;\n    _collisionIndex: CollisionIndex;\n    _optionsHook?(conf?: any): void;\n    _silentConfig: boolean | undefined | any;\n    options: LayerOptionsType;\n    constructor(id: string, options?: LayerOptionsType);\n    /**\n     * 加载tile layer,不能被子类重写\n     *\n     * @english\n     * load the tile layer, can't be overrided by sub-classes\n     */\n    load(): this;\n    /**\n     * 获取layer Id\n     *\n     * @english\n     * Get the layer id\n     * @returns id\n     */\n    getId(): string;\n    /**\n     * 为layer新设一个 Id\n     *\n     * @english\n     * Set a new id to the layer\n     * @param id - new layer id\n     * @return this\n     * @fires Layer#idchange\n     */\n    setId(id: string): this;\n    /**\n     * 将图层添加至 map\n     *\n     * @english\n     * Adds itself to a map.\n     * @param map - map added to\n     * @return this\n     */\n    addTo(map: Map): this;\n    /**\n     * 为layer 设置zIndex\n     *\n     * @engilsh\n     * Set a z-index to the layer\n     * @param zIndex - layer's z-index\n     * @return this\n     */\n    setZIndex(zIndex: number): this;\n    /**\n     * 获取layer 的 zIndex\n     *\n     * @english\n     * Get the layer's z-index\n     * @return\n     */\n    getZIndex(): number;\n    /**\n     * 获取 layer 的 minZoom\n     *\n     * @english\n     * Get Layer's minZoom to display\n     * @return\n     */\n    getMinZoom(): number;\n    /**\n     * 获取layer 的 maxZoom\n     *\n     * @english\n     * Get Layer's maxZoom to display\n     * @return\n     */\n    getMaxZoom(): number;\n    /**\n     * 获取 layer 的 opacity\n     *\n     * @english\n     * Get layer's opacity\n     * @returns {Number}\n     */\n    getOpacity(): number;\n    /**\n     * 设置 layer 的 opacity\n     *\n     * @english\n     * Set opacity to the layer\n     * @param opacity - layer's opacity\n     * @return this\n     */\n    setOpacity(op: number): this;\n    /**\n     * layer 是否为 HTML5 Canvas 渲染\n     *\n     * @english\n     * If the layer is rendered by HTML5 Canvas.\n     * @return\n     * @protected\n     */\n    isCanvasRender(): boolean;\n    /**\n     * 获取图层所在 map\n     *\n     * @english\n     * Get the map that the layer added to\n     * @returns {Map}\n     */\n    getMap(): Map;\n    /**\n     * 获取 layer 所在map 的 projection\n     *\n     * @english\n     * Get projection of layer's map\n     * @returns\n     */\n    getProjection(): CommonProjectionType;\n    /**\n     * 将图层置顶\n     *\n     * @english\n     * Brings the layer to the top of all the layers\n     * @returns this\n     */\n    bringToFront(): this;\n    /**\n     * 将图层置底\n     *\n     * @english\n     * Brings the layer under the bottom of all the layers\n     * @returns {Layer} this\n     */\n    bringToBack(): this;\n    /**\n     * 显示图层\n     *\n     * @english\n     * Show the layer\n     * @returns this\n     */\n    show(): this;\n    /**\n     * 隐藏图层\n     *\n     * @english\n     * Hide the layer\n     * @returns this\n     */\n    hide(): this;\n    /**\n     * layer 的当前 visible 状态\n     *\n     * @english\n     * Whether the layer is visible now.\n     * @return\n     */\n    isVisible(): boolean;\n    /**\n     * 移除图层\n     *\n     * @english\n     * Remove itself from the map added to.\n     * @returns this\n     */\n    remove(): this;\n    /**\n     * 获取 mask geometry\n     *\n     * @english\n     * Get the mask geometry of the layer\n     * @return {Geometry}\n     */\n    getMask(): Marker | MultiPolygon | Polygon;\n    /**\n     * 设置mask geometry, 只显示掩码的区域\n     *\n     * @english\n     * Set a mask geometry on the layer, only the area in the mask will be displayed.\n     * @param {Geometry} mask - mask geometry, can only be a Marker with vector symbol, a Polygon or a MultiPolygon\n     * @returns {Layer} this\n     */\n    setMask(mask: Polygon | MultiPolygon | Marker): this;\n    /**\n     * 移除mask\n     *\n     * @engilsh\n     * Remove the mask\n     * @returns {Layer} this\n     */\n    removeMask(): this;\n    /**\n     * 准备层的加载，是一个由子类重写的方法。\n     *\n     * @english\n     * Prepare Layer's loading, this is a method intended to be overrided by subclasses.\n     * @return true to continue loading, false to cease.\n     * @protected\n     */\n    onLoad(): boolean;\n    onLoadEnd(): void;\n    /**\n     * 是否加载layer\n     *\n     * @english\n     * Whether the layer is loaded\n     * @return\n     */\n    isLoaded(): boolean;\n    /**\n     * 获取collision index\n     *\n     * @english\n     * Get layer's collision index\n     * @returns {CollisionIndex}\n     */\n    getCollisionIndex(): CollisionIndex;\n    /**\n     * 清除 layer 的 collision index。\n     * 如果 collisionScope !== 'layer' 将忽略\n     *\n     * @english\n     * Clear layer's collision index.\n     * Will ignore if collisionScope is not layer\n     */\n    clearCollisionIndex(): this;\n    getRenderer(): CanvasRenderer;\n    onConfig(conf: {\n        [key: string]: any;\n    }): void;\n    onAdd(): void;\n    onRendererCreate(): void;\n    onCanvasCreate(): void;\n    onRemove(): void;\n    _bindMap(map: Map, zIndex?: number): void;\n    _initRenderer(): void;\n    _doRemove(): void;\n    _switchEvents(to: any, emitter: any): void;\n    _getRenderer(): CanvasRenderer;\n    _getLayerList(): Layer[];\n    _getMask2DExtent(): import(\"src\").Extent;\n    toJSON(options?: any): LayerJSONType;\n    /**\n     * Reproduce a Layer from layer's JSON.\n     * @param  {Object} layerJSON - layer's JSON\n     * @return {Layer}\n     */\n    static fromJSON(layerJSON: {\n        [key: string]: any;\n    }): Layer | null;\n}\nexport default Layer;\nexport type LayerOptionsType = {\n    attribution?: string;\n    minZoom?: number;\n    maxZoom?: number;\n    visible?: boolean;\n    opacity?: number;\n    zIndex?: number;\n    globalCompositeOperation?: string;\n    renderer?: 'canvas' | 'gl' | 'dom';\n    debugOutline?: string;\n    cssFilter?: string;\n    forceRenderOnMoving?: boolean;\n    forceRenderOnZooming?: boolean;\n    forceRenderOnRotating?: boolean;\n    collision?: boolean;\n    collisionScope?: 'layer' | 'map';\n    hitDetect?: boolean;\n    canvas?: HTMLCanvasElement;\n    mask?: any;\n    drawImmediate?: boolean;\n    geometryEvents?: boolean;\n    geometryEventTolerance?: number;\n};\nexport type LayerJSONType = {\n    id: string;\n    type: string;\n    options: Record<string, any>;\n    geometries?: Array<any>;\n    layers?: Array<any>;\n};\n"},{"path":"types/layer/OverlayLayer.d.ts","content":"import Extent from '../geo/Extent';\nimport { Geometry } from '../geometry';\nimport Layer, { LayerOptionsType } from './Layer';\nimport { type OverlayLayerCanvasRenderer } from '../renderer';\nimport { HandlerFnResultType } from '../core/Eventable';\n/**\n * layers 的基础类，可用于 geometries 的添加移除\n * 抽象类,不准备实例化\n *\n * @english\n * @classdesc\n * Base class of all the layers that can add/remove geometries. <br>\n * It is abstract and not intended to be instantiated.\n * @category layer\n * @abstract\n * @extends Layer\n */\ndeclare class OverlayLayer extends Layer {\n    _maxZIndex: number;\n    _minZIndex: number;\n    _geoMap: Record<string, Geometry>;\n    _geoList: Array<Geometry>;\n    _toSort: boolean;\n    _cookedStyles: any;\n    _clearing: boolean;\n    options: OverlayLayerOptionsType;\n    _renderer: OverlayLayerCanvasRenderer;\n    constructor(id: string, geometries: OverlayLayerOptionsType | Array<Geometry>, options?: OverlayLayerOptionsType);\n    getAltitude(): number;\n    /**\n     * 通过 id 获取 geometry\n     *\n     * @english\n     * Get a geometry by its id\n     * @param id   - id of the geometry\n     * @return\n     */\n    getGeometryById(id: string | number): Geometry;\n    /**\n     * 获取所有geometries，如果提供 filter() 方法,则根据方法返回\n     *\n     * @english\n     * Get all the geometries or the ones filtered if a filter function is provided.\n     * @param filter=undefined   - a function to filter the geometries\n     * @param context=undefined  - context of the filter function, value to use as this when executing filter.\n     * @return\n     */\n    getGeometries(filter?: (geo: Geometry) => boolean, context?: any): Array<Geometry>;\n    /**\n     * 获取第一个geometry, geometry 位于底部\n     *\n     * @english\n     * Get the first geometry, the geometry at the bottom.\n     * @return first geometry\n     */\n    getFirstGeometry(): Geometry;\n    /**\n     * 获取最后一个geometry, geometry 位于上部\n     *\n     * @english\n     * Get the last geometry, the geometry on the top\n     * @return last geometry\n     */\n    getLastGeometry(): Geometry;\n    /**\n     * 获取 geometries 个数\n     *\n     * Get count of the geometries\n     * @return count\n     */\n    getCount(): number;\n    /**\n     * 获取 geometries 的 extent, 如果 layer 为空,返回 null\n     *\n     * @english\n     * Get extent of all the geometries in the layer, return null if the layer is empty.\n     * @return {Extent} - extent of the layer\n     */\n    getExtent(): Extent;\n    /**\n     * 按顺序为图层中的每个 geometry 执行一次提供的回调。\n     *\n     * @english\n     * Executes the provided callback once for each geometry present in the layer in order.\n     * @param fn - a callback function\n     * @param context=undefined   - callback's context, value to use as this when executing callback.\n     * @return this\n     */\n    forEach(fn: (geo: Geometry, index: number) => void, context?: any): this;\n    /**\n     * 创建一个包含所有通过由提供的函数实现的测试的 geometries 的 GeometryCollection。\n     *\n     * @english\n     * Creates a GeometryCollection with all the geometries that pass the test implemented by the provided function.\n     * @param fn      - Function to test each geometry\n     * @param context=undefined  - Function's context, value to use as this when executing function.\n     * @return  A GeometryCollection with all the geometries that pass the test\n     */\n    filter(fn: (geo: Geometry) => boolean, context?: any): Array<Geometry>;\n    /**\n     * layer 是否为空\n     *\n     * @english\n     * Whether the layer is empty.\n     * @return {Boolean}\n     */\n    isEmpty(): boolean;\n    /**\n     * 为 layer 添加 geometries\n     *\n     * @english\n     * Adds one or more geometries to the layer\n     * @param geometries - one or more geometries\n     * @param fitView=false                                         - automatically set the map to a fit center and zoom for the geometries\n     * @param fitView.easing=out                                    - default animation type\n     * @param fitView.duration=map.options.zoomAnimationDuration    - default animation time\n     * @param fitView.step=null                                     - step function during animation, animation frame as the parameter\n     * @return this\n     */\n    addGeometry(geometries: Geometry | Array<Geometry>, fitView?: boolean | addGeometryFitViewOptions): any;\n    /**\n     * 所有 geometries 最小的 zIndex\n     *\n     * @english\n     * Get minimum zindex of geometries\n     */\n    getGeoMinZIndex(): number;\n    /**\n     * 所有 geometries 最大的 zIndex\n     *\n     * @english\n     * Get maximum zindex of geometries\n     */\n    getGeoMaxZIndex(): number;\n    _add(geo: Geometry, extent?: Extent, i?: number): void;\n    /**\n     * 移除一个或多个geometries\n     *\n     * @english\n     * Removes one or more geometries from the layer\n     * @param  geometries - geometry ids or geometries to remove\n     * @returns this\n     */\n    removeGeometry(geometries: Geometry | Geometry[]): any;\n    /**\n     * 清除 layer\n     *\n     * @english\n     * Clear all geometries in this layer\n     * @returns this\n     */\n    clear(): this;\n    /**\n     * 移除geometry 回调函数\n     *\n     * @english\n     * Called when geometry is being removed to clear the context concerned.\n     * @param geometry - the geometry instance to remove\n     * @protected\n     */\n    onRemoveGeometry(geometry: Geometry): void;\n    /**\n     * 获取 layer 的 style\n     *\n     * @english\n     * Gets layer's style.\n     * @return layer's style\n     */\n    getStyle(): any | any[];\n    /**\n     * layer 设置 style, 用样式符号对满足条件的 geometries进行样式修改\n     * 基于[mapbox-gl-js's style specification]， {https://www.mapbox.com/mapbox-gl-js/style-spec/#types-filter}.\n     *\n     * @english\n     * Sets style to the layer, styling the geometries satisfying the condition with style's symbol. <br>\n     * Based on filter type in [mapbox-gl-js's style specification]{https://www.mapbox.com/mapbox-gl-js/style-spec/#types-filter}.\n     * @param style - layer's style\n     * @returns this\n     * @fires VectorLayer#setstyle\n     * @example\n     * layer.setStyle([\n        {\n          'filter': ['==', 'count', 100],\n          'symbol': {'markerFile' : 'foo1.png'}\n        },\n        {\n          'filter': ['==', 'count', 200],\n          'symbol': {'markerFile' : 'foo2.png'}\n        }\n      ]);\n     */\n    setStyle(style: any | any[]): this;\n    _styleGeometry(geometry: Geometry): boolean;\n    /**\n     * 移除 style\n     *\n     * @english\n     * Removes layers' style\n     * @returns this\n     * @fires VectorLayer#removestyle\n     */\n    removeStyle(): this;\n    onAddGeometry(geo: Geometry): void;\n    hide(): this;\n    _initCache(): void;\n    _updateZIndex(...zIndex: number[]): void;\n    _sortGeometries(): void;\n    _compare(a: any, b: any): number;\n    _findInList(geo: Geometry): number;\n    _onGeometryEvent(param?: HandlerFnResultType): void;\n    _onGeometryIdChange(param: HandlerFnResultType): void;\n    _onGeometryZIndexChange(param: HandlerFnResultType): void;\n    _onGeometryPositionChange(param: HandlerFnResultType): void;\n    _onGeometryShapeChange(param: HandlerFnResultType): void;\n    _onGeometrySymbolChange(param: HandlerFnResultType): void;\n    _onGeometryShow(param: HandlerFnResultType): void;\n    _onGeometryHide(param: HandlerFnResultType): void;\n    _onGeometryPropertiesChange(param: HandlerFnResultType): void;\n    _hasGeoListeners(eventTypes: string | Array<string>): boolean;\n    _getRenderer(): OverlayLayerCanvasRenderer;\n}\nexport default OverlayLayer;\nexport type OverlayLayerOptionsType = LayerOptionsType & {\n    drawImmediate?: boolean;\n    geometryEvents?: boolean;\n    geometryEventTolerance?: number;\n    style?: any;\n};\nexport type addGeometryFitViewOptions = {\n    easing?: string;\n    duration?: number;\n    step?: (frame: any) => void;\n};\nexport type LayerIdentifyOptionsType = {\n    onlyVisible?: boolean;\n    tolerance?: number;\n};\n"},{"path":"types/layer/ParticleLayer.d.ts","content":"import CanvasLayer, { CanvasLayerOptionsType } from './CanvasLayer';\n/**\n * 粒子图层\n * 提供了一些渲染粒子的接口方法。\n * 你可以直接使用它，但不能以这种方式用JSON序列化/反序列化一个 particelayer\n * 更建议使用子类来扩展它\n *\n * @english\n * @classdesc\n * A layer to draw particles. <br>\n * ParticleLayer provides some interface methods to render particles. <br>\n * You can use it directly, but can't serialize/deserialize a ParticleLayer with JSON in this way. <br>\n * It is more recommended to extend it with a subclass.\n * @example\n * import { ParticleLayer } from 'maptalks';\n * var layer = new ParticleLayer('particle');\n *\n * layer.getParticles = function (t) {\n *     return particles[t];\n * };\n * layer.addTo(map);\n * @category layer\n * @extends CanvasLayer\n * @param {String} id - layer's id\n * @param {Object} [options=null] - options defined in [options]{@link ParticleLayer#options}\n */\ndeclare class ParticleLayer extends CanvasLayer {\n    options: ParticleLayerOptionsType;\n    /**\n     * 获取t时刻的例子位置\n     *\n     * @english\n     * Interface method to get particles's position at time t.\n     * @param t - current time in milliseconds\n     */\n    getParticles(t?: number): void;\n    draw(context: CanvasRenderingContext2D, view: any): void;\n    _fillCanvas(context: CanvasRenderingContext2D): void;\n}\nexport default ParticleLayer;\nexport type ParticleLayerOptionsType = CanvasLayerOptionsType & {\n    animation?: boolean;\n};\n"},{"path":"types/layer/tile/CanvasTileLayer.d.ts","content":"import { LayerJSONType } from '../Layer';\nimport TileLayer, { TileLayerOptionsType } from './TileLayer';\n/**\n * @classdesc\n * @ignore\n * @category layer\n * @extends TileLayer\n * @param id - tile layer's id\n * @param - options defined in [CanvasTileLayer]{@link TileLayer#options}\n * @example\n * var layer = new CanvasTileLayer(\"tile\");\n * layer.drawTile = ()\n */\ndeclare class CanvasTileLayer extends TileLayer {\n    constructor(id: string, options: CanvasTileLayerOptionsType);\n    /**\n     * The interface method to draw on canvsa tile\n     * @param canvas  canvas to draw on\n     * @param options current options\n     * @param options current options\n     */\n    drawTile(): void;\n    /**\n     * Export the CanvasTileLayer's json. <br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method\n     * @return layer's JSON\n     */\n    toJSON(): LayerJSONType;\n    /**\n     * Reproduce a CanvasTileLayer from layer's JSON.\n     * @param layerJSON - layer's JSON\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(layerJSON: {\n        [x: string]: any;\n    }): CanvasTileLayer;\n}\nexport default CanvasTileLayer;\nexport type CanvasTileLayerOptionsType = TileLayerOptionsType;\n"},{"path":"types/layer/tile/GroupTileLayer.d.ts","content":"import { LayerJSONType } from '../Layer';\nimport TileLayer, { TileLayerOptionsType, TilesType } from './TileLayer';\nimport Size from '../../geo/Size';\n/**\n * @classdesc\n * A layer used to display a group of tile layers. <br>\n * Its performance is better than add TileLayers seperately and it can help prevent limits of active webgl contexts: <br>\n * \"WARNING: Too many active WebGL contexts. Oldest context will be lost\"\n * @category layer\n * @extends TileLayer\n * @param {String|Number} id - tile layer's id\n * @param {TileLayer[]} layers  - TileLayers to add\n * @param {Object} [options=null] - options defined in [TileLayer]{@link TileLayer#options}\n * @example\n * new GroupTileLayer(\"group-tiles\",[\n    new maptalks.WMSTileLayer('wms', {\n      'urlTemplate' : 'https://demo.boundlessgeo.com/geoserver/ows',\n      'crs' : 'EPSG:3857',\n      'layers' : 'ne:ne',\n      'styles' : '',\n      'version' : '1.3.0',\n      'format': 'image/png',\n      'transparent' : true,\n      'uppercase' : true\n    }),\n    new maptalks.TileLayer('tile2',{\n      urlTemplate: 'http://korona.geog.uni-heidelberg.de/tiles/adminb/x={x}&y={y}&z={z}'\n    })\n  ])\n */\ndeclare class GroupTileLayer extends TileLayer {\n    layers: TileLayer[];\n    layerMap: Record<string, TileLayer>;\n    private _groupChildren;\n    /**\n     * Reproduce a GroupTileLayer from layer's profile JSON.\n     * @param layerJSON - layer's profile JSON\n     * @return\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(layerJSON: {\n        [x: string]: any;\n    }): GroupTileLayer;\n    /**\n     * @param id    - layer's id\n     * @param layers  - TileLayers to add\n     * @param [options=null]          - construct options\n     * @param [options.*=null]             - options defined in [TileLayer]{@link TileLayer#options}\n     */\n    constructor(id: string, layers: TileLayer[], options?: GroupTileLayerOptionsType);\n    /**\n     * Get children TileLayer\n     */\n    getLayers(): TileLayer[];\n    /**\n     * add tilelayers\n     * @param tileLayers\n     */\n    addLayer(tileLayers?: TileLayer[]): this;\n    /**\n     * remove tilelayers\n     * @param tileLayers\n     */\n    removeLayer(tileLayers?: TileLayer[]): this;\n    /**\n   * clear tilelayers\n   */\n    clearLayers(): this;\n    /**\n     * Export the GroupTileLayer's profile json. <br>\n     * Layer's profile is a snapshot of the layer in JSON format. <br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method\n     * @return layer's profile JSON\n     */\n    toJSON(): LayerJSONType;\n    getTileSize(id: number | string): Size;\n    /**\n     * Get tiles at zoom (or current zoom)\n     * @param z\n     * @returns tiles\n     */\n    getTiles(z: number, parentLayer: any): TilesType;\n    onAdd(): void;\n    onRemove(): void;\n    getLayer(id: string | number): TileLayer;\n    getChildLayer(id: string | number): TileLayer;\n    _removeChildTileCache(layer: TileLayer): this;\n    _onLayerShowHide(e: {\n        type: string;\n        target: any;\n    }): void;\n    _renderLayers(): this;\n    _refresh(): this;\n    isVisible(): boolean;\n    _checkChildren(): void;\n    _sortLayers(): void;\n}\nexport default GroupTileLayer;\nexport type GroupTileLayerOptionsType = TileLayerOptionsType & {\n    maxCacheSize?: number;\n};\n"},{"path":"types/layer/tile/tileinfo/TileConfig.d.ts","content":"import Coordinate from '../../../geo/Coordinate';\nimport Point from '../../../geo/Point';\nimport Extent from '../../../geo/Extent';\nimport Transformation from '../../../geo/transformation/Transformation';\nimport TileSystem from './TileSystem';\nimport { type Map } from '../../../map';\nimport { type Size } from '../../../geo';\n/**\n * Tile config for tile layers, an utilities class for tile layers to render tiles\n * @class\n * @category layer\n * @private\n */\ndeclare class TileConfig {\n    map: Map;\n    tileSize: Size;\n    fullExtent: Extent;\n    private _xScale;\n    private _yScale;\n    private _pointOrigin;\n    private _glRes;\n    tileSystem: TileSystem;\n    transformation: Transformation;\n    private _tileFullIndex;\n    /**\n     * @param tileSystem  - tileSystem\n     * @param fullExtent      - fullExtent of the tile layer\n     * @param tileSize          - tile size\n     */\n    constructor(map: Map, tileSystem: TileSystem, fullExtent: Extent, tileSize: Size);\n    prepareTileInfo(tileSystem: TileSystem, fullExtent: Extent): void;\n    /**\n     * Get index of point's tile\n     * @param point - transformed point, this.transformation.transform(pCoord)\n     * @param res  - current resolution\n     * @return       tile index\n     */\n    _getTileNum(point: Point, res: number): {\n        x: number;\n        y: number;\n    };\n    /**\n     * Get tile index and offset from tile's northwest\n     * @param pCoord   - projected coordinate\n     * @param res - current resolution\n     * @return   tile index and offset\n     */\n    getTileIndex(pCoord: Coordinate, res: number, repeatWorld: any): TileIndex;\n    /**\n     * Get neibor's tile index\n     * @param tileX\n     * @param tileY\n     * @param offsetX\n     * @param offsetY\n     * @param zoomLevel\n     * @return  tile's neighbor index\n     */\n    getNeighorTileIndex(tileX: number, tileY: number, offsetX: number, offsetY: number, res: number, repeatWorld: any): TileIndex;\n    _getTileFullIndex(res: number): Extent;\n    /**\n     * Get tile's north west's projected coordinate\n     * @param tileX\n     * @param tileY\n     * @param res\n     * @return\n     */\n    getTilePrjNW(tileX: number, tileY: number, res: number, out?: any): Coordinate;\n    getTilePointNW(tileX: number, tileY: number, res: number, out?: any): Point;\n    /**\n     * Get tile's south east's projected coordinate\n     * @param tileX\n     * @param tileY\n     * @param res\n     * @return\n     */\n    getTilePrjSE(tileX: number, tileY: number, res: number, out?: any): Coordinate;\n    getTilePointSE(tileX: number, tileY: number, res: number, out?: any): Point;\n    /**\n     * Get tile's projected extent\n     * @param tileX\n     * @param tileY\n     * @param res\n     * @return\n     */\n    getTilePrjExtent(tileX: number, tileY: number, res: number): Extent;\n}\nexport default TileConfig;\ntype TileIndex = {\n    x: number;\n    y: number;\n    idx: number;\n    idy: number;\n    out: any;\n};\n"},{"path":"types/layer/tile/tileinfo/TileSystem.d.ts","content":"/**\n * @classdesc\n * A class internally used by tile layer helps to descibe tile system used by different tile services.<br>\n *\n * @class\n * @category layer\n * @example\n * var ts = new TileSystem([1, -1, -20037508.34, 20037508.34]);\n */\ndeclare class TileSystem {\n    scale: {\n        x: number;\n        y: number;\n    };\n    origin: {\n        x: number;\n        y: number;\n    };\n    /**\n     * Similar with [transformation]{@link Transformation}, it contains 4 numbers: sx, sy, ox, oy.<br>\n     * @see {@link http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification}\n     * @param sx the order of X-axis tile index, 1 means right is larger and -1 means the reverse, left is larger;\n     * @param sy the order of Y-axis tile index, 1 means bottom is larger and -1 means the reverse, top is larger;\n     * @param ox x of the origin point of the world's projected coordinate system\n     * @param oy y of the origin point of the world's projected coordinate system\n     */\n    constructor(sx: number | number[], sy?: number, ox?: number, oy?: number);\n    /**\n     * Get the default tile system's code for the projection.\n     * @param projection      - a projection object\n     * @return tile system code\n     */\n    static getDefault(projection: any): string | number[];\n}\nexport default TileSystem;\n"},{"path":"types/layer/tile/TileLayer.d.ts","content":"import { Matrix4 } from '../../core/util';\nimport { ArrayLRUCache } from '../../core/util/LRUCache';\nimport Size from '../../geo/Size';\nimport Point from '../../geo/Point';\nimport PointExtent from '../../geo/PointExtent';\nimport TileConfig from './tileinfo/TileConfig';\nimport Layer, { LayerJSONType, LayerOptionsType } from '../Layer';\nimport SpatialReference, { SpatialReferenceType } from '../../map/spatial-reference/SpatialReference';\nimport { Coordinate, Extent } from '../../geo';\nimport { type TileLayerCanvasRenderer } from '../../renderer';\nimport { type Map } from '../../map';\ndeclare class TileHashset {\n    private _table;\n    constructor();\n    add(key: string | number): void;\n    has(key: string | number): any;\n    reset(): void;\n}\n/**\n * A layer used to display tiled map services, such as [google maps](http://maps.google.com), [open street maps](http://www.osm.org)\n * @category layer\n * @example\n *  new TileLayer(\"tile\",{\n        urlTemplate : 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n        subdomains:['a','b','c']\n    })\n */\ndeclare class TileLayer extends Layer {\n    tileInfoCache: ArrayLRUCache;\n    _tileSize: Size;\n    _coordCache: Record<string, Point>;\n    _disablePyramid: boolean;\n    _hasOwnSR: boolean;\n    _tileFullExtent: PointExtent;\n    _rootNodes: any;\n    _visitedTiles: TileHashset;\n    _zScale: number;\n    _sr: SpatialReference;\n    _srMinZoom: number;\n    _srMaxZoom: number;\n    _defaultTileConfig: TileConfig;\n    _tileConfig: TileConfig;\n    _polygonOffset: number;\n    _renderer: TileLayerCanvasRenderer;\n    /**\n     *\n     * @param id - tile layer's id\n     * @param options - options defined in TileLayerOptionsType\n     */\n    constructor(id: string, options?: TileLayerOptionsType);\n    /**\n     * Reproduce a TileLayer from layer's profile JSON.\n     * @param layerJSON - layer's profile JSON\n     * @return\n     * @static\n     * @protected\n     * @function\n     */\n    static fromJSON(layerJSON: Record<string, any>): TileLayer;\n    /**\n     * force Reload tilelayer.\n     * Note that this method will clear all cached tiles and reload them. It shouldn't be called frequently for performance reason.\n\n     * @return this\n     */\n    forceReload(): this;\n    /**\n     * Get tile size of the tile layer\n     * @return\n     */\n    getTileSize(id?: string): Size;\n    getTiles(z: number, parentLayer: Layer): TilesType;\n    _isPyramidMode(): boolean;\n    _getTileFullExtent(): Extent;\n    _getRootNodes(offset0: TileOffsetType): TileRootType;\n    createTileNode(x: number, y: number, z: number, idx: number, idy: number, res: number, error: number, parentId?: string, extent2d?: PointExtent, tileId?: string): TileNodeType;\n    _getRootError(): number;\n    _getPyramidTiles(z: number, layer: Layer): TilesType;\n    isParentTile(z: number, maxZoom: number, tile: TileNodeType): boolean;\n    _splitNode(node: TileNodeType, projectionView: Matrix4, queue: TileNodeType[], tiles: TileNodeType[], gridExtent: PointExtent, maxZoom: number, offset: TileOffsetType, parentRenderer: any, glRes: number): void;\n    _createChildNode(node: TileNodeType, dx: number, dy: number, offset?: TileOffsetType, tileId?: string): TileNodeType;\n    _isTileVisible(node: TileNodeType, projectionView: Matrix4, glScale: number, maxZoom: number, offset: TileOffsetType): 0 | 1 | -1;\n    private _isTileInFrustum;\n    /**\n     * Compute tile's SSE\n     * from Cesium\n     * 与cesium不同的是，我们用boundingVolume顶面的四个顶点中的最小值作为distanceToCamera\n     */\n    private _getScreenSpaceError;\n    /**\n     * Get tiles at zoom z (or current zoom)\n     * @param z - zoom\n     * @return tile descriptors\n     */\n    private _getCascadeTiles;\n    /**\n     * Get tile's url\n     * @param x\n     * @param y\n     * @param z\n     * @returns url\n     */\n    getTileUrl(x: number, y: number, z: number): string;\n    /**\n     * Clear the layer\n     * @return this\n     */\n    clear(): this;\n    /**\n     * Export the tile layer's profile json. <br>\n     * Layer's profile is a snapshot of the layer in JSON format. <br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method\n     * @return layer's profile JSON\n     */\n    toJSON(): LayerJSONType;\n    /**\n     * Get tilelayer's spatial reference.\n     * @returns spatial reference\n     */\n    getSpatialReference(): SpatialReference;\n    getMinZoom(): number;\n    getMaxZoom(): number;\n    _getTileZoom(zoom: number): number;\n    /**\n     * Get tileLayer's max available zoom, either options['maxAvailableZoom'] or spatialReference's maxZoom\n     *\n     * @returns\n     **/\n    getMaxAvailableZoom(): number;\n    _getTiles(tileZoom: number, containerExtent: PointExtent, cascadeLevel: number, parentRenderer: any, ignoreMinZoom?: boolean): TileGridType;\n    _convertToExtent2d(containerExtent: PointExtent): PointExtent | Extent;\n    _splitTiles(frustumMatrix: Matrix4, tiles: TileNodeType[], renderer: any, tileIdx: TileNodeType, z: number, res: number, tileExtent: PointExtent, dx?: number, dy?: number, tileOffsets?: Record<string, TileOffsetType>): void;\n    _checkAndAddTile(frustumMatrix: Matrix4, renderer: any, idx: number, idy: number, x: number, y: number, z: number, res: number, i: number, j: number, w: number, h: number, corner: Point, glScale: number, tileOffsets: Record<string, TileOffsetType>): TileNodeType;\n    _getTileOffset(...params: number[]): TileOffsetType;\n    getTileId(x: number, y: number, zoom: number, id: string): string;\n    _getTileId(x: number, y: number, zoom: number, id?: string): string;\n    _project(pcoord: Coordinate, out: Point): Coordinate;\n    _unproject(pcoord: Coordinate, out: Point): Coordinate;\n    /**\n     * initialize [tileConfig]{@link TileConfig} for the tilelayer\n     * @private\n     */\n    _initTileConfig(): void;\n    _getTileConfig(): TileConfig;\n    _bindMap(map: Map): any;\n    _isTileInExtent(frustumMatrix: Matrix4, tileExtent: PointExtent, offset: TileOffsetType, glScale: number): any;\n    _isSplittedTileInExtent(frustumMatrix: any, tileExtent: PointExtent, offset: TileOffsetType, glScale: number): boolean;\n    getEvents(): {\n        spatialreferencechange: () => void;\n    };\n    _onSpatialReferenceChange(): void;\n    /**\n     * Get layer's polygonOffset count\n     * @return\n     */\n    getPolygonOffsetCount(): number;\n    /**\n     * Get layer's base polygon offset\n     * @return\n     */\n    getPolygonOffset(): number;\n    /**\n     * Set layer's base polygon offset, called by GroupGLLayer\n     * @param offset polygon offset\n     * @return\n     */\n    setPolygonOffset(offset: number): this;\n    getRenderer(): TileLayerCanvasRenderer;\n}\nexport default TileLayer;\nexport type TileOffsetType = [number, number];\nexport type TileNodeType = {\n    x: number;\n    y: number;\n    z: number;\n    url: string;\n    res: number;\n    parent: string;\n    offset: TileOffsetType;\n    layer: string;\n    idy: number;\n    idx: number;\n    id: string;\n    extent2d: PointExtent;\n    error: number;\n    children: Array<string>;\n    minAltitude?: number;\n    maxAltitude?: number;\n};\nexport type TileGridType = {\n    count?: number;\n    extent: PointExtent;\n    offset: TileOffsetType;\n    parents?: Array<TileNodeType>;\n    tiles: Array<TileNodeType>;\n    zoom: number;\n};\nexport type TilesType = {\n    tileGrids: Array<TileGridType>;\n    count: number;\n};\nexport type TileCacheType = {\n    info: TileNodeType;\n};\nexport type TileRootType = {\n    status: 0 | 1;\n    error?: string;\n    tiles?: Array<TileNodeType>;\n    mapWidth?: number;\n    mapHeight?: number;\n};\nexport type TileLayerOptionsType = LayerOptionsType & {\n    urlTemplate: string | ((...args: any[]) => string);\n    subdomains?: string[];\n    spatialReference?: SpatialReferenceType;\n    tileSize?: number[];\n    offset?: number[] | ((...args: any[]) => number[]);\n    tileSystem?: [number, number, number, number];\n    maxAvailableZoom?: number;\n    repeatWorld?: boolean;\n    background?: boolean;\n    placeholder?: boolean | ((...args: any[]) => boolean);\n    fragmentShader?: string;\n    crossOrigin?: string;\n    fadeAnimation?: boolean;\n    fadeDuration?: number;\n    debug?: boolean;\n    renderer?: 'gl' | 'canvas';\n    maxCacheSize?: number;\n    cascadeTiles?: boolean;\n    zoomOffset?: number;\n    tileRetryCount?: number;\n    errorUrl?: string;\n    customTags?: Record<string, any>;\n    decodeImageInWorker?: boolean;\n    token?: string;\n    fetchOptions?: Record<string, any>;\n    awareOfTerrain?: boolean;\n    bufferPixel?: number;\n    depthMask?: boolean;\n    loadingLimitOnInteracting?: number;\n    loadingLimit?: number;\n    clipByPitch?: boolean;\n    pyramidMode?: number;\n    tileLimitPerFrame?: number;\n    tileStackStartDepth?: number;\n    tileStackDepth?: number;\n    mipmapTexture?: boolean;\n    currentTilesFirst?: boolean;\n};\n"},{"path":"types/layer/tile/WMSTileLayer.d.ts","content":"import { LayerJSONType } from '../Layer';\nimport TileLayer, { TileLayerOptionsType } from './TileLayer';\n/**\n * @classdesc\n * Used to display [WMS]{https://en.wikipedia.org/wiki/Web_Map_Service} services as tile layers on the map. Extends [TileLayer]{@link TileLayer}.\n * Implemented based on Leaflet's TileLayer.WMS.\n * @category layer\n * @extends TileLayer\n * @param id - tile layer's id\n * @param - options defined in [WMSTileLayer]{@link TileLayer#options}\n * @example\n * var layer = new maptalks.WMSTileLayer('wms', {\n *     'urlTemplate' : 'https://demo.boundlessgeo.com/geoserver/ows',\n *     'crs' : 'EPSG:3857',\n *     'layers' : 'ne:ne',\n *     'styles' : '',\n *     'version' : '1.3.0',\n *     'format': 'image/png',\n *     'transparent' : true,\n *     'uppercase' : true\n * });\n */\ndeclare class WMSTileLayer extends TileLayer {\n    wmsParams: WMSTileLayerOptionsType;\n    options: WMSTileLayerOptionsType;\n    private _wmsVersion;\n    constructor(id: string, options: WMSTileLayerOptionsType);\n    _optionsHook(options?: {}): this;\n    onAdd(): void;\n    getTileUrl(x: number, y: number, z: number): string;\n    /**\n     * Export the WMSTileLayer's json. <br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method\n     * @return layer's JSON\n     */\n    toJSON(): LayerJSONType;\n    /**\n     * Reproduce a WMSTileLayer from layer's JSON.\n     * @param layerJSON - layer's JSON\n     * @return a WMSTileLayer instance\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(layerJSON: {\n        [x: string]: any;\n    }): WMSTileLayer;\n}\nexport default WMSTileLayer;\nexport declare function getParamString(obj: Record<string, string>, existingUrl: string, uppercase: boolean): string;\nexport type WMSTileLayerOptionsType = TileLayerOptionsType & {\n    service?: string;\n    layers?: string;\n    styles?: string;\n    format?: string;\n    transparent?: boolean;\n    version?: string;\n    crs?: string;\n    uppercase?: boolean;\n    detectRetina?: boolean;\n    width?: number;\n    height?: number;\n};\n"},{"path":"types/layer/VectorLayer.d.ts","content":"import Extent from '../geo/Extent';\nimport Geometry from '../geometry/Geometry';\nimport OverlayLayer, { LayerIdentifyOptionsType, OverlayLayerOptionsType } from './OverlayLayer';\nimport Painter from '../renderer/geometry/Painter';\nimport CollectionPainter from '../renderer/geometry/CollectionPainter';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport { VectorLayerCanvasRenderer } from '../renderer';\nimport { LayerJSONType } from './Layer';\ntype VectorLayerToJSONOptions = {\n    geometries: any;\n    clipExtent: Extent;\n};\n/**\n * 用于管理、呈现 geometries 的 layer\n *\n * @english\n * @classdesc\n * A layer for managing and rendering geometries.\n * @category layer\n * @extends OverlayLayer\n */\ndeclare class VectorLayer extends OverlayLayer {\n    options: VectorLayerOptionsType;\n    /**\n     * @param id                    - layer's id\n     * @param geometries=null       - geometries to add\n     * @param options=null          - construct options\n     * @param options.style=null    - vectorlayer's style\n     * @param options.*=null        - options defined in [VectorLayer]{@link VectorLayer#options}\n     */\n    constructor(id: string, geometries: VectorLayerOptionsType | Array<Geometry>, options?: VectorLayerOptionsType);\n    onConfig(conf: Record<string, any>): void;\n    /**\n     * 通过给定 coordinate 识别 geometries\n     *\n     * @english\n     * Identify the geometries on the given coordinate\n     * @param  {maptalks.Coordinate} coordinate   - coordinate to identify\n     * @param  {Object} [options=null]  - options\n     * @param  {Object} [options.tolerance=0] - identify tolerance in pixel\n     * @param  {Object} [options.count=null]  - result count\n     * @return {Geometry[]} geometries identified\n     */\n    identify(coordinate: Coordinate, options?: LayerIdentifyOptionsType): Geometry[];\n    /**\n     * 通过给定 point 识别 geometries\n     *\n     * @english\n     * Identify the geometries on the given container point\n     * @param  {maptalks.Point} point   - container point to identify\n     * @param  {Object} [options=null]  - options\n     * @param  {Object} [options.tolerance=0] - identify tolerance in pixel\n     * @param  {Object} [options.count=null]  - result count\n     * @return {Geometry[]} geometries identified\n     */\n    identifyAtPoint(point: Point, options?: LayerIdentifyOptionsType): any;\n    _hitGeos(geometries: Array<Geometry>, cp: Point, options: LayerIdentifyOptionsType): Geometry[];\n    getAltitude(): number;\n    /**\n     * 输出 VectorLayer 的 json\n     *\n     * @english\n     * Export the VectorLayer's JSON. <br>\n     * @param  {Object} [options=null] - export options\n     * @param  {Object} [options.geometries=null] - If not null and the layer is a [OverlayerLayer]{@link OverlayLayer},\n     *                                            the layer's geometries will be exported with the given \"options.geometries\" as a parameter of geometry's toJSON.\n     * @param  {Extent} [options.clipExtent=null] - if set, only the geometries intersectes with the extent will be exported.\n     * @return layer's JSON\n     */\n    toJSON(options?: VectorLayerToJSONOptions): LayerJSONType;\n    getRenderer(): VectorLayerCanvasRenderer;\n    /**\n     * 通过 json 生成 VectorLayer\n     *\n     * @english\n     * Reproduce a VectorLayer from layer's JSON.\n     * @param  {Object} layerJSON - layer's JSON\n     * @return {VectorLayer}\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(json: Record<string, any>): VectorLayer;\n    static getPainterClass(): typeof Painter;\n    static getCollectionPainterClass(): typeof CollectionPainter;\n}\nexport default VectorLayer;\nexport type VectorLayerOptionsType = OverlayLayerOptionsType & {\n    debug?: boolean;\n    enableSimplify?: boolean;\n    cursor?: string;\n    geometryEvents?: boolean;\n    defaultIconSize?: [number, number];\n    cacheVectorOnCanvas?: boolean;\n    cacheSvgOnCanvas?: boolean;\n    enableAltitude?: boolean;\n    altitudeProperty?: string;\n    drawAltitude?: boolean;\n    sortByDistanceToCamera?: boolean;\n    roundPoint?: boolean;\n    altitude?: number;\n    clipBBoxBufferSize?: number;\n    collision?: boolean;\n    collisionBufferSize?: number;\n    collisionDelay?: number;\n    collisionScope?: 'layer' | 'map';\n    progressiveRender?: boolean;\n    progressiveRenderCount?: number;\n    progressiveRenderDebug?: boolean;\n};\n"},{"path":"types/map/handler/CommonType.d.ts","content":"import { Coordinate, Point } from '../../geo';\nexport type Event = {\n    type: string;\n    target: any;\n    coordinate: Coordinate;\n    containerPoint: Point;\n    viewPoint: Point;\n    domEvent: Event;\n};\nexport type Param = {\n    type: string;\n    target: any;\n    geometry: any;\n    coordinate: Coordinate;\n    containerPoint: Point;\n    viewPoint: Point;\n    domEvent: MouseEvent;\n    ignoreEndEvent?: boolean;\n    interupted?: boolean;\n};\n"},{"path":"types/map/handler/Map.AutoPanAtEdge.d.ts","content":"import Handler from '../../handler/Handler';\nimport { type Event } from './CommonType';\ndeclare class MapAutoPanAtEdgeHandler extends Handler {\n    addHooks(): void;\n    removeHooks(): void;\n    _onMouseMove(event: Event): void;\n}\nexport default MapAutoPanAtEdgeHandler;\n"},{"path":"types/map/handler/Map.BoxZoom.d.ts","content":"import Handler from '../../handler/Handler';\nimport DrawTool from '../tool/DrawTool';\nimport { type Param } from './CommonType';\ndeclare class MapBoxZoomHander extends Handler {\n    drawTool: DrawTool;\n    constructor(target: any);\n    addHooks(): void;\n    removeHooks(): void;\n    _onMouseDown(param: Param): void;\n    _boxZoom(param: Param): void;\n}\nexport default MapBoxZoomHander;\n"},{"path":"types/map/handler/Map.DoubleClickZoom.d.ts","content":"import Handler from '../../handler/Handler';\nimport { type Param } from './CommonType';\ndeclare class MapDoubleClickZoomHandler extends Handler {\n    addHooks(): void;\n    removeHooks(): void;\n    _onDoubleClick(param: Param): void;\n}\nexport default MapDoubleClickZoomHandler;\n"},{"path":"types/map/handler/Map.Drag.d.ts","content":"import Handler from '../../handler/Handler';\nimport DragHandler from '../../handler/Drag';\nimport { type Param } from './CommonType';\ndeclare class MapDragHandler extends Handler {\n    _dragHandler: DragHandler;\n    startDragTime: number;\n    startBearing: number;\n    _mode: 'rotatePitch' | 'move';\n    preX: number;\n    preY: number;\n    startX: number;\n    startY: number;\n    _startPrjCenter: any;\n    startPrjCoord: any;\n    _rotateMode: 'rotate_pitch' | 'rotate' | 'pitch';\n    _db: number;\n    addHooks(): void;\n    removeHooks(): void;\n    _cancelOn(domEvent: any): boolean;\n    _ignore(param: any): any;\n    _onMouseDown(param: any): void;\n    _onDragStart(param: any): void;\n    _onDragging(param: any): void;\n    _onDragEnd(param: any): void;\n    _start(param: any): void;\n    _moveStart(param: any): void;\n    _moving(param: any): void;\n    _containerPointToPrj(p: any): any;\n    _moveEnd(param: Param): void;\n    _rotateStart(param: Param): void;\n    _rotating(param: Param): void;\n    _rotateEnd(param: Param): void;\n    _clear(): void;\n}\nexport default MapDragHandler;\n"},{"path":"types/map/handler/Map.GeometryEvents.d.ts","content":"import Handler from '../../handler/Handler';\ndeclare class MapGeometryEventsHandler extends Handler {\n    _mouseDownTime: number;\n    _queryIdentifyTimeout: number;\n    addHooks(): void;\n    removeHooks(): void;\n    _identifyGeometryEvents(domEvent: any, type: any): void;\n}\nexport default MapGeometryEventsHandler;\n"},{"path":"types/map/handler/Map.ScrollWheelZoom.d.ts","content":"/// <reference types=\"node\" />\nimport Handler from '../../handler/Handler';\ndeclare class MapScrollWheelZoomHandler extends Handler {\n    _thisScrollZoom: number;\n    _wheelZoomRate: number;\n    _defaultZoomRate: number;\n    _delta: number;\n    _zooming: boolean;\n    _trackPadSuspect: number;\n    _ensureTrackpad: boolean;\n    _active: boolean;\n    _timeout: NodeJS.Timeout;\n    _requesting: number;\n    _startZoom: number;\n    _origin: any;\n    _zoomOrigin: any;\n    _lastWheelEvent: any;\n    constructor(target: any);\n    addHooks(): void;\n    removeHooks(): void;\n    _onWheelScroll(evt: any): boolean | void;\n    _seamless(evt: any, origin: any): void;\n    _start(): void;\n    _scrollZoom(): void;\n    _interval(evt: any, origin: any): boolean;\n}\nexport default MapScrollWheelZoomHandler;\n"},{"path":"types/map/handler/Map.Touch.d.ts","content":"import Handler from '../../handler/Handler';\nimport Point from '../../geo/Point';\ndeclare class MapTouchZoomHandler extends Handler {\n    preY: number;\n    _startP1: Point;\n    _startP2: Point;\n    _startDist: number;\n    _startVector: Point;\n    _startZoom: number;\n    _startBearing: number;\n    mode: 'rotate_zoom' | 'pitch' | 'rotate' | 'zoom';\n    _scale: number;\n    _Origin: Point;\n    addHooks(): void;\n    removeHooks(): void;\n    _onTouchStart(event: any): void;\n    _onTouchMove(event: any): void;\n    _startTouching(param: any): void;\n    _onTouchEnd(event: any): void;\n}\nexport default MapTouchZoomHandler;\n"},{"path":"types/map/index.d.ts","content":"import Map from './Map';\nimport './handler/Map.DoubleClickZoom';\nimport './handler/Map.Drag';\nimport './handler/Map.GeometryEvents';\nimport './handler/Map.ScrollWheelZoom';\nimport './handler/Map.Touch';\nimport './handler/Map.BoxZoom';\nimport './handler/Map.AutoPanAtEdge';\nimport './Map.Anim';\nimport './Map.DomEvents';\nimport './Map.FullScreen';\nimport './Map.Pan';\nimport './Map.Topo';\nimport './Map.Zoom';\nimport './Map.Camera';\nimport './Map.ViewHistory';\nimport './Map.Collision';\nimport './Map.CoordTransform';\nexport { Map };\n"},{"path":"types/map/Map.Anim.d.ts","content":"import { Player } from '../core/Animation';\ndeclare module \"./Map\" {\n    interface Map {\n        _mapAnimPlayer: Player;\n        isRotating(): boolean;\n        _animateTo(view: MapViewType, options?: MapAnimationOptionsType, step?: (frame: any) => void): Player;\n        _stopAnim(player?: Player): void;\n        animateTo(view: MapViewType, options?: MapAnimationOptionsType, step?: (frame: any) => void): Player;\n        flyTo(view: MapViewType, options?: MapAnimationOptionsType, step?: (frame: any) => void): this;\n        isAnimating(): boolean;\n    }\n}\n"},{"path":"types/map/Map.Camera.d.ts","content":"import Point from '../geo/Point';\nimport Coordinate from '../geo/Coordinate';\nimport { type Matrix4 } from '../core/util';\ndeclare module \"./Map\" {\n    interface Map {\n        cameraPosition: Point;\n        cameraLookAt: number[];\n        projViewMatrix: Matrix4;\n        getFov(): number;\n        setFov(fov: number): this;\n        getBearing(): number;\n        setBearing(bearing: number): this;\n        _setBearing(bearing: number): this;\n        getPitch(): number;\n        setPitch(pitch: number): this;\n        _setPitch(pitch: number): this;\n        _calcMatrices(): void;\n        _containerPointToPoint(p: Point, zoom?: number, out?: Point): Point;\n        _recenterOnTerrain(): void;\n        setCameraMovements(frameOptions: Array<MapViewType>, option?: {\n            autoRotate: boolean;\n        }): any;\n        setCameraOrientation(params: MapViewType): this;\n        setCameraPosition(coordinate: Coordinate): any;\n        getFitZoomForCamera(cameraPosition: Array<number>, pitch: number): any;\n        isTransforming(): boolean;\n        getFrustumAltitude(): number;\n        updateCenterAltitude(): any;\n        _queryTerrainByProjCoord(coord: Coordinate): number;\n        _hasAltitudeLayer(): boolean;\n        _queryTerrainInfo(containerPoint: Point): {\n            coordinate: Coordinate;\n            altitude: number;\n        } | null;\n        _pointAtResToContainerPoint(point: Point, res?: number, altitude?: number, out?: Point): Point;\n        _pointToContainerPoint(point: Point, zoom?: number, out?: Point): Point;\n        _pointsAtResToContainerPoints(point: Point[], res?: number, altitude?: number[], out?: Point[]): Point[];\n    }\n}\n"},{"path":"types/map/Map.Collision.d.ts","content":"import CollisionIndex from '../core/CollisionIndex';\nimport UIComponent from '../ui/UIComponent';\ndeclare module \"./Map\" {\n    interface Map {\n        getCollisionIndex(): CollisionIndex;\n        createCollisionIndex(): CollisionIndex;\n        clearCollisionIndex(): this;\n        _insertUICollidesQueue(): this;\n        uiCollides(): this;\n        _addUI(ui: UIComponent): this;\n        _removeUI(ui: UIComponent): number;\n    }\n}\n"},{"path":"types/map/Map.CoordTransform.d.ts","content":"import { Coordinate, Extent, Point, PointExtent, Size } from '../geo';\ndeclare module \"./Map\" {\n    interface Map {\n        /**\n         * Converts a coordinate to the 2D point in current zoom or in the specific zoom. <br>\n         * The 2D point's coordinate system's origin is the same with map's origin.\n         * Usually used in plugin development.\n         * @param  coordinate - coordinate\n         * @param  zoom  - zoom level\n         * @param  out    - optional point to receive result\n         * @return  2D point\n         * @example\n         * var point = map.coordinateToPoint(new Coordinate(121.3, 29.1));\n         */\n        coordinateToPoint(coordinate: Coordinate, zoom?: number, out?: Point): Point;\n        /**\n         * Converts a coordinate to the 2D point at specified resolution. <br>\n         * The 2D point's coordinate system's origin is the same with map's origin.\n         * Usually used in plugin development.\n         * @param  coordinate - coordinate\n         * @param  res  - target resolution\n         * @param  out    - optional point to receive result\n         * @return  2D point\n         * @example\n         * var point = map.coordinateToPoint(new Coordinate(121.3, 29.1));\n         */\n        coordinateToPointAtRes(coordinate: Coordinate, res?: number, out?: Point): Point;\n        /**\n         * Converts a 2D point in current zoom or a specific zoom to a coordinate.\n         * Usually used in plugin development.\n         * @param  point - 2D point\n         * @param  zoom  - point's zoom level\n         * @param  out    - optional coordinate to receive result\n         * @return coordinate\n         * @example\n         * var coord = map.pointToCoordinate(new Point(4E6, 3E4));\n         */\n        pointToCoordinate(point: Point, zoom?: number, out?: Coordinate): Coordinate;\n        /**\n         * Converts a 2D point at specific resolution to a coordinate.\n         * Usually used in plugin development.\n         * @param  point - 2D point\n         * @param  res  - point's resolution\n         * @param  out    - optional coordinate to receive result\n         * @return coordinate\n         * @example\n         * var coord = map.pointAtResToCoordinate(new Point(4E6, 3E4), map.getResolution());\n         */\n        pointAtResToCoordinate(point: Point, res?: number, out?: Coordinate): Coordinate;\n        /**\n         * Converts a geographical coordinate to view point.<br>\n         * A view point is a point relative to map's mapPlatform panel's position. <br>\n         * Usually used in plugin development.\n         * @param coordinate\n         * @param  out    - optional point to receive result\n         * @return          */\n        coordinateToViewPoint(coordinate: Coordinate, out?: Point, altitude?: number): Point;\n        /**\n         * Converts a view point to the geographical coordinate.\n         * Usually used in plugin development.\n         * @param viewPoint\n         * @param  out    - optional coordinate to receive result\n         * @return          */\n        viewPointToCoordinate(viewPoint: Point, out?: Coordinate): Coordinate;\n        /**\n         * Convert a geographical coordinate to the container point. <br>\n         *  A container point is a point relative to map container's top-left corner. <br>\n         * @param                - coordinate\n         * @param  zoom  - zoom level\n         * @param  out    - optional point to receive result\n         * @return          */\n        coordinateToContainerPoint(coordinate: Coordinate, zoom?: number, out?: Point): Point;\n        coordinateToContainerPointAtRes(coordinate: Coordinate, res?: number, out?: Point): Point;\n        /**\n         * Convert a geographical coordinate to the container point. <br>\n         * Batch conversion for better performance <br>\n         *  A container point is a point relative to map container's top-left corner. <br>\n         * @param  coordinates - coordinates\n         * @param  zoom  - zoom level\n         * @return {Point[]}\n         */\n        coordinatesToContainerPoints(coordinates: Array<Coordinate>, zoom?: number): Array<Point>;\n        /**\n         * Convert a geographical coordinate to the container point. <br>\n         * Batch conversion for better performance <br>\n         *  A container point is a point relative to map container's top-left corner. <br>\n         * @param  coordinates                - coordinates\n         * @param  resolution  - container points' resolution\n         * @return\n         */\n        coordinatesToContainerPointsAtRes(coordinates: Array<Coordinate>, res?: number): Array<Point>;\n        /**\n         * Converts a container point to geographical coordinate.\n         * @param          * @param  out    - optional coordinate to receive result\n         * @return          */\n        containerPointToCoordinate(containerPoint: Point, out?: Coordinate): Coordinate;\n        /**\n         * Converts a container point extent to the geographic extent.\n         * @param  containerExtent - containeproints extent\n         * @return  geographic extent\n         */\n        containerToExtent(containerExtent: PointExtent): Extent;\n        /**\n         * Converts geographical distances to the pixel length.<br>\n         * The value varis with difference zoom level.\n         *\n         * @param  xDist - distance on X axis.\n         * @param  yDist - distance on Y axis.\n         * @return {Size} result.width: pixel length on X axis; result.height: pixel length on Y axis\n         */\n        distanceToPixel(xDist: number, yDist: number, zoom?: number): Size;\n        /**\n         * Converts geographical distances to the 2d point length.<br>\n         * The value varis with difference zoom level.\n         *\n         * @param  xDist - distance on X axis.\n         * @param  yDist - distance on Y axis.\n         * @param  zoom - point's zoom\n         * @return          */\n        distanceToPoint(xDist: number, yDist: number, zoom?: number, paramCenter?: Coordinate): Point;\n        /**\n         * Converts geographical distances to the 2d point length at specified resolution.\n         *\n         * @param  xDist - distance on X axis.\n         * @param  yDist - distance on Y axis.\n         * @param  res - target resolution\n         * @return          */\n        distanceToPointAtRes(xDist: number, yDist: number, res?: number, paramCenter?: Coordinate, out?: Point): Point;\n        /**\n         * Converts height/altitude  to the 2d point\n         *\n         * @param  altitude - the value of altitude,suche as: map.altitudeToPoint(100);\n         * @param  res - target resolution\n         * @param  [originCenter=null] - optional original coordinate for caculation\n         * @return          */\n        altitudeToPoint(altitude: number, res?: number, originCenter?: Coordinate): number;\n        pointAtResToAltitude(point: Point, res?: number, originCenter?: Coordinate): number;\n        /**\n         * Converts pixel size to geographical distance.\n         *\n         * @param  width - pixel width\n         * @param  height - pixel height\n         * @return  distance - Geographical distance\n         */\n        pixelToDistance(width: number, height: number): number;\n        /**\n         * Converts 2d point distances to geographic length.<br>\n         *\n         * @param  dx - distance on X axis.\n         * @param  dy - distance on Y axis.\n         * @param  zoom - point's zoom\n         * @return distance\n         */\n        pointToDistance(dx: number, dy: number, zoom?: number): number;\n        /**\n         * Converts 2d point distances to geographic length.<br>\n         *\n         * @param  dx - distance on X axis.\n         * @param  dy - distance on Y axis.\n         * @param  res - point's resolution\n         * @return distance\n         */\n        pointAtResToDistance(dx: number, dy: number, res?: number, paramCenter?: Coordinate): number;\n        /**\n         * Computes the coordinate from the given pixel distance.\n         * @param  coordinate - source coordinate\n         * @param  px           - pixel distance on X axis\n         * @param  py           - pixel distance on Y axis\n         * @return Result coordinate\n         */\n        locateByPoint(coordinate: Coordinate, px: number, py: number): Coordinate;\n        /**\n         * Get map's extent in view points.\n         * @param zoom - zoom\n         * @return\n         */\n        get2DExtent(zoom?: number, out?: PointExtent): PointExtent;\n        get2DExtentAtRes(res?: number, out?: PointExtent): PointExtent;\n        /**\n         * Converts a view point extent to the geographic extent.\n         * @param  extent2D - view points extent\n         * @return  geographic extent\n         */\n        pointToExtent(extent2D: PointExtent): Extent;\n        /**\n         * When moving map, map's center is updated in real time, but platform will be moved in the next frame to keep syncing with other layers\n         * Get the offset in current frame and the next frame\n         * @return view point offset\n         */\n        getViewPointFrameOffset(): Point | null;\n        /**\n     * transform view point to geographical projected coordinate\n        * @param  viewPoint\n        * @param  out  - optional coordinate to receive result\n        * @return         */\n        viewPointToPrj(viewPoint: Point, out?: Point): Point;\n        /**\n         * transform geographical projected coordinate to container point\n         * @param  pCoordinate\n         * @param  zoom target zoom\n         * @param  out    - optional point to receive result\n         */\n        prjToContainerPoint(pCoordinate: Coordinate, zoom?: number, out?: Point, altitude?: number): Point;\n        prjToContainerPointAtRes(pCoordinate: Coordinate, res?: number, out?: Point, altitude?: number): Point;\n        /**\n         * transform geographical projected coordinate to view point\n         * @param  pCoordinate\n         * @return          */\n        prjToViewPoint(pCoordinate: Coordinate, out?: Point, altitude?: number): Point;\n        viewPointToPoint(viewPoint: Point, zoom?: number, out?: Point): Point;\n        pointToViewPoint(point: Point, zoom?: number, out?: Point): Point;\n    }\n}\n"},{"path":"types/map/Map.d.ts","content":"import Class from '../core/Class';\nimport Point from '../geo/Point';\nimport Size from '../geo/Size';\nimport PointExtent from '../geo/PointExtent';\nimport Extent from '../geo/Extent';\nimport Coordinate from '../geo/Coordinate';\nimport Layer from '../layer/Layer';\nimport SpatialReference, { type SpatialReferenceType } from './spatial-reference/SpatialReference';\nimport { AnimationOptionsType, EasingType } from '../core/Animation';\ndeclare const Map_base: {\n    new (...args: any[]): {\n        _handlers?: import(\"src\").Handler[];\n        addHandler(name: any, handlerClass: any): any;\n        removeHandler(name: any): any;\n        _clearHandlers(): void;\n    };\n} & {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & {\n    new (...args: any[]): {};\n    registerRenderer<T extends typeof Class>(name: string, clazz: T): any & typeof Class;\n    getRendererClass(name: string): Class;\n} & typeof Class;\n/**\n * The central class of the library, to create a map on a container.\n *\n * @category map\n *\n * @mixes Eventable\n * @mixes Handlerable\n * @mixes ui.Menuable\n * @mixes Renderable\n *\n * @example\n * var map = new maptalks.Map(\"map\",{\n *      center:     [180,0],\n *      zoom:  4,\n *      baseLayer : new maptalks.TileLayer(\"base\",{\n *          urlTemplate:'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n *          subdomains:['a','b','c']\n *      }),\n *      layers : [\n *          new maptalks.VectorLayer('v', [new maptalks.Marker([180, 0])])\n *      ]\n * });\n */\nexport declare class Map extends Map_base {\n    VERSION: string;\n    private _loaded;\n    private _panels;\n    private _baseLayer;\n    private _layers;\n    private _zoomLevel;\n    private _center;\n    private _centerZ;\n    private _mapViewPoint;\n    isMap: boolean;\n    private _containerDOM;\n    private _spatialReference;\n    private _originLng;\n    private _altitudeOriginDirty;\n    private _glScale;\n    private _cursor;\n    private _prjCenter;\n    private centerAltitude;\n    width: number;\n    height: number;\n    private _prjMaxExtent;\n    private _glRes;\n    private _zooming;\n    private _layerCache;\n    private _mapViewCoord;\n    private _eventSilence;\n    private _moving;\n    private _originCenter;\n    private _suppressRecenter;\n    private _dragRotating;\n    CanvasClass: any;\n    private _priorityCursor;\n    private _initTime;\n    private _renderer;\n    private _containerDomContentRect;\n    private _mapRes;\n    private _onLoadHooks;\n    private cameraCenterDistance;\n    options: MapOptionsType;\n    static VERSION: string;\n    JSON_VERSION: '1.0';\n    /**\n     * @param {(string|HTMLElement|object)} container - The container to create the map on, can be:<br>\n     *                                          1. A HTMLElement container.<br/>\n     *                                          2. ID of a HTMLElement container.<br/>\n     *                                          3. Any canvas compatible container\n     * @param {Object} options - construct options\n     * @param {(Number[]|Coordinate)} options.center - initial center of the map.\n     * @param {Number} options.zoom - initial zoom of the map.\n     * @param {Object} [options.spatialReference=null] - map's spatial reference, default is using projection EPSG:3857 with resolutions used by google map/osm.\n     * @param {Layer} [options.baseLayer=null] - base layer that will be set to map initially.\n     * @param {Layer[]} [options.layers=null] - layers that will be added to map initially.\n     * @param {*} options.* - any other option defined in [Map.options]{@link Map#options}      [description]\n     */\n    constructor(container: MapContainerType, options: MapCreateOptionsType);\n    /**\n     * Add hooks for additional codes when map's loading complete, useful for plugin developping.\n     * Note that it can only be called before the map is created.\n     * @param {Function | any} fn\n     * @returns {Map}\n     */\n    static addOnLoadHook(fn: string | ((...args: any[]) => void), ...args: any[]): typeof Map;\n    /**\n     * Whether the map is loaded or not.\n     * @return {Boolean}\n     */\n    isLoaded(): boolean;\n    /**\n     * Get map's container\n     * @returns {HTMLElement}\n     */\n    getContainer(): HTMLCanvasElement | HTMLDivElement;\n    /**\n     * Get the spatial reference of the Map.\n     * @return {SpatialReference} map's spatial reference\n     */\n    getSpatialReference(): SpatialReference;\n    /**\n     * Change the spatial reference of the map. <br>\n     * A SpatialReference is a series of settings to decide the map presentation:<br>\n     * 1. the projection.<br>\n     * 2. zoom levels and resolutions. <br>\n     * 3. full extent.<br>\n     * There are some [predefined spatial references]{@link http://www.foo.com}, and surely you can [define a custom one.]{@link http://www.foo.com}.<br>\n     * SpatialReference can also be updated by map.config('spatialReference', spatialReference);\n     * @param {SpatialReference} spatialReference - spatial reference\n     * @returns {Map} this\n     * @fires Map#spatialreferencechange\n     * @example\n     *  map.setSpatialReference({\n            projection:'EPSG:4326',\n            resolutions: (function() {\n                const resolutions = [];\n                for (let i=0; i < 19; i++) {\n                    resolutions[i] = 180/(Math.pow(2, i)*128);\n                }\n                return resolutions;\n            })()\n     *  });\n       @example\n     *  map.config('spatialReference', {\n            projection:'EPSG:4326',\n            resolutions: (function() {\n                const resolutions = [];\n                for (let i=0; i < 19; i++) {\n                    resolutions[i] = 180/(Math.pow(2, i)*128);\n                }\n                return resolutions;\n            })()\n        });\n     */\n    setSpatialReference(ref: SpatialReferenceType): this;\n    _updateSpatialReference(ref: SpatialReferenceType, oldRef: any): this;\n    /**\n     * Callback when any option is updated\n     * @param  {Object} conf - options to update\n     * @return {Map}   this\n     */\n    onConfig(conf: {\n        [key: string]: any;\n    }): this;\n    /**\n     * Get the projection of the map. <br>\n     * Projection is an algorithm for map projection, e.g. well-known [Mercator Projection]{@link https://en.wikipedia.org/wiki/Mercator_projection} <br>\n     * A projection must have 2 methods: <br>\n     * 1. project(coordinate) - project the input coordinate <br>\n     * 2. unproject(coordinate) - unproject the input coordinate <br>\n     * Projection also contains measuring method usually extended from a measurer: <br>\n     * 1. measureLength(coord1, coord2) - compute length between 2 coordinates.  <br>\n     * 2. measureArea(coords[]) - compute area of the input coordinates. <br>\n     * 3. locate(coord, distx, disty) - compute the coordinate from the coord with xdist on axis x and ydist on axis y.\n     * @return {Object}\n     */\n    getProjection(): import(\"src/geo/projection\").ProjectionType;\n    /**\n     * Get map's full extent, which is defined in map's spatial reference. <br>\n     * eg: {'left': -180, 'right' : 180, 'top' : 90, 'bottom' : -90}\n     * @return {Extent}\n     */\n    getFullExtent(): Extent;\n    /**\n     * Set map's cursor style, cursor style is same with CSS.\n     * @param {String} cursor - cursor style\n     * @returns {Map} this\n     * @example\n     * map.setCursor('url(cursor.png) 4 12, auto');\n     */\n    setCursor(cursor: string): this;\n    /**\n     * Reset map's cursor style.\n     * @return {Map} this\n     * @example\n     * map.resetCursor();\n     */\n    resetCursor(): this;\n    /**\n     * Get center of the map.\n     * @return {Coordinate}\n     */\n    getCenter(): Coordinate;\n    /**\n     * Set a new center to the map.\n     * @param {Coordinate} center\n     * @param  {Object} [padding]\n     * @param  {Number} [padding.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Number} [padding.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Number} [padding.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Number} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @return {Map} this\n     */\n    setCenter(center: Coordinate, padding?: MapPaddingType): this;\n    /**\n     * Get map's size (width and height) in pixel.\n     * @return {Size}\n     */\n    getSize(): Size;\n    /**\n     * Get container extent of the map\n     * @return {PointExtent}\n     */\n    getContainerExtent(): PointExtent;\n    _getVisualHeight(visualPitch: any): number;\n    /**\n     * Get the geographical extent of map's current view extent.\n     *\n     * @return {Extent}\n     */\n    getExtent(): Extent;\n    /**\n     * Get the projected geographical extent of map's current view extent.\n     *\n     * @return {Extent}\n     */\n    getProjExtent(): Extent;\n    /**\n     * Alias for getProjExtent\n     *\n     * @return {Extent}\n     */\n    getPrjExtent(): Extent;\n    /**\n     * Get the max extent that the map is restricted to.\n     * @return {Extent}\n     */\n    getMaxExtent(): Extent;\n    /**\n     * Sets the max extent that the map is restricted to.\n     * @param {Extent}\n     * @return {Map} this\n     * @example\n     * map.setMaxExtent(map.getExtent());\n     */\n    setMaxExtent(extent: Extent): this;\n    /**\n     * Get map's current zoom.\n     * @return {Number}\n     */\n    getZoom(): number;\n    /**\n     * Caculate the target zoom if scaling from \"fromZoom\" by \"scale\"\n     * @param  {Number} scale\n     * @param  {Number} fromZoom\n     * @param  {Boolean} isFraction - can return fractional zoom\n     * @return {Number} zoom fit for scale starting from fromZoom\n     */\n    getZoomForScale(scale: number, fromZoom?: number, isFraction?: boolean): number;\n    getZoomFromRes(res: number): number;\n    /**\n     * Sets zoom of the map\n     * @param {Number} zoom\n     * @param {Object} [options=null] options\n     * @param {Boolean} [options.animation=true] whether zoom is animation, true by default\n     * @returns {Map} this\n     */\n    setZoom(zoom: number, options?: {\n        animation: boolean;\n    }): this;\n    /**\n     * Get the max zoom that the map can be zoom to.\n     * @return {Number}\n     */\n    getMaxZoom(): number;\n    /**\n     * Sets the max zoom that the map can be zoom to.\n     * @param {Number} maxZoom\n     * @returns {Map} this\n     */\n    setMaxZoom(maxZoom: number): this;\n    /**\n     * Get the min zoom that the map can be zoom to.\n     * @return {Number}\n     */\n    getMinZoom(): number;\n    /**\n     * Sets the min zoom that the map can be zoom to.\n     * @param {Number} minZoom\n     * @return {Map} this\n     */\n    setMinZoom(minZoom: number): this;\n    /**\n     * Maximum zoom the map has\n     * @return {Number}\n     */\n    getMaxNativeZoom(): number;\n    /**\n     * Resolution for world point in WebGL context\n     * @returns {Number}\n     */\n    getGLRes(): number;\n    /**\n     * Caculate scale from gl zoom to given zoom (default by current zoom)\n     * @param {Number} [zoom=undefined] target zoom, current zoom by default\n     * @returns {Number}\n     * @examples\n     * const point = map.coordToPoint(map.getCenter());\n     * // convert to point in gl zoom\n     * const glPoint = point.multi(this.getGLScale());\n     */\n    getGLScale(zoom?: number): number;\n    /**\n     * zoom in\n     * @return {Map} this\n     */\n    zoomIn(): this;\n    /**\n     * zoom out\n     * @return {Map} this\n     */\n    zoomOut(): this;\n    /**\n     * Whether the map is zooming\n     * @return {Boolean}\n     */\n    isZooming(): boolean;\n    /**\n     * Whether the map is being interacted\n     * @return {Boolean}\n     */\n    isInteracting(): boolean;\n    /**\n     * Sets the center and zoom at the same time.\n     * @param {Coordinate} center\n     * @param {Number} zoom\n     * @return {Map} this\n     */\n    setCenterAndZoom(center: Coordinate, zoom?: number): this;\n    /**\n     * Get the padding Size\n     * @param  {Object} options\n     * @param  {Number} [options.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Number} [options.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Number} [options.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Number} [options.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @returns {Object|null}\n     */\n    _getPaddingSize(options?: {}): {\n        width: any;\n        height: any;\n    };\n    /**\n     * Caculate the zoom level that contains the given extent with the maximum zoom level possible.\n     * @param {Extent} extent\n     * @param  {Boolean} [isFraction] - can return fractional zoom\n     * @param  {Object} [padding] [padding] - padding\n     * @param  {Object} [padding.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Object} [padding.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Object} [padding.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Object} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @return {Number} zoom fit for scale starting from fromZoom\n     */\n    getFitZoom(extent: Extent, isFraction?: boolean, padding?: MapPaddingType): number;\n    /**\n     * Get map's current view (center/zoom/pitch/bearing)\n     * @return {Object} { center : *, zoom : *, pitch : *, bearing : * }\n     */\n    getView(): MapViewType;\n    /**\n     * Set map's center/zoom/pitch/bearing at one time\n     * @param {Object} view - a object containing center/zoom/pitch/bearing\n     * return {Map} this\n     */\n    setView(view: MapViewType): this;\n    /**\n     * Get map's resolution\n     * @param {Number} zoom - zoom or current zoom if not given\n     * @return {Number} resolution\n     */\n    getResolution(zoom?: number): number;\n    /**\n     * Get scale of resolutions from zoom to max zoom\n     * @param {Number} zoom - zoom or current zoom if not given\n     * @return {Number} scale\n     */\n    getScale(zoom?: number): number;\n    /**\n     * Get center by the padding.\n     * @private\n     * @param  {Coordinate} center\n     * @param  {Number} zoom\n     * @param  {Object} padding\n     * @param  {Number} [padding.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Number} [padding.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Number} [padding.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Number} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @return {Coordinate}\n     */\n    _getCenterByPadding(center: Coordinate, zoom?: number, padding?: MapPaddingType): Coordinate;\n    /**\n     * Set the map to be fit for the given extent with the max zoom level possible.\n     * @param  {Extent} extent - extent\n     * @param  {Number} zoomOffset - zoom offset\n     * @param  {Object} [options={}] - options\n     * @param  {Object} [options.animation]\n     * @param  {Object} [options.duration]\n     * @param  {Object} [options.zoomAnimationDuration]\n     * @param  {Object} [options.easing='out']\n     * @param  {Number} [options.paddingLeft] - Sets the amount of padding in the left of a map container\n     * @param  {Number} [options.paddingTop] - Sets the amount of padding in the top of a map container\n     * @param  {Number} [options.paddingRight] - Sets the amount of padding in the right of a map container\n     * @param  {Number} [options.paddingBottom] - Sets the amount of padding in the bottom of a map container\n     * @param  {Boolean} [options.isFraction=false] - can locate to fractional zoom\n     * @param  {Function} step - step function for animation\n     * @return {Map | player} - this\n     */\n    fitExtent(extent: Extent, zoomOffset?: number, options?: MapFitType, step?: (frame: any) => void): this | import(\"../core/Animation\").Player;\n    /**\n     * Get the base layer of the map.\n     * @return {Layer}\n     */\n    getBaseLayer(): Layer;\n    /**\n     * Sets a new base layer to the map.<br>\n     * Some events will be thrown such as baselayerchangestart, baselayerload, baselayerchangeend.\n     * @param  {Layer} baseLayer - new base layer\n     * @return {Map} this\n     * @fires Map#setbaselayer\n     * @fires Map#baselayerchangestart\n     * @fires Map#baselayerchangeend\n     */\n    setBaseLayer(baseLayer: Layer): this;\n    /**\n     * Remove the base layer from the map\n     * @return {Map} this\n     * @fires Map#baselayerremove\n     */\n    removeBaseLayer(): this;\n    /**\n     * Get the layers of the map, except base layer (which should be by getBaseLayer). <br>\n     * A filter function can be given to filter layers, e.g. exclude all the VectorLayers.\n     * @param {Function} [filter=undefined] - a filter function of layers, return false to exclude the given layer.\n     * @return {Layer[]}\n     * @example\n     * var vectorLayers = map.getLayers(function (layer) {\n     *     return (layer instanceof VectorLayer);\n     * });\n     */\n    getLayers(filter?: (layer: Layer) => boolean): Array<Layer>;\n    /**\n     * Get the layer with the given id.\n     * @param  {String} id - layer id\n     * @return {Layer}\n     */\n    getLayer(id: string): Layer | null;\n    /**\n     * Add a new layer on the top of the map.\n     * @param  {Layer|Layer[]} layer - one or more layers to add\n     * @return {Map} this\n     * @fires Map#addlayer\n     */\n    addLayer(layers: Layer | Array<Layer>, ...otherLayers: Array<Layer>): this;\n    /**\n     * Remove a layer from the map\n     * @param  {String|String[]|Layer|Layer[]} layer - one or more layers or layer ids\n     * @return {Map} this\n     * @fires Map#removelayer\n     */\n    removeLayer(layers: Layer | Array<Layer>): this;\n    /**\n     * Sort layers according to the order provided, the last will be on the top.\n     * @param  {string[]|Layer[]} layers - layers or layer ids to sort\n     * @return {Map} this\n     * @example\n     * map.addLayer([layer1, layer2, layer3]);\n     * map.sortLayers([layer2, layer3, layer1]);\n     * map.sortLayers(['3', '2', '1']); // sort by layer ids.\n     */\n    sortLayers(layers: Array<Layer>): this;\n    /**\n     * Exports image from the map's canvas.\n     * @param {Object} [options=undefined] - options\n     * @param {String} [options.mimeType=image/png] - mime type of the image: image/png, image/jpeg, image/webp\n     * @param {String} [options.quality=0.92] - A Number between 0 and 1 indicating the image quality to use for image formats that use lossy compression such as image/jpeg and image/webp.\n     * @param {Boolean} [options.save=false] - whether pop a file save dialog to save the export image.\n     * @param {String} [options.fileName=export] - specify the file name, if options.save is true.\n     * @return {String} image of base64 format.\n     */\n    toDataURL(options?: MapDataURLType): string | null;\n    /**\n     * shorter alias for coordinateToPoint\n     */\n    coordToPoint(coordinate: Coordinate, zoom?: number, out?: Point): Point;\n    /**\n     * shorter alias for coordinateToPointAtRes\n     */\n    coordToPointAtRes(coordinate: Coordinate, res?: number, out?: Point): Point;\n    /**\n     * shorter alias for pointToCoordinate\n     */\n    pointToCoord(point: Point, zoom?: number, out?: Coordinate): Coordinate;\n    /**\n     * shorter alias for pointAtResToCoordinate\n     */\n    pointAtResToCoord(point: Point, res?: number, out?: Coordinate): Coordinate;\n    /**\n     * shorter alias for coordinateToViewPoint\n     */\n    coordToViewPoint(coordinate: Coordinate, out?: Point, altitude?: number): Point;\n    /**\n     * shorter alias for viewPointToCoordinate\n     */\n    viewPointToCoord(viewPoint: Point, out?: Coordinate): Coordinate;\n    /**\n     * shorter alias for coordinateToContainerPoint\n     */\n    coordToContainerPoint(coordinate: Coordinate, zoom?: number, out?: Point): Point;\n    /**\n     * shorter alias for containerPointToCoordinate\n     */\n    containerPointToCoord(containerPoint: Point, out?: Coordinate): Coordinate;\n    /**\n     * Converts a container point to the view point.\n     * Usually used in plugin development.\n     * @param {Point}\n     * @param  {Point} [out=undefined]    - optional point to receive result\n     * @returns {Point}\n     */\n    containerPointToViewPoint(containerPoint: Point, out?: Point): Point;\n    /**\n     * Converts a view point to the container point.\n     * Usually used in plugin development.\n     * @param {Point}\n     * @param  {Point} [out=undefined]    - optional point to receive result\n     * @returns {Point}\n     */\n    viewPointToContainerPoint(viewPoint: Point, out?: Point): Point;\n    /**\n     * Checks if the map container size changed and updates the map if so.\n     * @return {Map} this\n     * @fires Map#resize\n     */\n    checkSize(force?: boolean): this;\n    /**\n     * Computes the coordinate from the given meter distance.\n     * @param  {Coordinate} coordinate - source coordinate\n     * @param  {Number} dx           - meter distance on X axis\n     * @param  {Number} dy           - meter distance on Y axis\n     * @return {Coordinate} Result coordinate\n     */\n    locate(coordinate: Coordinate, dx: number, dy: number): Coordinate;\n    /**\n     * Return map's main panel\n     * @returns {HTMLElement}\n     */\n    getMainPanel(): HTMLDivElement | null;\n    /**\n     * Returns map panels.\n     * @return {Object}\n     */\n    getPanels(): Record<string, PanelDom>;\n    /**\n     * Remove the map\n     * @return {Map} this\n     */\n    remove(): this;\n    /**\n     * whether the map is removed\n     * @return {Boolean}\n     */\n    isRemoved(): boolean;\n    /**\n     * Whether the map is moving\n     * @return {Boolean}\n     */\n    isMoving(): boolean;\n    /**\n     * The callback function when move started\n     * @private\n     * @fires Map#movestart\n     */\n    onMoveStart(param?: any): void;\n    onMoving(param: any): void;\n    onMoveEnd(param: any): void;\n    onDragRotateStart(param: any): void;\n    onDragRotating(param: any): void;\n    onDragRotateEnd(param: any): void;\n    isDragRotating(): boolean;\n    /**\n     * Test if given box is out of current screen\n     * @param {Number[] | PointExtent} box - [minx, miny, maxx, maxy]\n     * @param {Number} padding - test padding\n     * @returns {Boolean}\n     */\n    isOffscreen(box: PointExtent | Array<number>, viewportPadding?: number): boolean;\n    getRenderer(): any;\n    /**\n     * Get map's devicePixelRatio, you can override it by setting devicePixelRatio in options.\n     * @returns {Number}\n     */\n    getDevicePixelRatio(): number;\n    /**\n     * Set map's devicePixelRatio\n     * @param {Number} dpr\n     * @returns {Map} this\n     */\n    setDevicePixelRatio(dpr: number): this;\n    _initContainer(container: MapContainerType): void;\n    /**\n     * try to change cursor when map is not setCursored\n     * @private\n     * @param  {String} cursor css cursor\n     */\n    _trySetCursor(cursor: string): this;\n    _setPriorityCursor(cursor: string): this;\n    _setCursorToPanel(cursor: string): void;\n    _removeLayer(layer: Layer, layerList: Array<Layer>): void;\n    _sortLayersByZIndex(): void;\n    _fireEvent(eventName: string, param?: {\n        [key: string]: any;\n    }): void;\n    _Load(): void;\n    _initRenderer(): void;\n    _getRenderer(): any;\n    _loadAllLayers(): void;\n    /**\n     * Gets layers that fits for the filter\n     * @param  {fn} filter - filter function\n     * @return {Layer[]}\n     * @private\n     */\n    _getLayers(filter?: (layer: Layer) => boolean): any[];\n    _eachLayer(fn: any, ...layerLists: any[]): void;\n    _onLayerEvent(param: any): void;\n    _resetMapStatus(): void;\n    setContainerDomRect(domRect: DOMRect): void;\n    _getContainerDomSize(): Size | null;\n    _updateMapSize(mSize: Size): this;\n    /**\n     * Gets projected center of the map\n     * @return {Coordinate}\n     * @private\n     */\n    _getPrjCenter(): Coordinate;\n    _setPrjCenter(pcenter: Coordinate): void;\n    _setPrjCoordAtContainerPoint(coordinate: Coordinate, point: Point): this;\n    _setPrjCoordAtOffsetToCenter(prjCoord: Coordinate, offset: Point): this;\n    _verifyExtent(prjCenter: Coordinate): boolean;\n    /**\n     * Move map's center by pixels.\n     * @param  {Point} pixel - pixels to move, the relation between value and direction is as:\n     * -1,1 | 1,1\n     * ------------\n     *-1,-1 | 1,-1\n     * @private\n     * @returns {Coordinate} the new projected center.\n     */\n    _offsetCenterByPixel(pixel: Point): void;\n    /**\n     * offset map panels.\n     *\n     * @param  {Point} offset - offset in pixel to move\n     * @return {Map} this\n     */\n    /**\n     * Gets map panel's current view point.\n     * @return {Point}\n     */\n    offsetPlatform(offset?: Point): Point;\n    /**\n     * Get map's view point, adding in frame offset\n     * @return {Point} map view point\n     */\n    getViewPoint(): Point;\n    _resetMapViewPoint(): void;\n    /**\n     * Get map's current resolution\n     * @return {Number} resolution\n     * @private\n     */\n    _getResolution(zoom?: number): number;\n    _getResolutions(): number[];\n    /**\n     * Converts the projected coordinate to a 2D point in the specific zoom\n     * @param  {Coordinate} pCoord - projected Coordinate\n     * @param  {Number} zoom   - point's zoom level\n     * @return {Point} 2D point\n     * @private\n     */\n    _prjToPoint(pCoord: any, zoom?: number, out?: Point): Point;\n    _prjToPointAtRes(pCoord: Coordinate, res?: number, out?: Point): Point;\n    /**\n     * Converts the projected coordinate to a 2D point in the specific resolution\n     * @param  {Coordinate} pCoord - projected Coordinate\n     * @param  {Number} res   - point's resolution\n     * @return {Point} 2D point\n     * @private\n     */\n    _prjsToPointsAtRes(pCoords: Array<Coordinate>, res?: number, resultPoints?: any[]): Array<Point>;\n    /**\n     * Converts the 2D point to projected coordinate\n     * @param  {Point} point - 2D point\n     * @param  {Number} zoom   - point's zoom level\n     * @return {Coordinate} projected coordinate\n     * @private\n     */\n    _pointToPrj(point: Point, zoom?: number, out?: Coordinate): Coordinate;\n    _pointToPrjAtRes(point: Point, res?: number, out?: Coordinate): Coordinate;\n    /**\n     * Convert point at zoom to point at current zoom\n     * @param  {Point} point point\n     * @param  {Number} zoom point's zoom\n     * @return {Point} point at current zoom\n     * @private\n     */\n    _pointToPoint(point: Point, zoom?: number, out?: Point): Point;\n    _pointAtResToPoint(point: Point, res?: number, out?: Point): Point;\n    /**\n     * Convert point at current zoom to point at target res\n     * @param  {Point} point point\n     * @param  {Number} res target res\n     * @return {Point} point at target res\n     * @private\n     */\n    _pointToPointAtRes(point: Point, res?: number, out?: Point): Point;\n    /**\n     * transform container point to geographical projected coordinate\n     *\n     * @param  {Point} containerPoint\n     * @return {Coordinate}\n     * @private\n     */\n    _containerPointToPrj(containerPoint: Point, out?: Coordinate): Coordinate;\n    _callOnLoadHooks(): void;\n    _fixPrjOnWorldWide(prjCoord: Coordinate): this;\n    /**\n     * Export the map's json, a snapshot of the map in JSON format.<br>\n     * It can be used to reproduce the instance by [fromJSON]{@link Map#fromJSON} method\n     * @param  {Object} [options=null] - export options\n     * @param  {Boolean|Object} [options.baseLayer=null] - whether to export base layer's JSON, if yes, it will be used as layer's toJSON options.\n     * @param  {Boolean|Extent} [options.clipExtent=null] - if set with an extent instance, only the geometries intersectes with the extent will be exported.\n     *                                                             If set to true, map's current extent will be used.\n     * @param  {Boolean|Object|Object[]} [options.layers=null] - whether to export other layers' JSON, if yes, it will be used as layer's toJSON options.\n     *                                                        It can also be an array of layer export options with a \"id\" attribute to filter the layers to export.\n     * @return {Object} layer's JSON\n     */\n    toJSON(options?: MapOptionsType): {\n        [key: string]: any;\n    };\n    /**\n     * Reproduce a map from map's profile JSON.\n     * @param {(string|HTMLElement|object)} container - The container to create the map on, can be:<br>\n     *                                          1. A HTMLElement container.<br/>\n     *                                          2. ID of a HTMLElement container.<br/>\n     *                                          3. A canvas compatible container in node,\n     *                                          e.g. [node-canvas]{@link https://github.com/Automattic/node-canvas},\n     *                                              [canvas2svg]{@link https://github.com/gliffy/canvas2svg}\n     * @param  {Object} mapJSON - map's profile JSON\n     * @param  {Object} [options=null] - options\n     * @param  {Object} [options.baseLayer=null] - whether to import the baseLayer\n     * @param  {Object} [options.layers=null]    - whether to import the layers\n     * @return {Map}\n     * @static\n     * @function\n     * @example\n     * var map = Map.fromJSON('map', mapProfile);\n     */\n    static fromJSON(container: MapContainerType, profile: {\n        [key: string]: any;\n    }, options?: MapOptionsType): Map;\n}\nexport default Map;\nexport type MapOptionsType = {\n    baseLayer?: Layer;\n    layers?: Array<Layer>;\n    draggable?: boolean;\n    dragPan?: boolean;\n    dragRotate?: boolean;\n    dragPitch?: boolean;\n    dragRotatePitch?: boolean;\n    touchGesture?: boolean;\n    touchZoom?: boolean;\n    touchRotate?: boolean;\n    touchPitch?: boolean;\n    touchZoomRotate?: boolean;\n    doubleClickZoom?: boolean;\n    scrollWheelZoom?: boolean;\n    geometryEvents?: boolean;\n    control?: boolean;\n    attribution?: boolean;\n    zoomControl?: boolean;\n    scaleControl?: boolean;\n    overviewControl?: boolean;\n    fog?: boolean;\n    fogColor?: any;\n    devicePixelRatio?: number;\n    heightFactor?: number;\n    cameraInfiniteFar?: boolean;\n    originLatitudeForAltitude?: number;\n    viewHistory?: boolean;\n    viewHistoryCount?: number;\n    seamlessZoom?: boolean;\n    maxVisualPitch?: number;\n    maxPitch?: number;\n    centerCross?: boolean;\n    zoomInCenter?: boolean;\n    zoomOrigin?: Array<number>;\n    zoomAnimation?: boolean;\n    zoomAnimationDuration?: number;\n    panAnimation?: boolean;\n    panAnimationDuration?: number;\n    rotateAnimation?: boolean;\n    rotateAnimationDuration?: number;\n    zoomable?: boolean;\n    enableInfoWindow?: boolean;\n    hitDetect?: boolean;\n    hitDetectLimit?: number;\n    fpsOnInteracting?: number;\n    layerCanvasLimitOnInteracting?: number;\n    maxZoom?: number;\n    minZoom?: number;\n    maxExtent?: Extent;\n    fixCenterOnResize?: boolean;\n    checkSize?: boolean;\n    checkSizeInterval?: number;\n    renderer?: 'canvas' | 'gl';\n    cascadePitches?: Array<number>;\n    renderable?: boolean;\n    clickTimeThreshold?: number;\n    stopRenderOnOffscreen?: boolean;\n    preventWheelScroll?: boolean;\n    preventTouch?: boolean;\n    supportPluginEvent?: boolean;\n    switchDragButton?: boolean;\n    mousemoveThrottleTime?: number;\n    maxFPS?: number;\n    debug?: boolean;\n    spatialReference?: SpatialReferenceType;\n    autoPanAtEdge?: boolean;\n    boxZoom?: boolean;\n    boxZoomSymbol?: {\n        'markerType': string;\n        'markerLineWidth': number;\n        'markerLineColor': string;\n        'markerLineDasharray': Array<number>;\n        'markerFillOpacity': number;\n        'markerFill': string;\n        'markerWidth': number;\n        'markerHeight': number;\n    };\n    onlyVisibleGeometryEvents?: boolean;\n    compassControl?: boolean;\n    layerSwitcherControl?: boolean;\n    navControl?: boolean;\n    resetControl?: boolean;\n};\nexport type MapCreateOptionsType = {\n    center: Array<number> | Coordinate;\n    zoom: number;\n} & MapOptionsType;\nexport type MapPaddingType = {\n    paddingLeft: number;\n    paddingRight: number;\n    paddingTop: number;\n    paddingBottom: number;\n};\nexport type MapViewType = {\n    center?: Array<number> | Coordinate;\n    zoom?: number;\n    pitch?: number;\n    bearing?: number;\n    height?: number;\n};\nexport type MapFitType = {\n    isFraction?: boolean;\n    animation?: boolean;\n    duration?: number;\n    easing?: EasingType;\n} & MapPaddingType;\nexport type MapDataURLType = {\n    mimeType?: string;\n    fileName?: string;\n    quality?: number;\n    save?: boolean;\n};\nexport type MapAnimationOptionsType = AnimationOptionsType;\nexport type MapIdentifyOptionsType = {\n    tolerance?: number;\n    eventTypes?: Array<string>;\n    layers?: Array<Layer>;\n    count?: number;\n    includeInvisible?: boolean;\n    includeInternals?: boolean;\n};\nexport type MapContainerType = string | HTMLDivElement | HTMLCanvasElement | {\n    [key: string]: any;\n};\nexport type PanelDom = (HTMLDivElement | HTMLElement) & {\n    layerDOM: HTMLElement;\n    uiDOM: HTMLElement;\n};\n"},{"path":"types/map/Map.DomEvents.d.ts","content":"import { Coordinate, Point } from '../geo';\ndeclare module \"./Map\" {\n    interface Map {\n        _removeDomEvents(): void;\n        _ignoreEvent(domEvent: MapEventDomType): boolean;\n        _isEventOutMap(domEvent: MapEventDomType): boolean;\n        _parseEvent(e: MapEventDomType, type?: string): MapEventDataType;\n        _parseEventFromCoord(coord: Coordinate): MapEventDataType;\n        _fireDOMEvent(target: any, e: MapEventDomType, type: string): any;\n        _getEventParams(e: MapEventDomType): MapEventDataType;\n    }\n}\nexport type MapEventDomType = MouseEvent | TouchEvent | DragEvent;\nexport type MapEventDataType = {\n    coordinate?: Coordinate;\n    containerPoint?: Point;\n    viewPoint?: Point;\n    point2d?: Point;\n    domEvent?: MouseEvent | DragEvent | TouchEvent;\n    terrain?: {\n        coordinate: Coordinate;\n        altitude: number;\n    } | null;\n};\n"},{"path":"types/map/Map.FullScreen.d.ts","content":"declare module \"./Map\" {\n    interface Map {\n        isFullScreen(): boolean;\n        requestFullScreen(dom?: HTMLDivElement): this;\n        cancelFullScreen(): this;\n        _requestFullScreen(dom: HTMLDivElement): void;\n        _cancelFullScreen(): void;\n    }\n}\nexport {};\n"},{"path":"types/map/Map.Pan.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\ndeclare module \"./Map\" {\n    interface Map {\n        panTo(coordinate: Coordinate, options?: MapAnimationOptionsType, step?: (frame: any) => void): this;\n        _panTo(prjCoord: Coordinate, options?: MapAnimationOptionsType): this;\n        panBy(offset: Point | Array<number>, options?: MapAnimationOptionsType, step?: (frame: any) => void): this;\n        _panAnimation(target: Coordinate, t?: number, cb?: (frame: any) => void): void;\n    }\n}\n"},{"path":"types/map/Map.Profile.d.ts","content":"/** Profile **/\n/**\n * Produce a geometry from one or more [JSON]{@link Geometry#toJSON} or GeoJSON.\n * @param  {Object} json - a geometry's JSON or a geojson\n * @return {Geometry} geometry\n * @example\n * var profile = {\n        \"feature\": {\n              \"type\": \"Feature\",\n              \"id\" : \"point1\",\n              \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.0, 0.5]},\n              \"properties\": {\"prop0\": \"value0\"}\n        },\n        //construct options.\n        \"options\":{\n            \"draggable\" : true\n        },\n        //symbol\n        \"symbol\":{\n            \"markerFile\"  : \"http://foo.com/icon.png\",\n            \"markerWidth\" : 20,\n            \"markerHeight\": 20\n        }\n    };\n    const marker = Geometry.fromJSON(profile);\n */\n"},{"path":"types/map/Map.Topo.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport { type Geometry } from '../geometry';\nimport { MapIdentifyOptionsType } from './Map';\ntype identifyOptionsType = MapIdentifyOptionsType & {\n    coordinate: Coordinate;\n};\ntype identifyAtPointOptionsType = MapIdentifyOptionsType & {\n    containerPoint: Point;\n};\ntype MapIdentifyCBType = (geos: Array<Geometry>) => void;\ndeclare module \"./Map\" {\n    interface Map {\n        computeLength(coord1: Coordinate, coord2: Coordinate): number;\n        computeGeometryLength(geometry: Geometry): number;\n        computeGeometryArea(geometry: Geometry): number;\n        identify(opts: identifyOptionsType, cb: MapIdentifyCBType): void;\n        identifyAtPoint(opts: identifyAtPointOptionsType, cb: MapIdentifyCBType): void;\n    }\n}\nexport {};\n"},{"path":"types/map/Map.ViewHistory.d.ts","content":"declare module \"./Map\" {\n    interface Map {\n        zoomToPreviousView(options?: any): MapViewType;\n        hasPreviousView(): boolean;\n        zoomToNextView(options?: any): MapViewType;\n        hasNextView(): boolean;\n        getViewHistory(): Array<MapViewType>;\n        _onViewChange(view: MapViewType): void;\n        _getCurrentView(): MapViewType;\n    }\n}\nexport {};\n"},{"path":"types/map/Map.Zoom.d.ts","content":"import Point from '../geo/Point';\ndeclare module \"./Map\" {\n    interface Map {\n        _zoom(nextZoom: number, origin?: Point): any;\n        _zoomAnimation(nextZoom: number, origin?: Point, startScale?: number): any;\n        _checkZoomOrigin(origin?: Point): Point;\n        _startZoomAnim(nextZoom: number, origin?: Point, startScale?: number): any;\n        onZoomStart(nextZoom: number, origin?: Point): any;\n        onZooming(nextZoom: number, origin?: Point, startScale?: number): any;\n        onZoomEnd(nextZoom: number, origin?: Point): any;\n        _zoomTo(nextZoom: number, origin?: Point): any;\n        _checkZoom(nextZoom: number): number;\n    }\n}\n"},{"path":"types/map/spatial-reference/SpatialReference.Arc.d.ts","content":"import { type SpatialReferenceType } from './SpatialReference';\nexport type ArcgisConfig = {\n    tileInfo: {\n        cols: number;\n        rows: number;\n        origin: {\n            x: number;\n            y: number;\n        };\n        lods: Array<{\n            resolution: number;\n        }>;\n    };\n    fullExtent: SpatialReferenceType['fullExtent'];\n};\n/**\n * 加载Arcgis空间参考配置文件\n * @param url arcgis spatialreference json file url\n * @param cb\n * @param options\n * @returns\n */\ndeclare const loadArcgis: (url: string, cb: (_: any, spatialRef?: any) => void, options?: any) => void;\nexport default loadArcgis;\n"},{"path":"types/map/spatial-reference/SpatialReference.d.ts","content":"import Extent, { JsonExtent } from '../../geo/Extent';\nimport * as projections from '../../geo/projection';\nimport type { ProjectionType } from '../../geo/projection';\nimport Transformation from '../../geo/transformation/Transformation';\nexport type FullExtent = {\n    top: number;\n    left: number;\n    bottom: number;\n    right: number;\n};\nexport type SpatialReferenceType = {\n    projection: string | ProjectionType;\n    resolutions?: number[];\n    fullExtent?: FullExtent | JsonExtent;\n};\n/**\n * 空间参考类\n *\n * @english\n * SpatialReference Class\n */\nexport default class SpatialReference {\n    options: SpatialReferenceType;\n    _projection: ProjectionType;\n    isEPSG: boolean;\n    _resolutions: number[];\n    _pyramid: boolean;\n    _fullExtent: Extent;\n    _transformation: Transformation;\n    json: SpatialReferenceType;\n    constructor(options?: SpatialReferenceType);\n    static registerPreset(name: string, value: SpatialReferenceType): void;\n    static getPreset(preset: string): SpatialReferenceType;\n    static getAllPresets(): string[];\n    static loadArcgis(url: string, cb: (_: any, spatialRef?: any) => void, options: any): typeof SpatialReference;\n    static loadWMTS(url: string, cb: (_: any, spatialRef?: any) => void, options: any): typeof SpatialReference;\n    /**\n     * 获取投影类实例对象\n     *\n     * @english\n     * get Projection Class instance\n     * @param projection\n     * @returns\n     */\n    static getProjectionInstance(projection?: string | ProjectionType): any;\n    static equals(sp1: SpatialReferenceType, sp2: SpatialReferenceType): boolean;\n    _initSpatialRef(): void;\n    getResolutions(): number[];\n    getResolution(zoom: number): number;\n    getProjection(): projections.ProjectionType;\n    getFullExtent(): Extent;\n    getTransformation(): Transformation;\n    getMinZoom(): number;\n    getMaxZoom(): number;\n    getZoomDirection(): number;\n    toJSON(): SpatialReferenceType;\n    isPyramid(): boolean;\n}\n"},{"path":"types/map/spatial-reference/SpatialReference.WMTS.d.ts","content":"export declare const loadWMTS: (url: string, cb: (_: any, layers?: any) => void, options?: {\n    jsonp: boolean;\n}) => void;\nexport default loadWMTS;\n"},{"path":"types/map/tool/AreaTool.d.ts","content":"import { Geometry } from '../../geometry';\nimport DistanceTool from './DistanceTool';\nexport type AreaToolOptions = {\n    language?: string;\n    metric?: boolean;\n    imperial?: boolean;\n    symbol?: any;\n    vertexSymbol?: any;\n    labelOptions?: any;\n    mode?: string;\n};\n/**\n * 一个继承于DistanceTool类，测量面积的地图工具类。\n *\n * @english\n * A map tool to help measure area on the map .it is extends DistanceTool\n * @category maptool\n * @extends DistanceTool\n * @example\n * var areaTool = new AreaTool({\n *     'once' : true,\n *     'symbol': {\n *       'lineColor' : '#34495e',\n *       'lineWidth' : 2\n *     },\n *     'vertexSymbol' : {\n *       'markerType'        : 'ellipse',\n *       'markerFill'        : '#1bbc9b',\n *       'markerLineColor'   : '#000',\n *       'markerLineWidth'   : 3,\n *       'markerWidth'       : 10,\n *      'markerHeight'      : 10\n *    },\n *    'language' : 'en-US'\n *  }).addTo(map);\n */\ndeclare class AreaTool extends DistanceTool {\n    /**\n     * 配置项\n     *\n     * @english\n     * @param options option              - construct options\n     * @param options.language=zh-CN      - language of the distance tool, zh-CN or en-US\n     * @param options.metric=true         - display result in metric system\n     * @param options.imperial=false      - display result in imperial system.\n     * @param options.symbol=null         - symbol of the line\n     * @param options.vertexSymbol=null   - symbol of the vertice\n     * @param options.labelOptions=null   - construct options of the vertice labels.\n     */\n    constructor(options: AreaToolOptions);\n    _measure(toMeasure: Geometry | Array<any>): string;\n    _msGetCoordsToMeasure(param: any): any;\n    _msOnDrawVertex(param: any): void;\n    _msOnDrawEnd(param: any): void;\n}\nexport default AreaTool;\n"},{"path":"types/map/tool/DistanceTool.d.ts","content":"import Marker from '../../geometry/Marker';\nimport Translator from '../../lang/translator';\nimport DrawTool from './DrawTool';\nimport Coordinate from '../../geo/Coordinate';\nexport type DistanceToolOptions = {\n    mode?: string;\n    language?: string;\n    metric?: boolean;\n    imperial?: boolean;\n    symbol?: any;\n    vertexSymbol?: any;\n    labelOptions?: any;\n    decimalPlaces?: number;\n    formatLabelContent?: any;\n    clearButtonSymbol?: any;\n    zIndex?: number;\n};\n/**\n * 距离测量工具类\n *\n * @english\n * A map tool to help measure distance on the map\n * @category maptool\n * @extends DrawTool\n * @example\n * var distanceTool = new DistanceTool({\n *     'once' : true,\n *     'symbol': {\n *       'lineColor' : '#34495e',\n *       'lineWidth' : 2\n *     },\n *     'vertexSymbol' : {\n *       'markerType'        : 'ellipse',\n *       'markerFill'        : '#1bbc9b',\n *       'markerLineColor'   : '#000',\n *       'markerLineWidth'   : 3,\n *       'markerWidth'       : 10,\n *      'markerHeight'      : 10\n *    },\n *    'language' : 'en-US'\n *  }).addTo(map);\n *\n */\ndeclare class DistanceTool extends DrawTool {\n    _measureLayers: Array<any>;\n    translator: Translator;\n    _tailMarker?: any;\n    _tailLabel?: any;\n    _lastMeasure?: number | string;\n    _lastVertex?: any;\n    _measureMarkerLayer?: any;\n    _measureLineLayer?: any;\n    /**\n     * 配置项\n     *\n     * @param options=null                  - construct options\n     * @param options.language=zh-CN        - language of the distance tool, zh-CN or en-US\n     * @param options.metric=true           - display result in metric system\n     * @param options.imperial=false        - display result in imperial system.\n     * @param options.symbol=null           - symbol of the line\n     * @param options.vertexSymbol=null     - symbol of the vertice\n     * @param options.labelOptions=null     - construct options of the vertice labels.\n     */\n    constructor(options: DistanceToolOptions);\n    /**\n     * 清空测量\n     *\n     * @english\n     * Clear the measurements\n     * @return {DistanceTool} this\n     */\n    clear(): this;\n    /**\n     * 获取在绘制图形期间的VectorLayers\n     *\n     * @english\n     * Get the VectorLayers with the geometries drawn on the map during measuring.\n     * @return {Array<Layer>}\n     */\n    getMeasureLayers(): any[];\n    /**\n     * 获取最后测量结果\n     *\n     * @english\n     * Get last measuring result\n     * @return {Number}\n     */\n    getLastMeasure(): string | number;\n    /**\n     * 撤消绘图，仅适用于点击/删除模式\n     *\n     * @english\n     * Undo drawing, only applicable for click/dblclick mode\n     * @return {DistanceTool} this\n     */\n    undo(): this;\n    /**\n     * 重做绘图，只适用于click/dblclick模式\n     *\n     * @english\n     * Redo drawing, only applicable for click/dblclick mode\n     * @return {DistanceTool} this\n     */\n    redo(): this;\n    _formatLabelContent(params: any): string;\n    _measure(toMeasure: any): string;\n    _registerMeasureEvents(): void;\n    _afterEnable(): void;\n    _afterDisable(): void;\n    _msOnDrawStart(param: any): void;\n    _msOnMouseMove(param: any): void;\n    _msGetCoordsToMeasure(param: any): any;\n    _msOnDrawVertex(param: any): void;\n    _addVertexMarker(marker: Marker, vertexLabel?: any): void;\n    _msOnDrawEnd(param: any): void;\n    _addClearMarker(coordinates: Coordinate, prjCoord: any, dx: number | string): void;\n    _clearTailMarker(): void;\n    _clearMeasureLayers(): void;\n    _getFirstCoordinate(): any;\n    _getLasttCoordinate(): any;\n}\nexport default DistanceTool;\n"},{"path":"types/map/tool/DrawTool.d.ts","content":"import Point from '../../geo/Point';\nimport Geometry from '../../geometry/Geometry';\nimport MapTool from './MapTool';\nexport type DrawToolOptions = {\n    mode?: string;\n    symbol?: any;\n    once?: boolean;\n    autoPanAtEdge?: boolean;\n    blockGeometryEvents?: boolean;\n    zIndex?: number;\n    doubleClickZoom?: boolean;\n    ignoreMouseleave?: boolean;\n    enableAltitude?: boolean;\n};\nexport type modeActionType = {\n    action?: string | Array<string>;\n    create?: any;\n    update?: any;\n    generate?: any;\n    clickLimit?: number | string;\n};\n/**\n * 图形绘制工具类\n *\n * @english\n * A map tool to help draw geometries.\n * @category maptool\n * @extends MapTool\n * @example\n * var drawTool = new DrawTool({\n *     mode : 'Polygon',\n *     symbol : {\n *         'lineColor' : '#000',\n *         'lineWidth' : 5\n *     },\n *     once : true\n * }).addTo(map);\n */\ndeclare class DrawTool extends MapTool {\n    _vertexes: Array<any>;\n    _historyPointer: any;\n    _events: any;\n    _geometry?: any;\n    _drawToolLayer?: any;\n    _mapAutoPanAtEdge?: boolean;\n    _geometryEvents?: boolean;\n    _mapDoubleClickZoom?: boolean;\n    _ending: boolean;\n    _mapDraggable?: boolean;\n    _clickCoords?: Array<any>;\n    _layers?: Array<any>;\n    /**\n     * 为DrawTool注册一个新mode\n     *\n     * @english\n     * Register a new mode for DrawTool\n     * @param name                  mode name\n     * @param modeAction            modeActions\n     * @param modeAction.action     the action of DrawTool: click, mousedown, clickDblclick\n     * @param modeAction.create     the create method of drawn geometry\n     * @param modeAction.update     the update method of drawn geometry\n     * @param modeAction.generate   the method to generate geometry at the end of drawing.\n     * @example\n     * //Register \"CubicBezierCurve\" mode to draw Cubic Bezier Curves.\n     * DrawTool.registerMode('CubicBezierCurve', {\n        'action': 'clickDblclick',\n        'create': path => new CubicBezierCurve(path),\n        'update': (path, geometry) => {\n            geometry.setCoordinates(path);\n        },\n        'generate': geometry => geometry\n       }\n     });\n     */\n    static registerMode(name: string, modeAction: modeActionType): void;\n    /**\n     * 根据name获取mode actions\n     *\n     * @english\n     * Get mode actions by mode name\n     * @param name      DrawTool mode name\n     * @return          mode actions\n     */\n    static getRegisterMode(name: string): any;\n    /**\n     * 实例化DrawTool工具\n     *\n     * @english\n     * In default, DrawTool supports the following modes: <br>\n     * [Point, LineString, Polygon, Circle, Ellipse, Rectangle, ArcCurve, QuadBezierCurve, CubicBezierCurve] <br>\n     * You can easily add new mode to DrawTool by calling [registerMode]{@link DrawTool.registerMode}\n     * @param options=null                  - construct options\n     * @param options.mode=null             - mode of the draw tool\n     * @param options.symbol=null           - symbol of the geometries drawn\n     * @param options.once=null             - whether disable immediately once drawn a geometry.\n     * @param options.autoPanAtEdge=false   - Whether to make edge judgement or not.\n     */\n    constructor(options: DrawToolOptions);\n    /**\n     * 获取当前mode\n     *\n     * @english\n     * Get current mode of draw tool\n     * @return mode\n     */\n    getMode(): string;\n    /**\n     * 设置mode\n     *\n     * @english\n     * Set mode of the draw tool\n     * @param mode - mode of the draw tool\n     * @returns {DrawTool} this\n     * @expose\n     */\n    setMode(mode: string): DrawTool;\n    /**\n     * 获取DrawTool的symbol属性\n     *\n     * @english\n     * Get symbol of the draw tool\n     * @return symbol\n     */\n    getSymbol(): any;\n    /**\n     * 设置DrawTool的symbol属性\n     *\n     * @english\n     * Set draw tool's symbol\n     * @param symbol - symbol set\n     * @returns {DrawTool} this\n     */\n    setSymbol(symbol: any): DrawTool;\n    /**\n     * 获取当前绘制图形\n     *\n     * @english\n     * Get geometry is currently drawing\n     * @return geometry currently drawing\n     */\n    getCurrentGeometry(): Geometry;\n    onAdd(): void;\n    onEnable(): this;\n    onDisable(): this;\n    /**\n     * 撤消绘图，仅适用于点击/删除模式\n     *\n     * @english\n     * Undo drawing, only applicable for click/dblclick mode\n     * @return this\n     */\n    undo(): DrawTool;\n    /**\n     * 重做绘图，只适用于click/dblclick模式\n     *\n     * @english\n     * Redo drawing, only applicable for click/dblclick mode\n     * @return this\n     */\n    redo(): DrawTool;\n    /**\n     * 检查历史记录\n     *\n     * @english\n     * check should recor history\n     * @param actions\n     * @returns {boolean}\n     * @private\n     */\n    _shouldRecordHistory(actions: any): boolean;\n    _checkMode(): void;\n    _saveMapCfg(): void;\n    _restoreMapCfg(): void;\n    _loadResources(): void;\n    _getProjection(): import(\"src/geo/projection\").ProjectionType;\n    _getRegisterMode(): any;\n    getEvents(): {};\n    /**\n     * 鼠标按下开始绘画\n     *\n     * @english\n     * mouse down start draw\n     * @param event\n     * @private\n     */\n    _mouseDownHandler(event: any): void;\n    /**\n     * 监听 mouse up 事件\n     *\n     * @english\n     * handle mouse up event\n     * @param event\n     * @private\n     */\n    _mouseUpHandler(event: any): void;\n    /**\n     * 监听mouse first click点击事件\n     *\n     * @english\n     * handle mouse first click handle\n     * @param event\n     * @private\n     */\n    _clickHandler(event: any): void;\n    /**\n     * 第一次事件创建相关geometry\n     *\n     * @param event\n     * @private\n     */\n    _createGeometry(event: any): void;\n    /**\n     * 监听鼠标移动\n     *\n     * @english\n     * handle mouse move event\n     * @param event\n     * @private\n     */\n    _mouseMoveHandler(event: any): void;\n    /**\n     * 监听double click事件\n     *\n     * @english\n     * handle mouse double click event\n     * @param event\n     * @private\n     */\n    _doubleClickHandler(event: any): void;\n    _addGeometryToStage(geometry: any): void;\n    /**\n     * 结束当前绘制\n     *\n     * @english\n     * End current draw\n     * @param [param=null] params of drawend event\n     * @returns this\n     */\n    endDraw(param: any): DrawTool;\n    _clearStage(): void;\n    /**\n     * 获取鼠标事件 ontainer point 信息\n     *\n     * @english\n     * Get container point of the mouse event\n     * @param event -  mouse event\n     * @return\n     * @private\n     */\n    _getMouseContainerPoint(event: Event): Point;\n    _isValidContainerPoint(containerPoint: any): boolean;\n    _getSnapResult(snapTo: any, containerPoint: any): {\n        prjCoord: any;\n        effectedVertex: any;\n    };\n    _getDrawLayer(): any;\n    _fireEvent(eventName: any, param: any): void;\n    _pushLayers(layers: any): this;\n    _outLayers(layers: any): this;\n    /**\n    * 设置Layer的zIndex\n    * @english\n    * set draw inner layers zIndex\n    * @param  {Number} zIndex -  draw layer zIndex\n    * @return this\n    */\n    setLayerZIndex(zIndex: any): DrawTool;\n}\nexport default DrawTool;\n"},{"path":"types/map/tool/DrawToolRegister.d.ts","content":"export {};\n"},{"path":"types/map/tool/index.d.ts","content":"import MapTool from './MapTool';\nimport DrawTool from './DrawTool';\nimport DistanceTool from './DistanceTool';\nimport AreaTool from './AreaTool';\nimport './DrawToolRegister';\nexport { MapTool, DrawTool, DistanceTool, AreaTool };\n"},{"path":"types/map/tool/MapTool.d.ts","content":"import Class from '../../core/Class';\nimport type Map from '../Map';\ndeclare const MapTool_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any;\n        once(eventTypes: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../../core/Eventable\").EventRecords, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../../core/Eventable\").EventRecords, context?: any): any;\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Class;\n/**\n * @classdesc\n * <pre>\n * The parent class for all the map tools.\n * It is abstract and not intended to be instantiated.\n * Some interface methods to implement:\n * 1. onAdd: optional, a callback method to do some prepares before enabled when the map tool is added to a map\n * 2. onEnable: optional, called when the map tool is enabled, used to setup the context such as adding more event listeners other than the map, disabling map's default handlers (draggable, scrollWheelZoom, etc) and creating temporary layers.\n * 3. getEvents: required, provide an event map to register event listeners on the map.\n * 4. onDisable: optional, called when the map tool is disabled, used to cleanup such as unregistering event listeners, enable map's original handlers and remove temporary layers.\n * </pre>\n * @abstract\n * @category maptool\n * @extends Class\n * @mixes Eventable\n */\ndeclare class MapTool extends MapTool_base {\n    _map: Map;\n    _enabled?: boolean;\n    onEnable?(): void;\n    getEvents?(): void;\n    onDisable?(): void;\n    onAdd?(): void;\n    /**\n     * Adds the map tool to a map.\n     * @param {Map} map\n     * @return {MapTool} this\n     * @fires MapTool#add\n     */\n    addTo(map: Map): this;\n    /**\n     * Gets the map it added to.\n     * @return {Map} map\n     */\n    getMap(): Map;\n    /**\n     * Enable the map tool.\n     * @return {MapTool} this\n     * @fires MapTool#enable\n     */\n    enable(): this;\n    /**\n     * Disable the map tool\n     * @return {MapTool} this\n     * @fires MapTool#disable\n     */\n    disable(): this;\n    /**\n     * Returns whether the tool is enabled\n     * @return {Boolean} true | false\n     */\n    isEnabled(): boolean;\n    remove(): this;\n    _registerEvents(): void;\n    _switchEvents(to: any): void;\n    _fireEvent(eventName: string, param?: any): void;\n}\nexport default MapTool;\n"},{"path":"types/maptalks.d.ts","content":""},{"path":"types/renderer/edit/EditHandle.d.ts","content":"import Point, { type PointJson } from '../../geo/Point';\nimport DragHandler from '../../handler/Drag';\nimport { BBOX } from '../../core/util/bbox';\nimport type Map from '../../map/Map';\nimport type GeometryEditor from '../../geometry/editor/GeometryEditor';\ntype EventParams = any;\nexport interface EditHandleOptions {\n    symbol: Record<string, any>;\n    events: string[];\n    cursor: string;\n    zIndex?: number;\n}\ndeclare const EditHandle_base: any;\nexport default class EditHandle extends EditHandle_base {\n    target: GeometryEditor;\n    map: Map;\n    w: number;\n    h: number;\n    opacity: number;\n    events: string[];\n    url: string;\n    bbox: BBOX;\n    _point: Point;\n    _img: any;\n    _dragger: DragHandler;\n    constructor(target: GeometryEditor, map: Map, options: EditHandleOptions);\n    getCursor(): any;\n    _fetchImage(): void;\n    setContainerPoint(cp: Point): void;\n    getContainerPoint(): Point;\n    offset(p: Point | PointJson): void;\n    render(ctx: any): boolean;\n    delete(): void;\n    hitTest(p: Point | PointJson): boolean;\n    addTo(map: Map): void;\n    onEvent(e: EventParams): void;\n    mousedown(e: EventParams): void;\n    onDragstart(e: EventParams): void;\n    onDragging(e: EventParams): void;\n    onDragend(e: EventParams): void;\n    needCollision(): boolean;\n    getRenderBBOX(dpr?: number): BBOX;\n    setZIndex(zIndex: number): void;\n}\nexport {};\n"},{"path":"types/renderer/edit/EditOutline.d.ts","content":"import type Map from '../../map/Map';\nimport type GeometryEditor from '../../geometry/editor/GeometryEditor';\nimport type { Point } from '../../geo';\nimport type { BBOX } from '../../core/util/bbox';\nexport interface EditOutlineOptions {\n    zIndex?: number;\n}\nexport default class EditOutline {\n    points: any;\n    xmin: number;\n    xmax: number;\n    ymin: number;\n    ymax: number;\n    map: Map;\n    target: GeometryEditor;\n    options: EditOutlineOptions;\n    constructor(target: GeometryEditor, map: Map, options?: EditOutlineOptions);\n    needCollision?(): boolean;\n    getRenderBBOX?(dpr?: number): BBOX;\n    setPoints(points: Point[]): void;\n    hitTest(): boolean;\n    render(ctx: CanvasRenderingContext2D): void;\n    addTo(map: Map): void;\n    delete(): void;\n}\n"},{"path":"types/renderer/geometry/CollectionPainter.d.ts","content":"import Class from '../../core/Class';\nimport { BBOX } from '../../core/util/bbox';\nimport Painter from './Painter';\nimport Extent from '../../geo/Extent';\nimport { ResourceCache } from '../layer/CanvasRenderer';\nimport { Geometries } from '../../geometry';\n/**\n * @classdesc\n * Painter for collection type geometries\n * @class\n * @private\n */\nexport default class CollectionPainter extends Class {\n    _drawTime: number;\n    bbox: BBOX;\n    geometry: Geometries;\n    isMask: boolean;\n    /**\n     * @param geometry - geometry to paint\n     * @param isMask\n     */\n    constructor(geometry: Geometries, isMask?: boolean);\n    _setDrawTime(time: number): this;\n    getRenderBBOX(): BBOX;\n    _eachPainter(fn: (p: Painter) => void): void;\n    getLayer(): import(\"src\").OverlayLayer;\n    paint(extent: Extent): void;\n    get2DExtent(resources?: ResourceCache, out?: Extent): Extent;\n    remove(): void;\n    setZIndex(index: number): void;\n    show(): void;\n    hide(): void;\n    repaint(): void;\n    refreshSymbol(): void;\n    hasPoint(): boolean;\n    getMinAltitude(): number;\n    getMaxAltitude(): number;\n}\n"},{"path":"types/renderer/geometry/index.d.ts","content":"import Painter from './Painter';\nimport CollectionPainter from './CollectionPainter';\nimport './PointRenderer';\nimport './VectorRenderer';\nexport { Painter, CollectionPainter };\n"},{"path":"types/renderer/geometry/Painter.d.ts","content":"import Class from '../../core/Class';\nimport Point from '../../geo/Point';\nimport PointExtent from '../../geo/PointExtent';\nimport { BBOX } from '../../core/util/bbox';\nimport Map from '../../map/Map';\nimport { DebugSymbolizer } from './symbolizers';\nimport Extent from '../../geo/Extent';\nimport { ResourceCache } from '../layer/CanvasRenderer';\nimport type { WithUndef } from '../../types/typings';\nimport { Geometries } from '../../geometry';\ndeclare const TEMP_BBOX: {\n    minx: number;\n    miny: number;\n    maxx: number;\n    maxy: number;\n};\n/**\n * @classdesc\n * Painter class for all geometry types except the collection types.\n * @class\n * @private\n */\ndeclare class Painter extends Class {\n    _drawTime: number;\n    _hasPoint: boolean;\n    _debugSymbolizer: DebugSymbolizer;\n    _renderPoints: Record<string, Point[][]>;\n    _hitPoint: WithUndef<Point>;\n    _sprite: any;\n    _paintParams: any;\n    _cachedParams: any;\n    _unsimpledParams: any;\n    _spriting: boolean;\n    _extent2D: Extent & {\n        _zoom: number;\n    };\n    _fixedExtent: PointExtent;\n    _altAtGL: any;\n    _propAlt: number | number[] | number[][];\n    _projCode: string;\n    _pitched: boolean;\n    _rotated: boolean;\n    _painted: boolean;\n    _containerBbox: typeof TEMP_BBOX;\n    bbox: BBOX;\n    geometry: Geometries;\n    symbolizers: any[];\n    containerOffset: Point;\n    minAltitude: number;\n    maxAltitude: number;\n    /**\n     *  @param geometry - geometry to paint\n     */\n    constructor(geometry: Geometries);\n    _setDrawTime(time: number): this;\n    getRenderBBOX(): BBOX;\n    getMap(): Map;\n    getLayer(): import(\"src\").OverlayLayer;\n    /**\n     * create symbolizers\n     */\n    _createSymbolizers(): any[];\n    hasPoint(): boolean;\n    /**\n     * for point symbolizers\n     * @return points to render\n     */\n    getRenderPoints(placement: string): Point[][];\n    /**\n     * for strokeAndFillSymbolizer\n     * @return resources to render vector\n     */\n    getPaintParams(dx: number, dy: number, ignoreAltitude: boolean, disableClip: boolean, ptkey?: string): any[];\n    _pointContainerPoints(points: any, dx: any, dy: any, ignoreAltitude: any, disableClip: any, pointPlacement: any, ptkey?: string): any;\n    _clip(points: Point[], altitude?: number): {\n        points: any;\n        altitude: any;\n    } | {\n        points: Point[];\n        altitude: number;\n        inView: boolean;\n    };\n    /**\n     * interpolate clipped line segs's altitude\n     * @param {Point[]|Point[][]} clipSegs\n     * @param {Point[]|Point[][]} orig\n     * @param {Number|Number[]} altitude\n     * @private\n     */\n    _interpolateSegAlt(clipSegs: any, orig: any, altitude: any): {\n        points: any;\n        altitude: any;\n    };\n    getSymbol(): any;\n    _resetSymbolizersBBOX(): this;\n    paint(extent?: Extent, context?: any, offset?: Point): void;\n    getSprite(resources: any, canvasClass: any): any;\n    isSpriting(): boolean;\n    hitTest(cp: any, tolerance: any): boolean;\n    isHitTesting(): boolean;\n    _prepareShadow(ctx: CanvasRenderingContext2D, symbol: Record<string, any>): void;\n    _eachSymbolizer(fn: any, context?: any): void;\n    get2DExtent(resources?: ResourceCache, out?: Extent): Extent;\n    _computeExtent2D(extent: any): any;\n    _computeFixedExtent(resources: any, extent: any): any;\n    _isDynamicSize(): boolean;\n    _aboveCamera(): boolean;\n    getFixedExtent(): any;\n    setZIndex(change: number): void;\n    show(): void;\n    hide(): void;\n    repaint(): void;\n    /**\n     * refresh symbolizers when symbol changed\n     */\n    refreshSymbol(): void;\n    remove(): void;\n    _removeSymbolizers(): void;\n    /**\n     * delete painter's caches\n     */\n    removeCache(): void;\n    getAltitude(): any;\n    getMinAltitude(): number;\n    getMaxAltitude(): number;\n    _getGeometryAltitude(): number | number[] | number[][];\n    _verifyProjection(): void;\n    _beforePaint(): void;\n    _afterPaint(): void;\n}\nexport default Painter;\n"},{"path":"types/renderer/geometry/PointRenderer.d.ts","content":"import Point from '../../geo/Point';\nimport { WithNull } from \"../../types/typings\";\ndeclare const CenterPointRenderer: {\n    _getRenderPoints(): [Point[], Point[]];\n};\nexport type CenterPointRendererType = typeof CenterPointRenderer;\ndeclare module '../../geometry/Marker' {\n    interface Marker extends CenterPointRendererType {\n    }\n}\ndeclare module '../../geometry/LineString' {\n    interface LineString {\n        _getRenderPoints(placement?: string): [Point[], WithNull<Point[]>];\n    }\n}\ndeclare module '../../geometry/Polygon' {\n    interface Polygon {\n        _getRenderPoints(placement?: string): [Point[], WithNull<Point[]>];\n    }\n}\nexport {};\n"},{"path":"types/renderer/geometry/symbolizers/CanvasSymbolizer.d.ts","content":"import Symbolizer from './Symbolizer';\nimport { ResourceCache } from '../../layer/CanvasRenderer';\n/**\n *所有基于 HTML5 Canvas2D 的symbolizer类\n *\n * @english\n * @classdesc\n * Base symbolizer class for all the symbolizers base on HTML5 Canvas2D\n * @abstract\n * @class\n * @private\n * @memberOf symbolizer\n * @name CanvasSymbolizer\n * @extends {Symbolizer}\n */\ndeclare abstract class CanvasSymbolizer extends Symbolizer {\n    symbol: any;\n    _opacityFn: any;\n    _prepareContext(ctx: CanvasRenderingContext2D): void;\n    prepareCanvas(ctx: CanvasRenderingContext2D, style: any, resources?: ResourceCache): void;\n    remove(): void;\n    setZIndex(): void;\n    show(): void;\n    hide(): void;\n    _defineStyle(style: any): any;\n}\nexport default CanvasSymbolizer;\n"},{"path":"types/renderer/geometry/symbolizers/DebugSymbolizer.d.ts","content":"import Point from '../../../geo/Point';\nimport PointSymbolizer from './PointSymbolizer';\nexport default class DebugSymbolizer extends PointSymbolizer {\n    getPlacement(): string;\n    getDxDy(): Point;\n    symbolize(ctx: CanvasRenderingContext2D): void;\n}\n"},{"path":"types/renderer/geometry/symbolizers/DrawAltitudeSymbolizer.d.ts","content":"import Point from '../../../geo/Point';\nimport PointSymbolizer from './PointSymbolizer';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport { PointExtent } from '../../../geo';\nexport default class DrawAltitudeSymbolizer extends PointSymbolizer {\n    dxdy: any;\n    static test(symbol: any, geometry: Geometry): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D): void;\n    getDxDy(): Point;\n    get2DExtent(): PointExtent;\n    getPlacement(): string;\n    _getPaintParams(dx: any, dy: any): any[];\n    _drawMarkerAltitude(ctx: CanvasRenderingContext2D, point: Point, groundPoint: Point): void;\n    _drawLineAltitude(ctx: CanvasRenderingContext2D, points: any[], groundPoints: any[]): void;\n    _drawLine(ctx: CanvasRenderingContext2D, points: any[], groundPoints: any[]): void;\n    _getStyle(): any;\n}\n"},{"path":"types/renderer/geometry/symbolizers/ImageMarkerSymbolizer.d.ts","content":"import PointExtent from '../../../geo/PointExtent';\nimport PointSymbolizer from './PointSymbolizer';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport { ResourceCache } from '../../layer/CanvasRenderer';\nexport default class ImageMarkerSymbolizer extends PointSymbolizer {\n    _url: [string, string | number, string | number];\n    _fixedExtent: PointExtent;\n    static test(symbol: any): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D, resources: ResourceCache): void;\n    _getImage(resources: ResourceCache): any;\n    getFixedExtent(resources: ResourceCache): PointExtent;\n    translate(): any;\n}\n"},{"path":"types/renderer/geometry/symbolizers/index.d.ts","content":"import Symbolizer from './Symbolizer';\nimport CanvasSymbolizer from './CanvasSymbolizer';\nimport DebugSymbolizer from './DebugSymbolizer';\nimport ImageMarkerSymbolizer from './ImageMarkerSymbolizer';\nimport PointSymbolizer from './PointSymbolizer';\nimport StrokeAndFillSymbolizer from './StrokeAndFillSymbolizer';\nimport TextMarkerSymbolizer from './TextMarkerSymbolizer';\nimport VectorMarkerSymbolizer from './VectorMarkerSymbolizer';\nimport VectorPathMarkerSymbolizer from './VectorPathMarkerSymbolizer';\nimport DrawAltitudeSymbolizer from './DrawAltitudeSymbolizer';\nexport { Symbolizer, CanvasSymbolizer, DebugSymbolizer, ImageMarkerSymbolizer, PointSymbolizer, StrokeAndFillSymbolizer, TextMarkerSymbolizer, VectorMarkerSymbolizer, VectorPathMarkerSymbolizer, DrawAltitudeSymbolizer };\n"},{"path":"types/renderer/geometry/symbolizers/PointSymbolizer.d.ts","content":"import PointExtent from '../../../geo/PointExtent';\nimport Point from '../../../geo/Point';\nimport CanvasSymbolizer from './CanvasSymbolizer';\nimport Painter from '../Painter';\nimport { Geometry } from '../../../geometry';\n/**\n * 所有点类型符号样式的symbolizer基类\n *\n * @english\n * @classdesc\n * Base symbolizer class for all the point type symbol styles.\n * @abstract\n * @class\n * @private\n * @memberOf symbolizer\n * @name PointSymbolizer\n * @extends {symbolizer.CanvasSymbolizer}\n */\ndeclare abstract class PointSymbolizer extends CanvasSymbolizer {\n    style: any;\n    symbol: any;\n    geometry: Geometry;\n    painter: Painter;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    get2DExtent(): PointExtent;\n    isDynamicSize(): boolean;\n    _rotateExtent(fixedExtent: PointExtent, angle: number): PointExtent;\n    _getRenderPoints(): Point[][];\n    /**\n     * 获取容器内的点用于绘制\n     *\n     * @english\n     * Get container points to draw on Canvas\n     */\n    _getRenderContainerPoints(ignoreAltitude?: boolean): Point[];\n    getPlacement(): any;\n    getRotation(): number;\n    getDxDy(): Point;\n    _getRotationAt(i: number): number;\n    _rotate(ctx: CanvasRenderingContext2D, origin: Point, rotation: number): Point | null;\n}\nexport default PointSymbolizer;\n"},{"path":"types/renderer/geometry/symbolizers/StrokeAndFillSymbolizer.d.ts","content":"import { ResourceCache } from '../..';\nimport Coordinate from '../../../geo/Coordinate';\nimport PointExtent from '../../../geo/PointExtent';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport CanvasSymbolizer from './CanvasSymbolizer';\nexport default class StrokeAndFillSymbolizer extends CanvasSymbolizer {\n    _extMin: Coordinate;\n    _extMax: Coordinate;\n    _pxExtent: PointExtent;\n    static test(symbol: any, geometry: Geometry): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D, resources: ResourceCache): void;\n    get2DExtent(): PointExtent;\n    getFixedExtent(): PointExtent;\n    _getPaintParams(): any[];\n    translate(): any;\n    _createGradient(ctx: CanvasRenderingContext2D, points: any[], lineColor: any): void;\n}\n"},{"path":"types/renderer/geometry/symbolizers/Symbolizer.d.ts","content":"import { BBOX } from \"../../../core/util/bbox\";\nimport { Geometry } from \"../../../geometry\";\nimport { Map } from \"../../../map\";\nimport Painter from \"../Painter\";\n/**\n * symbolilzers的基础类,所有的symbolilzers都继承于此\n * 抽象类,不可实例化\n *\n * @english\n * @classdesc\n * Base class for all the symbolilzers\n * @class\n * @extends Class\n * @abstract\n * @private\n */\ndeclare abstract class Symbolizer {\n    bbox: BBOX;\n    geometry: Geometry;\n    painter: Painter;\n    style: any;\n    constructor();\n    _setBBOX(ctx: CanvasRenderingContext2D, x1?: number | BBOX, y1?: number, x2?: number, y2?: number): Symbolizer;\n    _bufferBBOX(ctx: CanvasRenderingContext2D, bufferSize: number): Symbolizer;\n    getMap(): Map;\n    getPainter(): Painter;\n    isDynamicSize(): boolean;\n    isVisible(): boolean;\n    /**\n     * 测试该属性是否是与着色相关的属性\n     *\n     * @english\n     * Test if the property is a property related with coloring\n     * @param  prop - property name to test\n     * @static\n     * @function\n     * @memberof symbolizer.Symbolizer\n     */\n    static testColor(prop: string): boolean;\n}\nexport default Symbolizer;\n"},{"path":"types/renderer/geometry/symbolizers/TextMarkerSymbolizer.d.ts","content":"import Point from '../../../geo/Point';\nimport PointExtent from '../../../geo/PointExtent';\nimport PointSymbolizer from './PointSymbolizer';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport { ResourceCache } from '../..';\nexport default class TextMarkerSymbolizer extends PointSymbolizer {\n    _dynamic: any;\n    strokeAndFill: any;\n    _textDesc: any;\n    _fixedExtent: PointExtent;\n    _index: number;\n    static test(symbol: any): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D, resources: ResourceCache): void;\n    getPlacement(): any;\n    getRotation(): number;\n    getDxDy(): Point;\n    getFixedExtent(): PointExtent;\n    translate(): any;\n    translateLineAndFill(s: any): any;\n}\n"},{"path":"types/renderer/geometry/symbolizers/VectorMarkerSymbolizer.d.ts","content":"import Point from '../../../geo/Point';\nimport PointExtent from '../../../geo/PointExtent';\nimport PointSymbolizer from './PointSymbolizer';\nimport { Geometry } from '../../../geometry';\nimport Painter from '../Painter';\nimport { Extent } from '../../../geo';\nimport { ResourceCache } from '../../layer/CanvasRenderer';\nexport default class VectorMarkerSymbolizer extends PointSymbolizer {\n    _dynamic: any;\n    strokeAndFill: any;\n    padding: number;\n    _stamp: any;\n    _fixedExtent: PointExtent;\n    static test(symbol: any): boolean;\n    constructor(symbol: any, geometry: Geometry, painter: Painter);\n    symbolize(ctx: CanvasRenderingContext2D, resources: ResourceCache): void;\n    _drawMarkers(ctx: CanvasRenderingContext2D, cookedPoints: any[], resources: ResourceCache): void;\n    _drawMarkersWithCache(ctx: CanvasRenderingContext2D, cookedPoints: any[], resources: ResourceCache): void;\n    _createMarkerImage(ctx: CanvasRenderingContext2D, resources: ResourceCache): any;\n    _stampSymbol(): any;\n    _getCacheImageAnchor(w: number, h: number): Point;\n    _getGraidentExtent(points: PointExtent | Extent): PointExtent;\n    _drawVectorMarker(ctx: CanvasRenderingContext2D, point: Point, resources: ResourceCache): void;\n    getFixedExtent(): PointExtent;\n    translate(): any;\n}\n"},{"path":"types/renderer/geometry/symbolizers/VectorPathMarkerSymbolizer.d.ts","content":"import ImageMarkerSymbolizer from './ImageMarkerSymbolizer';\nimport { ResourceCache } from '../../layer/CanvasRenderer';\nexport default class VectorPathMarkerSymbolizer extends ImageMarkerSymbolizer {\n    _url: any;\n    static test(symbol: any): boolean;\n    constructor(symbol: any, geometry: any, painter: any);\n    _prepareContext(): void;\n    _getImage(resources: ResourceCache): any;\n}\n"},{"path":"types/renderer/geometry/VectorRenderer.d.ts","content":"import Point from '../../geo/Point';\nimport { BBOX } from '../../core/util/bbox';\nimport Extent from '../../geo/Extent';\nimport Coordinate from '../../geo/Coordinate';\nimport { WithNull } from '../../types/typings';\ndeclare const geometryInclude: {\n    _redrawWhenPitch: () => boolean;\n    _redrawWhenRotate: () => boolean;\n    _getRenderBBOX(ctx: CanvasRenderingContext2D, points: Point[]): BBOX;\n};\nexport type GeometryIncludeType = typeof geometryInclude;\ndeclare module '../../geometry/Geometry' {\n    interface Geometry extends GeometryIncludeType {\n    }\n}\ndeclare function _computeRotatedPrjExtent(): Extent;\ndeclare function getRotatedShell(): Coordinate[];\ndeclare const el: {\n    _redrawWhenPitch: () => boolean;\n    _redrawWhenRotate: () => boolean;\n    _computeRotatedPrjExtent: typeof _computeRotatedPrjExtent;\n    getRotatedShell: typeof getRotatedShell;\n    _paintAsPath: () => boolean;\n    _getPaintParams(): any[];\n    _paintOn: (...args: any[]) => void;\n    _getRenderSize(pt: Coordinate): number[];\n};\nexport type ElType = typeof el;\ndeclare module '../../geometry/Ellipse' {\n    interface Ellipse extends Omit<ElType, '_paintOn' | '_getPaintParams'> {\n    }\n}\ndeclare module '../../geometry/Circle' {\n    interface Circle extends Omit<ElType, '_paintOn' | '_getPaintParams'> {\n    }\n}\ndeclare const rectangleInclude: {\n    _getPaintParams(): any[];\n    _paintOn: (ctx: any, points: any, lineOpacity: any, fillOpacity: any, lineDashArray?: any, smoothness?: any) => void;\n    _computeRotatedPrjExtent: typeof _computeRotatedPrjExtent;\n    getRotatedShell: typeof getRotatedShell;\n};\nexport type RectangleIncludeType = typeof rectangleInclude;\ndeclare module '../../geometry/Rectangle' {\n    interface Rectangle extends Omit<RectangleIncludeType, '_paintOn' | '_getPaintParams'> {\n    }\n}\ndeclare const sectorInclude: {\n    _redrawWhenPitch: () => boolean;\n    _getPaintParams(): [Point, number, [number, number]];\n    _paintOn: (...args: any[]) => void;\n};\nexport type SectorIncludeType = typeof sectorInclude;\ndeclare module '../../geometry/Sector' {\n    interface Sector extends Omit<SectorIncludeType, '_paintOn' | '_getPaintParams'> {\n    }\n}\ndeclare module '../../geometry/Path' {\n    interface Path {\n        _paintAsPath: () => boolean;\n    }\n}\ndeclare const lineStringInclude: {\n    arrowStyles: {\n        classic: number[];\n    };\n    _getArrowShape(prePoint?: Point, point?: any, lineWidth?: number, arrowStyle?: any, tolerance?: number): any[];\n    _getPaintParams(): [Point[]];\n    _paintOn(ctx: CanvasRenderingContext2D, points: Point[], lineOpacity?: number, fillOpacity?: number, dasharray?: number[]): any;\n    _getArrowPlacement(): any;\n    _getArrowStyle(): any;\n    _getArrows(points: any, lineWidth: number, tolerance?: number): any[];\n    _getArrowPoints(arrows: any[], segments: any[], lineWidth?: number, arrowStyle?: any, tolerance?: number): void;\n    _paintArrow(ctx: CanvasRenderingContext2D, points: Point[], lineOpacity?: number): void;\n};\nexport type LineStringIncludeType = typeof lineStringInclude;\ndeclare module '../../geometry/LineString' {\n    interface LineString extends LineStringIncludeType {\n    }\n}\ndeclare module '../../geometry/Polygon' {\n    interface Polygon {\n        _paintOn(ctx: CanvasRenderingContext2D, points: Point[], lineOpacity?: number, fillOpacity?: number, dasharray?: number[]): WithNull<BBOX>;\n    }\n}\nexport {};\n"},{"path":"types/renderer/index.d.ts","content":"/** @namespace renderer */\nexport { ResourceCache } from './layer/CanvasRenderer';\nexport { default as CanvasRenderer } from './layer/CanvasRenderer';\nexport { default as ImageGLRenderable } from './layer/ImageGLRenderable';\nexport * from './layer/tilelayer';\nexport * from './layer/vectorlayer';\nexport * from './layer/canvaslayer';\nexport { default as MapRenderer } from './map/MapRenderer';\nexport { default as MapCanvasRenderer } from './map/MapCanvasRenderer';\nexport { default as Renderable } from './Renderable';\nexport { ImageLayerCanvasRenderer, ImageLayerGLRenderer } from '../layer/ImageLayer';\n"},{"path":"types/renderer/layer/canvaslayer/CanvasLayerRenderer.d.ts","content":"import CanvasRenderer from '../../../renderer/layer/CanvasRenderer';\nexport default class CanvasLayerRenderer extends CanvasRenderer {\n    buffer: HTMLCanvasElement;\n    _drawContext: any[];\n    _predrawed: boolean;\n    _shouldClear: boolean;\n    getPrepareParams(): any[];\n    getDrawParams(): any[];\n    onCanvasCreate(): void;\n    needToRedraw(): boolean;\n    draw(...args: any[]): void;\n    drawOnInteracting(...args: any[]): void;\n    getCanvasImage(): any;\n    remove(): void;\n    onZoomStart(param: any): void;\n    onZooming(param: any): void;\n    onZoomEnd(param: any): void;\n    onMoveStart(param: any): void;\n    onMoving(param: any): void;\n    onMoveEnd(param: any): void;\n    onResize(param: any): void;\n    prepareDrawContext(): void;\n    _prepareDrawParams(): any[];\n    _drawLayer(...args: any[]): void;\n    _drawLayerOnInteracting(...args: any[]): void;\n}\n"},{"path":"types/renderer/layer/canvaslayer/index.d.ts","content":"export { default as CanvasLayerRenderer } from './CanvasLayerRenderer';\n"},{"path":"types/renderer/layer/CanvasRenderer.d.ts","content":"import Class from '../../core/Class';\nimport Actor from '../../core/worker/Actor';\nimport Point from '../../geo/Point';\nimport Extent from '../../geo/Extent';\nimport { SizeLike } from '../../geo/Size';\nimport { TileRenderingCanvas, TileRenderingContext, ImageType } from '../types';\ndeclare class ResourceWorkerConnection extends Actor {\n    constructor();\n    fetchImage(url: string, cb: Function): void;\n}\n/**\n * 在 HTMLCanvasElement 上渲染图层的基类\n * @english\n * Base Class to render layer on HTMLCanvasElement\n * @abstract\n * @protected\n * @memberOf renderer\n * @extends Class\n */\ndeclare class CanvasRenderer extends Class {\n    layer: any;\n    resources: ResourceCache;\n    context: CanvasRenderingContext2D;\n    canvas: TileRenderingCanvas;\n    gl: TileRenderingContext;\n    middleWest: Point;\n    canvasExtent2D: Extent;\n    _extent2D: Extent;\n    _maskExtent: Extent;\n    _painted: boolean;\n    _drawTime: number;\n    _frameTime: number;\n    _resWorkerConn: ResourceWorkerConnection;\n    _toRedraw: boolean;\n    _loadingResource: boolean;\n    _renderComplete: boolean;\n    _canvasUpdated: boolean;\n    _renderZoom: number;\n    _errorThrown: boolean;\n    __zoomTransformMatrix: number[];\n    drawOnInteracting?(...args: any[]): void;\n    checkResources?(): any[];\n    getImageData?(): ImageData;\n    draw?(...args: any[]): void;\n    /**\n     * @param  {Layer} layer the layer to render\n     */\n    constructor(layer: any);\n    /**\n     * Render the layer.\n     * Call checkResources\n     */\n    render(framestamp?: number): void;\n    getFrameTimestamp(): number;\n    checkAndDraw(drawFn: any, ...args: any[]): void;\n    /**\n     * Check if has any external resources to load\n     * If yes, load the resources before calling draw method\n     * @abstract\n     * @method checkResources\n     * @instance\n     * @returns {Array[]} an array of resource arrays [ [url1, width, height], [url2, width, height], [url3, width, height] .. ]\n     * @memberOf renderer.CanvasRenderer\n     */\n    /**\n     * a required abstract method to implement\n     * draw the layer when map is not interacting\n     * @abstract\n     * @instance\n     * @method draw\n     * @memberOf renderer.CanvasRenderer\n     */\n    /**\n     * an optional abstract method to implement\n     * draw the layer when map is interacting (moving/zooming/dragrotating)\n     * @abstract\n     * @instance\n     * @method drawOnInteracting\n     * @param {Object} eventParam event parameters\n     * @memberOf renderer.CanvasRenderer\n     */\n    /**\n     * @private\n     */\n    testIfNeedRedraw(): boolean;\n    /**\n     * Ask whether the layer renderer needs to redraw\n     */\n    needToRedraw(): boolean;\n    /**\n     * A callback for overriding when drawOnInteracting is skipped due to low fps\n     */\n    onSkipDrawOnInteracting(): void;\n    isLoadingResource(): boolean;\n    isRenderComplete(): boolean;\n    /**\n     * Whether must call render instead of drawOnInteracting when map is interacting\n     */\n    mustRenderOnInteracting(): boolean;\n    /**\n     * Set to redraw, ask map to call draw/drawOnInteracting to redraw the layer\n     */\n    setToRedraw(): this;\n    /**\n     *  Mark layer's canvas updated\n     */\n    setCanvasUpdated(): this;\n    /**\n     * Only called by map's renderer to check whether the layer's canvas is updated\n     * @protected\n     * @return {Boolean}\n     */\n    isCanvasUpdated(): boolean;\n    /**\n     * Remove the renderer, will be called when layer is removed\n     */\n    remove(): void;\n    onRemove(): void;\n    onAdd(): void;\n    /**\n     * Get map\n     */\n    getMap(): any;\n    /**\n     * Get renderer's Canvas image object\n     */\n    getCanvasImage(): any;\n    /**\n     * Clear canvas\n     */\n    clear(): void;\n    /**\n     * A method to help improve performance.\n     * If you are sure that layer's canvas is blank, returns true to save unnecessary layer works of maps.\n     */\n    isBlank(): boolean;\n    /**\n     * Show the layer\n     */\n    show(): void;\n    /**\n     * Hide the layer\n     */\n    hide(): void;\n    /**\n     * Set z-index of layer\n     */\n    setZIndex(_z?: number): void;\n    /**\n     * Detect if there is anything painted on the given point\n     * @param point containerPoint\n     */\n    hitDetect(point: Point): boolean;\n    /**\n     * loadResource from resourceUrls\n     * @param  {String[]} resourceUrls    - Array of urls to load\n     * @returns {Promise[]}\n     */\n    loadResources(resourceUrls: string[][]): Promise<any>;\n    /**\n     * Prepare rendering\n     * Set necessary properties, like this._renderZoom/ this.canvasExtent2D, this.middleWest\n     * @private\n     */\n    prepareRender(): void;\n    /**\n     * Create renderer's Canvas\n     */\n    createCanvas(): void;\n    onCanvasCreate(): void;\n    createContext(): void;\n    resetCanvasTransform(): void;\n    /**\n     * Resize the canvas\n     * @param canvasSize the size resizing to\n     */\n    resizeCanvas(canvasSize?: SizeLike): void;\n    /**\n     * Clear the canvas to blank\n     */\n    clearCanvas(): void;\n    /**\n     * @english\n     * Prepare the canvas for rendering. <br>\n     * 1. Clear the canvas to blank. <br>\n     * 2. Clip the canvas by mask if there is any and return the mask's extent\n     * @return {PointExtent} mask's extent of current zoom's 2d point.\n     */\n    prepareCanvas(): any;\n    clipCanvas(context: CanvasRenderingContext2D & {\n        isMultiClip: boolean;\n        isClip: boolean;\n    }): boolean;\n    /**\n     * Get renderer's current view extent in 2d point\n     * @return {Object} view.extent, view.maskExtent, view.zoom, view.middleWest\n     */\n    getViewExtent(): {\n        extent: Extent;\n        maskExtent: Extent;\n        zoom: number;\n        middleWest: Point;\n    };\n    /**\n     * call when rendering completes, this will fire necessary events and call setCanvasUpdated\n     */\n    completeRender(): void;\n    /**\n     * Get renderer's event map registered on the map\n     * @return {Object} events\n     */\n    getEvents(): {\n        _zoomstart: (param: any) => void;\n        _zooming: (param: any) => void;\n        _zoomend: (param: any) => void;\n        _resize: (param: any) => void;\n        _movestart: (param: any) => void;\n        _moving: (param: any) => void;\n        _moveend: (param: any) => void;\n        _dragrotatestart: (param: any) => void;\n        _dragrotating: (param: any) => void;\n        _dragrotateend: (param: any) => void;\n        _spatialreferencechange: (param: any) => void;\n    };\n    /**\n     * onZoomStart\n     * @param  {Object} param event parameters\n     */\n    onZoomStart(param: any): void;\n    /**\n    * onZoomEnd\n    * @param  {Object} param event parameters\n    */\n    onZoomEnd(param: any): void;\n    /**\n    * onZooming\n    * @param  {Object} param event parameters\n    */\n    onZooming(param: any): void;\n    /**\n    * onMoveStart\n    * @param  {Object} param event parameters\n    */\n    onMoveStart(param: any): void;\n    /**\n    * onMoving\n    * @param  {Object} param event parameters\n    */\n    onMoving(param: any): void;\n    /**\n    * onMoveEnd\n    * @param  {Object} param event parameters\n    */\n    onMoveEnd(param: any): void;\n    /**\n    * onResize\n    * @param  {Object} param event parameters\n    */\n    onResize(param: any): void;\n    /**\n    * onDragRotateStart\n    * @param  {Object} param event parameters\n    */\n    onDragRotateStart(param: any): void;\n    /**\n    * onDragRotating\n    * @param  {Object} param event parameters\n    */\n    onDragRotating(param: any): void;\n    /**\n    * onDragRotateEnd\n    * @param  {Object} param event parameters\n    */\n    onDragRotateEnd(param: any): void;\n    /**\n    * onSpatialReferenceChange\n    * @param  {Object} param event parameters\n    */\n    onSpatialReferenceChange(param: any): void;\n    /**\n     * Get ellapsed time of previous drawing\n     * @return {Number}\n     */\n    getDrawTime(): number;\n    _tryToDraw(framestamp: any): void;\n    _drawAndRecord(framestamp: number): void;\n    _promiseResource(url: any): (resolve: any) => void;\n    _cacheResource(url: [string, number | string, string | number], img: ImageType): void;\n}\nexport default CanvasRenderer;\nexport type ResourceUrl = string | string[];\nexport declare class ResourceCache {\n    resources: any;\n    private _errors;\n    constructor();\n    addResource(url: [string, number | string, number | string], img: any): void;\n    isResourceLoaded(url: ResourceUrl, checkSVG?: boolean): boolean;\n    login(url: string): void;\n    logout(url: string): void;\n    getImage(url: ResourceUrl): any;\n    markErrorResource(url: ResourceUrl): void;\n    merge(res: any): this;\n    forEach(fn: Function): this;\n    _getImgUrl(url: ResourceUrl): string;\n    remove(): void;\n}\n"},{"path":"types/renderer/layer/ImageGLRenderable.d.ts","content":"import { Matrix4InOut } from '../../core/util';\nimport type { Map } from '../../map';\nimport { MixinConstructor } from '../../core/Mixin';\nimport { VertexAttrib, TileImageBuffer, TileImageTexture, TileImageType, TileRenderingProgram, TileRenderingCanvas, TileRenderingContext } from '../types';\nimport { WithNull } from '../../types/typings';\n/**\n * A mixin providing image support in WebGL env\n * @mixin ImageGLRenderable\n * @protected\n */\ndeclare const ImageGLRenderable: <T extends MixinConstructor>(Base: T) => {\n    new (...args: any[]): {\n        gl: TileRenderingContext;\n        canvas: TileRenderingCanvas;\n        canvas2?: TileRenderingCanvas;\n        _debugInfoCanvas?: TileRenderingCanvas;\n        program?: TileRenderingProgram;\n        _layerAlt: number;\n        _layerAltitude: number;\n        layer?: any;\n        texBuffer?: TileImageBuffer;\n        _debugBuffer?: TileImageBuffer;\n        posBuffer?: TileImageBuffer;\n        _imageBuffers?: TileImageBuffer[];\n        _buffers?: TileImageBuffer[];\n        _textures?: TileImageTexture[];\n        getMap?(): Map;\n        /**\n         * 绘制图片数据\n         *\n         * @english\n         * Draw an image at x, y at map's gl zoom\n         * @param image\n         * @param x x at map's gl zoom\n         * @param y y at map's gl zoom\n         * @param w width at map's gl zoom\n         * @param h height at map's gl zoom\n         * @param scale scale at map's gl zoom\n         * @param opacity\n         * @param debugInfo\n         * @param baseColor\n         */\n        drawGLImage(image: TileImageType, x: number, y: number, w: number, h: number, scale: number, opacity: number, debugInfo?: string, baseColor?: number[]): void;\n        /**\n         * 绘制 debug 信息，包括边线和行列号\n         * @param uMatrix\n         * @param x\n         * @param y\n         * @param w\n         * @param h\n         * @param debugInfo\n         */\n        drawDebug(uMatrix: Matrix4InOut, x: number, y: number, w: number, h: number, debugInfo: string): void;\n        /**\n         * 构建瓦片顶点数据\n         * @param x\n         * @param y\n         * @param w\n         * @param h\n         * @param buffer\n         */\n        bufferTileData(x: number, y: number, w: number, h: number, buffer?: TileImageBuffer): TileImageBuffer;\n        /**\n         * 对于需要两个 canvas 来绘制的图层我们需要重新创建一个 canvas\n         * @english\n         * Create another GL canvas to draw gl images\n         * For layer renderer that needs 2 seperate canvases for 2d and gl\n         */\n        createCanvas2(): void;\n        /**\n         * 创建 webgl 实例，优先使用 canvas2\n         * @english\n         * Get webgl context(this.gl). It prefers canvas2, and will change to this.canvas if canvas2 is not created\n         */\n        createGLContext(): void;\n        /**\n         * Resize GL canvas with renderer's 2D canvas\n         */\n        resizeGLCanvas(): void;\n        /**\n         * Clear gl canvas\n         */\n        clearGLCanvas(): void;\n        disposeImage(image: TileImageType): void;\n        _createTexture(image: TileImageType): TileImageTexture;\n        /**\n         * Get a texture from cache or create one if cache is empty\n         */\n        getTexture(): WithNull<TileImageTexture>;\n        /**\n         * Save a texture to the cache\n         */\n        saveTexture(texture: TileImageTexture): void;\n        /**\n         * Load image into a text and bind it with WebGLContext\n         * @param image\n         */\n        loadTexture(image: TileImageType): TileImageTexture;\n        /**\n         * Get a texture from cache or create one if cache is empty\n         */\n        getImageBuffer(): WithNull<TileImageBuffer>;\n        /**\n         * Save a texture to the cache\n         * @param buffer\n         */\n        saveImageBuffer(buffer: TileImageBuffer): void;\n        /**\n         * Load image into a text and bind it with WebGLContext\n         * @returns\n         */\n        loadImageBuffer(data: Float32Array | Int16Array, glBuffer: TileImageBuffer): TileImageBuffer;\n        createImageBuffer(): TileImageBuffer;\n        /**\n         * remove all the resources and remove gl canvas\n         */\n        removeGLCanvas(): void;\n        /**\n         * Create a WebGL buffer\n         * @returns {WebGLBuffer}\n         */\n        createBuffer(): TileImageBuffer;\n        /**\n         * Enable vertex attributes\n         * @params attributes\n         * @example\n         * rendererr.enableVertexAttrib(['a_position', 3, 'FLOAT']);\n         */\n        enableVertexAttrib(attributes: VertexAttrib): void;\n        /**\n         * Create the linked program object\n         * @param vert a vertex shader program (string)\n         * @param frag a fragment shader program (string)\n         * @return created program object, or null if the creation has failed\n         */\n        createProgram(vert: string, frag: string): TileRenderingProgram;\n        /**\n         * use the given program\n         * @param {WebGLProgram} program\n         */\n        useProgram(program: TileRenderingProgram): any;\n        /**\n         * 启用纹理采样器\n         * Enable a sampler, and set texture\n         * @param sampler\n         * @param texIdx id\n         */\n        enableSampler(sampler: string, texIdx?: number): WebGLUniformLocation;\n        _initUniforms(program: TileRenderingProgram, uniforms: string[]): void;\n        _getUniform(program: TileRenderingProgram, uniformName: string): WebGLUniformLocation;\n        set8(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Float32Array;\n        set8Int(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Int16Array;\n    };\n} & T;\nexport default ImageGLRenderable;\nexport declare function isPowerOfTwo(value: number): boolean;\nexport declare function floorPowerOfTwo(value: number): number;\n"},{"path":"types/renderer/layer/tilelayer/CanvasTileLayerRenderer.d.ts","content":"import TileLayerCanvasRenderer from './TileLayerCanvasRenderer';\nimport TileLayerGLRenderer from './TileLayerGLRenderer';\ndeclare class CanvasRenderer extends TileLayerCanvasRenderer {\n    loadTile(...args: any[]): any;\n}\ndeclare class GLRenderer extends TileLayerGLRenderer {\n    loadTile(...args: any[]): any;\n}\nexport { CanvasRenderer as CanvasTileLayerCanvasRenderer, GLRenderer as CanvasTileLayerGLRenderer };\n"},{"path":"types/renderer/layer/tilelayer/index.d.ts","content":"import TileLayerCanvasRenderer from './TileLayerCanvasRenderer';\nimport TileLayerGLRenderer from './TileLayerGLRenderer';\nimport { CanvasTileLayerCanvasRenderer, CanvasTileLayerGLRenderer } from './CanvasTileLayerRenderer';\nimport QuadStencil from './QuadStencil';\nexport { TileLayerCanvasRenderer, TileLayerGLRenderer, CanvasTileLayerCanvasRenderer, CanvasTileLayerGLRenderer, QuadStencil };\n"},{"path":"types/renderer/layer/tilelayer/QuadStencil.d.ts","content":"import { TileRenderingContext, TileRenderingProgram, VertexAttrib } from '../../types';\ndeclare class QuadStencil {\n    gl: TileRenderingContext;\n    quadVertices: any;\n    attributes: VertexAttrib;\n    debug: boolean;\n    buffer: any;\n    program: TileRenderingProgram;\n    _savedProgram: TileRenderingProgram;\n    colorLoc: WebGLUniformLocation;\n    transformLoc: WebGLUniformLocation;\n    ref: GLint;\n    constructor(gl: TileRenderingContext, vertices: any[] | Int8Array, debug?: boolean);\n    start(): void;\n    end(): void;\n    draw(transform: number[]): void;\n    remove(): this;\n    stencilMask(mask: number): this;\n    stencilFunc(func: number, ref: number, mask: number): this;\n    stencilOp(fail: number, zfail: number, zpass: number): this;\n    resetFunc(): this;\n    _save(): void;\n    _restore(): void;\n    _createBuffer(): void;\n    _createProgram(): void;\n}\nexport default QuadStencil;\n"},{"path":"types/renderer/layer/tilelayer/TileLayerCanvasRenderer.d.ts","content":"import { default as TileLayer } from '../../../layer/tile/TileLayer';\nimport CanvasRenderer from '../CanvasRenderer';\nimport Extent from '../../../geo/Extent';\nimport LRUCache from '../../../core/util/LRUCache';\nimport Actor from '../../../core/worker/Actor';\nimport { TileImageBuffer, TileImageTexture } from '../../types';\nimport type { WithUndef } from '../../../types/typings';\ndeclare class TileWorkerConnection extends Actor {\n    constructor();\n    checkUrl(url: string): string;\n    fetchImage(url: string, workerId: number, cb: Function, fetchOptions: any): void;\n}\n/**\n * 基于 `HTML5 Canvas2D` 的渲染器类，用于瓦片图层\n *\n * @english\n * Renderer class based on HTML5 Canvas2D for TileLayers\n * @class\n * @protected\n * @group renderer\n * @extends {renderer.CanvasRenderer}\n */\ndeclare class TileLayerCanvasRenderer extends CanvasRenderer {\n    tilesInView: TilesInViewType;\n    tilesLoading: {\n        [key: string]: any;\n    };\n    _parentTiles: any[];\n    _childTiles: any[];\n    _tileZoom: number;\n    _tileQueue: {\n        tileInfo: any;\n        tileData: any;\n    }[];\n    _tileQueueIds: Set<LayerId>;\n    tileCache: typeof LRUCache;\n    _compareTiles: any;\n    _tileImageWorkerConn: TileWorkerConnection;\n    _renderTimestamp: number;\n    _frameTiles: {\n        empty: boolean;\n        timestamp: number;\n    };\n    _terrainHelper: TerrainHelper;\n    _tilePlaceHolder: any;\n    _frameTileGrids: TileGrids;\n    drawingCurrentTiles: WithUndef<boolean>;\n    drawingChildTiles: WithUndef<boolean>;\n    drawingParentTiles: WithUndef<boolean>;\n    avgMinAltitude: number;\n    avgMaxAltitude: number;\n    /**\n     *\n     * @param {TileLayer} layer - TileLayer to render\n     */\n    constructor(layer: TileLayer);\n    getCurrentTileZoom(): number;\n    draw(timestamp: number, context: any): number;\n    getTileGridsInCurrentFrame(): TileGrids;\n    getCurrentTimestamp(): number;\n    _getTilesInCurrentFrame(): {\n        childTiles: any[];\n        missedTiles: any[];\n        parentTiles: any[];\n        tiles: any[];\n        incompleteTiles: unknown[];\n        placeholders: any[];\n        loading: boolean;\n        loadingCount: number;\n        tileQueue: {};\n    };\n    removeTileCache(tileId: TileId): void;\n    isTileCachedOrLoading(tileId: TileId): any;\n    isTileCached(tileId: TileId): boolean;\n    isTileFadingIn(tileImage: Tile['image']): boolean;\n    _drawTiles(tiles: any, parentTiles: any, childTiles: any, placeholders: any, parentContext: any): void;\n    _drawChildTiles(childTiles: any, parentContext: any): void;\n    _drawParentTiles(parentTiles: any, parentContext: any): void;\n    onDrawTileStart(context: RenderContext, parentContext: RenderContext): void;\n    onDrawTileEnd(context: RenderContext, parentContext: RenderContext): void;\n    _drawTile(info: any, image: any, parentContext: any): void;\n    _drawTileAndCache(tile: Tile, parentContext: any): void;\n    drawOnInteracting(event: any, timestamp: number, context: any): void;\n    needToRedraw(): boolean;\n    hitDetect(): boolean;\n    /**\n     * @private\n     * limit tile number to load when map is interacting\n     */\n    _getLoadLimit(): number;\n    isDrawable(): boolean;\n    clear(): void;\n    _isLoadingTile(tileId: TileId): boolean;\n    clipCanvas(context: any): boolean;\n    _clipByPitch(ctx: CanvasRenderingContext2D): boolean;\n    loadTileQueue(tileQueue: any): void;\n    loadTile(tile: Tile['info']): Tile['image'];\n    _fetchImage(image: any, tile: Tile['info']): void;\n    loadTileImage(tileImage: any, url: string): void;\n    abortTileLoading(tileImage: Tile['image'], tileInfo: Tile['info']): void;\n    onTileLoad(tileImage: Tile['image'], tileInfo: Tile['info']): void;\n    removeTileLoading(tileInfo: Tile['info']): void;\n    _consumeTileQueue(): void;\n    _computeAvgTileAltitude(): void;\n    checkTileInQueue(): boolean;\n    consumeTile(tileImage: Tile['image'], tileInfo: Tile['info']): void;\n    resetTileLoadTime(tileImage: Tile['image']): void;\n    onTileError(tileImage: Tile['image'], tileInfo: Tile['info'], error?: any): void;\n    drawTile(tileInfo: Tile['info'], tileImage: Tile['image'], parentContext?: RenderContext): void;\n    getDebugInfo(tileId: TileId): string;\n    findChildTiles(info: Tile['info']): any;\n    _findChildTiles(info: Tile['info']): Tile[] | any;\n    _findChildTilesAt(children: Tile[], pmin: number, pmax: number, layer: any, childZoom: number): void;\n    findParentTile(info: Tile['info'], targetDiff?: number): Tile;\n    _findParentTile(info: Tile['info'], targetDiff?: number): Tile;\n    isValidCachedTile(tile: Tile): boolean;\n    isTileComplete(): boolean;\n    _getLayerOfTile(layerId: LayerId): any;\n    getCachedTile(tile: Tile, isParent: boolean): any;\n    _addTileToCache(tileInfo: Tile['info'], tileImage: Tile['image']): void;\n    getTileOpacity(tileImage: Tile['image'], tileInfo: Tile['info']): number;\n    _getTileFadingOpacity(tileImage: Tile['image']): number;\n    onRemove(): void;\n    markCurrent(tile: Tile, isCurrent?: boolean): void;\n    markTiles(): number[];\n    retireTiles(force?: boolean): void;\n    deleteTile(tile: Tile): void;\n    _generatePlaceHolder(res: number): HTMLCanvasElement;\n    setTerrainHelper(helper: TerrainHelper): void;\n}\nexport default TileLayerCanvasRenderer;\nexport type TileId = string;\nexport type LayerId = string | number;\nexport type TerrainHelper = any;\nexport type TileImage = (HTMLImageElement | HTMLCanvasElement | ImageBitmap) & {\n    loadTime: number;\n    glBuffer?: TileImageBuffer;\n    texture?: TileImageTexture;\n    onerrorTick?: number;\n};\nexport interface Tile {\n    id: TileId;\n    info: {\n        x: number;\n        y: number;\n        z: number;\n        idx: number;\n        idy: number;\n        id: TileId;\n        layer: number | string;\n        children: [];\n        error: number;\n        offset: [number, number];\n        extent2d: Extent;\n        res: number;\n        url: string;\n        parent: any;\n        cache?: boolean;\n        minAltitude?: number;\n        maxAltitude?: number;\n        _glScale: number;\n    };\n    image: TileImage;\n    current?: boolean;\n}\nexport type RenderContext = any;\nexport type TilesInViewType = {\n    [key: string]: Tile;\n};\nexport interface TileGrid {\n    extent: Extent;\n    count: number;\n    tiles: Tile[];\n    parents: any[];\n    offset: number[];\n    zoom: number;\n}\nexport interface TileGrids {\n    count: number;\n    tileGrids: TileGrid[];\n}\n"},{"path":"types/renderer/layer/tilelayer/TileLayerGLRenderer.d.ts","content":"import TileLayerCanvasRenderer from './TileLayerCanvasRenderer';\nimport type { Tile, RenderContext } from './TileLayerCanvasRenderer';\nimport { SizeLike } from '../../../geo/Size';\ndeclare const TileLayerGLRenderer_base: {\n    new (...args: any[]): {\n        gl: import(\"src/renderer/types\").TileRenderingContext;\n        canvas: import(\"src/renderer/types\").TileRenderingCanvas;\n        canvas2?: import(\"src/renderer/types\").TileRenderingCanvas;\n        _debugInfoCanvas?: import(\"src/renderer/types\").TileRenderingCanvas;\n        program?: import(\"src/renderer/types\").TileRenderingProgram;\n        _layerAlt: number;\n        _layerAltitude: number;\n        layer?: any;\n        texBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        _debugBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        posBuffer?: import(\"src/renderer/types\").TileImageBuffer;\n        _imageBuffers?: import(\"src/renderer/types\").TileImageBuffer[];\n        _buffers?: import(\"src/renderer/types\").TileImageBuffer[];\n        _textures?: WebGLTexture[];\n        getMap?(): import(\"src\").Map;\n        drawGLImage(image: import(\"src/renderer/types\").TileImageType, x: number, y: number, w: number, h: number, scale: number, opacity: number, debugInfo?: string, baseColor?: number[]): void;\n        drawDebug(uMatrix: import(\"src/core/util\").Matrix4InOut, x: number, y: number, w: number, h: number, debugInfo: string): void;\n        bufferTileData(x: number, y: number, w: number, h: number, buffer?: import(\"src/renderer/types\").TileImageBuffer): import(\"src/renderer/types\").TileImageBuffer;\n        createCanvas2(): void;\n        createGLContext(): void;\n        resizeGLCanvas(): void;\n        clearGLCanvas(): void;\n        disposeImage(image: import(\"src/renderer/types\").TileImageType): void;\n        _createTexture(image: import(\"src/renderer/types\").TileImageType): WebGLTexture;\n        getTexture(): WebGLTexture;\n        saveTexture(texture: WebGLTexture): void;\n        loadTexture(image: import(\"src/renderer/types\").TileImageType): WebGLTexture;\n        getImageBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        saveImageBuffer(buffer: import(\"src/renderer/types\").TileImageBuffer): void;\n        loadImageBuffer(data: Int16Array | Float32Array, glBuffer: import(\"src/renderer/types\").TileImageBuffer): import(\"src/renderer/types\").TileImageBuffer;\n        createImageBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        removeGLCanvas(): void;\n        createBuffer(): import(\"src/renderer/types\").TileImageBuffer;\n        enableVertexAttrib(attributes: import(\"src/renderer/types\").VertexAttrib): void;\n        createProgram(vert: string, frag: string): import(\"src/renderer/types\").TileRenderingProgram;\n        useProgram(program: import(\"src/renderer/types\").TileRenderingProgram): any;\n        enableSampler(sampler: string, texIdx?: number): WebGLUniformLocation;\n        _initUniforms(program: import(\"src/renderer/types\").TileRenderingProgram, uniforms: string[]): void;\n        _getUniform(program: import(\"src/renderer/types\").TileRenderingProgram, uniformName: string): WebGLUniformLocation;\n        set8(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Float32Array;\n        set8Int(a0: number, a1: number, a2: number, a3: number, a4: number, a5: number, a6: number, a7: number): Int16Array;\n    };\n} & typeof TileLayerCanvasRenderer;\n/**\n * 基于 HTML5 WebGL 的 TileLayers 渲染器\n *\n * @english\n * Renderer class based on HTML5 WebGL for TileLayers\n * @class\n * @protected\n * @group renderer\n * @extends {renderer.TileLayerCanvasRenderer}\n * @param layer - TileLayer to render\n */\ndeclare class TileLayerGLRenderer extends TileLayerGLRenderer_base {\n    isDrawable(): boolean;\n    needToRedraw(): boolean;\n    onDrawTileStart(context: RenderContext, parentContext: RenderContext): void;\n    onDrawTileEnd(context: RenderContext, parentContext: RenderContext): void;\n    drawTile(tileInfo: Tile['info'], tileImage: Tile['image'], parentContext: RenderContext): void;\n    _bindGLBuffer(image: Tile['image'], w: number, h: number): void;\n    loadTileImage(tileImage: HTMLImageElement, url: string): void;\n    /**\n     * prepare gl, create program, create buffers and fill unchanged data: image samplers, texture coordinates\n     */\n    onCanvasCreate(): void;\n    createContext(): void;\n    resizeCanvas(canvasSize: SizeLike): void;\n    clearCanvas(): void;\n    getCanvasImage(): any;\n    /**\n     * decide whether the layer is renderer with gl.\n     * when map is pitching, or fragmentShader is set in options\n     */\n    isGL(): boolean;\n    deleteTile(tile: Tile): void;\n    onRemove(): void;\n}\nexport default TileLayerGLRenderer;\n"},{"path":"types/renderer/layer/vectorlayer/index.d.ts","content":"import OverlayLayerCanvasRenderer from './OverlayLayerCanvasRenderer';\nimport VectorLayerCanvasRenderer from './VectorLayerCanvasRenderer';\nexport { OverlayLayerCanvasRenderer, VectorLayerCanvasRenderer };\n"},{"path":"types/renderer/layer/vectorlayer/OverlayLayerCanvasRenderer.d.ts","content":"import { type Geometry } from '../../../geometry';\nimport CanvasRenderer from '../CanvasRenderer';\nimport { Geometries } from '../../../geometry';\nimport Extent from '../../../geo/Extent';\ninterface MapStateCacheType {\n    resolution: number;\n    pitch: number;\n    bearing: number;\n    glScale: number;\n    glRes: number;\n    _2DExtent: Extent;\n    glExtent: Extent;\n    containerExtent: Extent;\n    offset: number;\n}\n/**\n * OverlayLayer 的父呈现器类，供 OverlayLayer 的子类继承。\n *\n * @english\n *\n * A parent renderer class for OverlayLayer to inherit by OverlayLayer's subclasses.\n * @protected\n * @memberOf renderer\n * @name OverlayLayerCanvasRenderer\n * @extends renderer.CanvasRenderer\n */\ndeclare class OverlayLayerRenderer extends CanvasRenderer {\n    _geosToCheck: Geometries[];\n    _resourceChecked: boolean;\n    clearImageData?(): void;\n    _lastGeosToDraw: Geometry[];\n    mapStateCache: MapStateCacheType;\n    /**\n     * @english\n     * possible memory leaks:\n     * 1. if geometries' symbols with external resources change frequently,\n     * resources of old symbols will still be stored.\n     * 2. removed geometries' resources won't be removed.\n     */\n    checkResources(): any[];\n    render(...args: any[]): void;\n    _addGeoToCheckRes(res: Geometries | Geometries[]): void;\n    onGeometryAdd(geometries: Geometries | Geometries[]): void;\n    onGeometryRemove(params: any): void;\n    onGeometrySymbolChange(e: {\n        target: Geometries;\n    }): void;\n    onGeometryShapeChange(params: any): void;\n    onGeometryPositionChange(params: any): void;\n    onGeometryZIndexChange(params: any): void;\n    onGeometryShow(params: any): void;\n    onGeometryHide(params: any): void;\n    onGeometryPropertiesChange(_: any): void;\n}\nexport default OverlayLayerRenderer;\n"},{"path":"types/renderer/layer/vectorlayer/VectorLayerCanvasRenderer.d.ts","content":"import { type Vector3 } from '../../../core/util';\nimport OverlayLayerCanvasRenderer from './OverlayLayerCanvasRenderer';\nimport Extent from '../../../geo/Extent';\nimport type { Painter, CollectionPainter } from '../../geometry';\nimport { Point } from '../../../geo';\nimport { Geometries } from '../../../geometry';\nimport type { WithUndef } from '../../../types/typings';\n/**\n * 基于 `HTML5 Canvas2D` 的渲染器类，用于矢量层\n *\n * @english\n * Renderer class based on HTML5 Canvas2D for VectorLayers\n * @protected\n * @group renderer\n * @name VectorLayerCanvasRenderer\n * @extends renderer.OverlaylayerCanvasRenderer\n * @param layer - layer to render\n */\ndeclare class VectorLayerRenderer extends OverlayLayerCanvasRenderer {\n    _lastRenderTime: number;\n    _lastCollisionTime: number;\n    _imageData: ImageData;\n    _geosToDraw: Geometries[];\n    _lastGeosToDraw: Geometries[];\n    _hasPoint: boolean;\n    _onlyHasPoint: WithUndef<boolean>;\n    _displayExtent: Extent;\n    _drawnRes: number;\n    renderEnd: boolean;\n    pageGeos: Geometries[];\n    page: number;\n    maxTolerance: number;\n    geoPainterList: (Painter | CollectionPainter)[];\n    snapshotCanvas: HTMLCanvasElement;\n    setToRedraw(): this;\n    _geoIsCollision(geo: GeoType, collisionIndex: any): boolean;\n    getImageData(): ImageData;\n    clearImageData(): void;\n    checkResources(...args: any[]): any;\n    needToRedraw(): boolean;\n    /**\n     * render layer\n     */\n    draw(): void;\n    isBlank(): boolean;\n    drawOnInteracting(): void;\n    /**\n     * Show and render\n     * @override\n     */\n    show(...args: any[]): void;\n    forEachGeo(fn: Function, context?: any): void;\n    _checkGeos(): this;\n    drawGeos(): void;\n    prepareToDraw(): this;\n    _setDrawGeosDrawTime(): this;\n    checkGeo(geo: Geometries): void;\n    _collidesGeos(): this;\n    onZoomEnd(...args: any[]): void;\n    onRemove(): void;\n    onGeometryPropertiesChange(param: any): void;\n    _updateDisplayExtent(): void;\n    identifyAtPoint(point: Point, options?: {}): any;\n    _updateMapStateCache(): this;\n    /**\n     * 使用批量坐标转换提升性能\n     * 优化前 11fps\n     * 优化后 15fps\n     * Better performance of batch coordinate conversion\n     * @param glRes\n     */\n    _batchConversionMarkers(glRes: number): any[];\n    _sortByDistanceToCamera(cameraPosition: Vector3): void;\n    _constructorIsThis(): boolean;\n    isProgressiveRender(): boolean;\n    getGeosForIdentify(): Geometries[];\n    getGeoPainterList(): (Painter | CollectionPainter)[];\n    _checkSnapshotCanvas(): HTMLCanvasElement;\n    _getCurrentNeedRenderGeos(): Geometries[];\n    _resetProgressiveRender(): void;\n    _clearSnapshotCanvas(): void;\n    _snapshot(): this;\n    _drawSnapshot(): this;\n}\ntype GeoType = any;\nexport default VectorLayerRenderer;\n"},{"path":"types/renderer/map/MapCanvasRenderer.d.ts","content":"import Point from '../../geo/Point';\nimport MapRenderer from './MapRenderer';\nimport Map from '../../map/Map';\nimport type EditHandle from '../edit/EditHandle';\nimport type EditOutline from '../edit/EditOutline';\nimport type { Layer } from '../../layer';\nimport type Size from '../../geo/Size';\nimport type { WithUndef } from '../../types/typings';\n/**\n * 基于 Canvas2D 的 map 渲染器\n *\n * @english\n * Renderer class based on HTML5 Canvas for maps.\n * @class\n * @protected\n * @extends {renderer.MapRenderer}\n * @memberOf renderer\n */\ndeclare class MapCanvasRenderer extends MapRenderer {\n    _containerIsCanvas: boolean;\n    _loopTime: number;\n    _resizeTime: number;\n    _resizeCount: number;\n    _frameCycleRenderCount: number;\n    _resizeEventList: ResizeObserverEntry[];\n    _needClear: boolean;\n    _canvasUpdated: boolean;\n    _isViewChanged: WithUndef<boolean>;\n    _spatialRefChanged: WithUndef<boolean>;\n    _resizeObserver: ResizeObserver;\n    _resizeInterval: number;\n    _checkSizeInterval: number;\n    _hitDetectFrame: number;\n    _animationFrame: number;\n    _mapview: MapView;\n    _zoomMatrix: number[];\n    _eventParam: any;\n    _canvasIds: string[];\n    _updatedIds: string[];\n    _frameTimestamp: number;\n    _checkPositionTime: number;\n    _tops: (EditHandle | EditOutline)[];\n    context: CanvasRenderingContext2D;\n    canvas: HTMLCanvasElement;\n    topLayer: HTMLCanvasElement;\n    topCtx: CanvasRenderingContext2D;\n    /**\n     * @param map - map for the renderer\n     */\n    constructor(map: Map);\n    load(): void;\n    /**\n     * render layers in current frame\n     * @returns return false to cease frame loop\n     */\n    renderFrame(framestamp: number): boolean;\n    updateMapDOM(): void;\n    drawLayers(layers: Layer[], framestamp: number): void;\n    /**\n     * check if need to call layer's draw/drawInteracting\n     * @param layer\n     */\n    _checkLayerRedraw(layer: Layer): boolean;\n    /**\n     * Draw canvas rendered layer when map is interacting\n     * @param layer\n     * @param t     current consumed time of layer drawing\n     * @param timeLimit time limit for layer drawing\n     * @param framestamp\n     * @returns time to draw this layer\n     * @private\n     */\n    _drawCanvasLayerOnInteracting(layer: Layer, t: number, timeLimit: number, framestamp: number): number;\n    /**\n     * Fire layerload events.\n     * Make sure layer are drawn on map when firing the events\n     * @private\n     */\n    _fireLayerLoadEvents(): void;\n    isLayerCanvasUpdated(): boolean;\n    setLayerCanvasUpdated(): void;\n    /**\n     * Renders the layers\n     */\n    drawLayerCanvas(layers: Layer[]): boolean;\n    setToRedraw(): void;\n    updateMapSize(size: Size): void;\n    getMainPanel(): HTMLCanvasElement | HTMLDivElement | (HTMLElement & {\n        layerDOM: HTMLElement;\n        uiDOM: HTMLElement;\n    });\n    toDataURL(mimeType: string, quality?: number): string;\n    remove(): void;\n    hitDetect(point: Point): void;\n    _getLayerImage(layer: Layer): any;\n    /**\n     * initialize container DOM of panels\n     */\n    initContainer(): void;\n    /**\n     * Is current map's state changed?\n     */\n    isViewChanged(): boolean;\n    _recordView(): void;\n    isSpatialReferenceChanged(): boolean;\n    _getMapView(): MapView;\n    _lockFrameRenderEnable(): boolean;\n    /**\n    * Main frame loop\n    */\n    _frameLoop(framestamp: number): void;\n    _cancelFrameLoop(): void;\n    _drawLayerCanvasImage(layer: Layer, layerImage: any, targetWidth?: number, targetHeight?: number): void;\n    _drawCenterCross(): void;\n    _drawContainerExtent(): void;\n    _drawFog(): void;\n    _debugSky(): this;\n    _getAllLayerToRender(): any[];\n    clearCanvas(): void;\n    _updateCanvasSize(): boolean;\n    createCanvas(): void;\n    _updateDomPosition(framestamp: number): this;\n    _handleResizeEventList(time: number): this;\n    _checkSize(): void;\n    _setCheckSizeInterval(interval: number): void;\n    _registerEvents(): void;\n    _onMapMouseMove(param: any): void;\n    _getCanvasLayers(): any[];\n    addTopElement(e: EditHandle | EditOutline): void;\n    removeTopElement(e: EditHandle | EditOutline): void;\n    getTopElements(): (EditHandle | EditOutline)[];\n    sortTopElements(): void;\n    drawTops(): void;\n}\nexport type MapView = {\n    x: number;\n    y: number;\n    zoom: number;\n    pitch: number;\n    bearing: number;\n    width: number;\n    height: number;\n};\nexport default MapCanvasRenderer;\n"},{"path":"types/renderer/map/MapRenderer.d.ts","content":"import Class from '../../core/Class';\nimport Point from '../../geo/Point';\nimport type { WithUndef } from '../../types/typings';\nimport type Map from '../../map/Map';\ntype handlerQueueFn = () => void;\n/**\n * 所有地图渲染器的基类。\n * @english\n * Base class for all the map renderers.\n * @abstract\n * @protected\n * @memberOf renderer\n * @extends {Class}\n */\ndeclare abstract class MapRenderer extends Class {\n    map: Map;\n    _handlerQueue: handlerQueueFn[];\n    _frontCount: WithUndef<number>;\n    _backCount: WithUndef<number>;\n    _uiCount: WithUndef<number>;\n    _thisDocVisibilitychange: () => void;\n    _thisDocDragStart: () => void;\n    _thisDocDragEnd: () => void;\n    _thisDocDPRChange: () => void;\n    constructor(map: Map);\n    abstract _frameLoop(f?: number): void;\n    abstract setToRedraw(): void;\n    callInNextFrame(fn: handlerQueueFn): void;\n    executeFrameCallbacks(): void;\n    /**\n     * Move map platform with offset\n     * @param offset\n     * @param force\n     */\n    offsetPlatform(offset: Point, force?: boolean): this;\n    domChanged(): boolean;\n    resetContainer(): void;\n    onZoomEnd(): void;\n    onLoad(): void;\n    _onDocVisibilitychange(): void;\n    _getWrapPanel(): import(\"../../map/Map\").PanelDom;\n    _onDocDragStart(): void;\n    _onDocDragEnd(): void;\n    _onDocDPRChange(): void;\n    _containerIsOffscreen(): boolean;\n}\nexport default MapRenderer;\n"},{"path":"types/renderer/Renderable.d.ts","content":"import Class from \"../core/Class\";\nimport { MixinConstructor } from \"../core/Mixin\";\n/**\n * 一切可渲染的公共方法，例如：`Map`、'Layers'\n * @english\n * Common methods for classes can be rendered, e.g. Map, Layers\n * @mixin Renderable\n * @protected\n */\nexport default function <T extends MixinConstructor>(Base: T): {\n    new (...args: any[]): {};\n    /**\n     * 用给定的 name 注册一个 `renderer` 类\n     * @english\n     * Register a renderer class with the given name.\n     * @param  name  - renderer's register key\n     * @param  clazz - renderer's class{@link Class}).\n     */\n    registerRenderer<T_1 extends typeof Class>(name: string, clazz: T_1): any & T;\n    /**\n     * 返回用name注册的 `renderer` 类\n     * @english\n     * Get the registered renderer class by the given name\n     * @param  name  - renderer's register key\n     */\n    getRendererClass(name: string): Class | null;\n} & T;\n"},{"path":"types/renderer/types.d.ts","content":"export type TileRenderingCanvas = {\n    gl?: TileRenderingContext;\n    texture?: TileImageTexture;\n    _parentTileTimestamp?: number;\n} & HTMLCanvasElement;\nexport type TileRenderingContext = {\n    program: TileRenderingProgram;\n    wrap: () => TileRenderingContext;\n} & (WebGLRenderingContext | WebGL2RenderingContext);\nexport type TileRenderingProgram = {\n    fragmentShader: string;\n    vertexShader: string;\n} & WebGLProgram;\nexport type ImageType = HTMLImageElement | ImageBitmap | HTMLCanvasElement;\nexport type TileImageType = {\n    glBuffer?: TileImageBuffer;\n    texture?: TileImageTexture;\n} & ImageType;\nexport type TileImageBuffer = {\n    width?: number;\n    height?: number;\n    type?: string;\n} & WebGLBuffer;\nexport type TileImageTexture = WebGLTexture;\nexport type VertexAttrib = [name: string, stride: number, type?: string];\n"},{"path":"types/symbol/index.d.ts","content":"export type FunctionTypeExponential = {\n    stops: Array<Array<number>>;\n    base?: number;\n    property?: string;\n    default?: number;\n    type: 'exponential';\n};\nexport type FunctionTypeIdentity = {\n    property: string;\n    default?: any;\n    type: 'identity';\n};\nexport type FunctionTypeInterval = {\n    stops: Array<[number, any]>;\n    property?: string;\n    default?: any;\n    type: 'interval';\n};\nexport type FunctionTypeCategorical = {\n    stops: Array<[number, any]>;\n    property?: string;\n    default?: any;\n    type: 'categorical';\n};\nexport type FunctionTypeColor_Interpolate = {\n    stops: Array<[number, string]>;\n    property?: string;\n    default?: any;\n    type: 'color-interpolate';\n};\nexport type SymbolBooleanType = boolean | FunctionTypeIdentity | FunctionTypeInterval | FunctionTypeCategorical;\nexport type SymbolNumberType = number | FunctionTypeExponential | FunctionTypeIdentity | FunctionTypeInterval | FunctionTypeCategorical;\nexport type SymbolColorType = string | Array<number> | FunctionTypeColor_Interpolate;\nexport type SymbolCommon = {\n    visible?: SymbolBooleanType;\n    opacity?: SymbolNumberType;\n    shadowBlur?: SymbolNumberType;\n    shadowColor?: SymbolColorType;\n    shadowOffsetX?: SymbolNumberType;\n    shadowOffsetY?: SymbolNumberType;\n};\nexport type MarkerCommonSymbol = {\n    markerOpacity?: SymbolNumberType;\n    markerWidth?: SymbolNumberType;\n    markerHeight?: SymbolNumberType;\n    markerDx?: SymbolNumberType;\n    markerDy?: SymbolNumberType;\n    markerHorizontalAlignment?: 'left' | 'middle' | 'right';\n    markerVerticalAlignment?: 'top' | 'middle' | 'bottom';\n    markerPlacement?: 'point' | 'vertex' | 'line' | 'vertex-first' | 'vertex-last';\n    markerRotation?: number;\n};\nexport type FileMarkerSymbol = {\n    markerFile: string;\n} & MarkerCommonSymbol & SymbolCommon;\nexport type VectorMarkerSymbol = {\n    markerType: 'ellipse' | 'cross' | 'x' | 'diamond' | 'bar' | 'square' | 'rectangle' | 'triangle' | 'pin' | 'pie';\n    markerFill?: SymbolColorType;\n    markerFillPatternFile?: string;\n    markerFillOpacity?: number;\n    markerLineColor?: SymbolColorType;\n    markerLineWidth?: number;\n    markerLineOpacity?: number;\n    markerLineDasharray?: Array<number>;\n    markerLinePatternFile?: string;\n} & MarkerCommonSymbol & SymbolCommon;\ntype SVGPathItem = {\n    path: string;\n    fill?: string;\n};\nexport type PathMarkerSymbol = {\n    markerType: 'path';\n    markerPath: string | Array<SVGPathItem>;\n    markerPathWidth: number;\n    markerPathHeight: number;\n} & MarkerCommonSymbol & SymbolCommon;\nexport type TextSymbol = {\n    textName?: string;\n    textPlacement?: 'point' | 'vertex' | 'line' | 'vertex-first' | 'vertex-last';\n    textFaceName?: string;\n    textFont?: string;\n    textWeight?: string;\n    textStyle?: string;\n    textSize?: SymbolNumberType;\n    textFill?: SymbolColorType;\n    textOpacity?: SymbolNumberType;\n    textHaloFill?: SymbolColorType;\n    textHaloRadius?: SymbolNumberType;\n    textHaloOpacity?: SymbolNumberType;\n    textWrapWidth?: number;\n    textWrapCharacter?: string;\n    textLineSpacing?: number;\n    textHorizontalAlignment?: 'left' | 'middle' | 'right';\n    textVerticalAlignment?: 'top' | 'middle' | 'bottom';\n    textAlign?: 'left' | 'right' | 'center';\n    textRotation?: number;\n    textDx?: SymbolNumberType;\n    textDy?: SymbolNumberType;\n};\nexport type LineSymbol = {\n    lineColor?: SymbolColorType;\n    lineWidth?: SymbolNumberType;\n    lineDasharray?: Array<number>;\n    lineOpacity?: SymbolNumberType;\n    lineJoin?: 'round' | 'bevel' | 'miter';\n    lineCap?: 'butt' | 'round' | 'square';\n    linePatternFile?: string;\n    lineDx?: SymbolNumberType;\n    lineDy?: SymbolNumberType;\n};\nexport type FillSymbol = {\n    polygonFill?: SymbolColorType;\n    polygonOpacity?: SymbolNumberType;\n    polygonPatternFile?: string;\n} & LineSymbol;\nexport type AnyMarkerSymbol = FileMarkerSymbol | VectorMarkerSymbol | PathMarkerSymbol | TextSymbol;\nexport type AnySymbol = FillSymbol | LineSymbol | TextSymbol | FileMarkerSymbol | VectorMarkerSymbol | PathMarkerSymbol;\nexport {};\n"},{"path":"types/test/MapDrill.d.ts","content":""},{"path":"types/types/typings.d.ts","content":"export type WithNull<T> = T | null;\nexport type WithUndef<T> = T | undefined;\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\nexport type Requireal<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\ndeclare global {\n    interface Window {\n        MSPointerEvent: any;\n        opera: any;\n        DocumentTouch: any;\n    }\n    interface CanvasRenderingContext2D {\n        isHitTesting: boolean;\n    }\n}\n"},{"path":"types/typings.d.ts","content":"export type WithNull<T> = T | null;\nexport type WithUndef<T> = T | undefined;\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\nexport type Requireal<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\ndeclare global {\n    interface Window {\n        MSPointerEvent: any;\n        opera: any;\n        DocumentTouch: any;\n    }\n    interface CanvasRenderingContext2D {\n        isHitTesting: boolean;\n    }\n}\n"},{"path":"types/ui/index.d.ts","content":"import UIComponent from './UIComponent';\nimport UIMarker from './UIMarker';\nimport InfoWindow from './InfoWindow';\nimport ToolTip from './ToolTip';\nimport Menu from './Menu';\nimport Menuable from './Menuable';\nexport { UIComponent, UIMarker, InfoWindow, ToolTip, Menuable, Menu };\n"},{"path":"types/ui/InfoWindow.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport { Geometry, LineString } from '../geometry';\nimport type { Map } from '../map';\nimport { MapEventDataType } from '../map/Map.DomEvents';\nimport UIComponent, { UIComponentOptionsType } from './UIComponent';\n/**\n * @classdesc\n * Class for info window, a popup on the map to display any useful infomation you wanted.\n * @category ui\n * @extends ui.UIComponent\n * @param {Object} options - options defined in [InfoWindow]{@link InfoWindow#options}\n * @memberOf ui\n */\ndeclare class InfoWindow extends UIComponent {\n    options: InfoWindowOptionsType;\n    _onCloseBtnClick: () => void;\n    _getClassName(): string;\n    /**\n     * Adds the UI Component to a geometry or a map\n     * @param {Geometry|Map} owner - geometry or map to addto.\n     * @returns {UIComponent} this\n     * @fires UIComponent#add\n     */\n    addTo(owner: Geometry | Map): this;\n    /**\n     * Set the content of the infowindow.\n     * @param {String|HTMLElement} content - content of the infowindow.\n     * return {InfoWindow} this\n     * @fires InfoWindow#contentchange\n     */\n    setContent(content: string | HTMLElement): this;\n    /**\n     * Get content of  the infowindow.\n     * @return {String|HTMLElement} - content of the infowindow\n     */\n    getContent(): string | HTMLElement;\n    /**\n     * Set the title of the infowindow.\n     * @param {String|HTMLElement} title - title of the infowindow.\n     * return {InfoWindow} this\n     * @fires InfoWindow#titlechange\n     */\n    setTitle(title: string): this;\n    /**\n     * Get title of  the infowindow.\n     * @return {String|HTMLElement} - content of the infowindow\n     */\n    getTitle(): string;\n    buildOn(): HTMLElement;\n    _replaceTemplate(dom: Element): this;\n    /**\n     * Gets InfoWindow's transform origin for animation transform\n     * @protected\n     * @return {Point} transform origin\n     */\n    getTransformOrigin(): string;\n    getOffset(): Point;\n    show(coordinate: Coordinate): this;\n    getEvents(): {};\n    getOwnerEvents(): {};\n    onRemove(): void;\n    onDomRemove(): void;\n    _onAutoOpen(e: MapEventDataType): void;\n    _rectifyMouseCoordinte(owner: Geometry | Map, mouseCoordinate: Coordinate): Coordinate;\n    _rectifyLineStringMouseCoordinate(lineString: LineString, mouseCoordinate: Coordinate): {\n        dis: number;\n        coordinate: Coordinate;\n    };\n    _getWindowWidth(): string;\n}\nexport default InfoWindow;\nexport type InfoWindowOptionsType = {\n    containerClass?: string;\n    autoPan?: boolean;\n    autoCloseOn?: string;\n    autoOpenOn?: string;\n    width?: string;\n    minHeight?: number;\n    custom?: boolean;\n    title?: string;\n    content?: string | HTMLElement;\n    enableTemplate?: boolean;\n} & UIComponentOptionsType;\n"},{"path":"types/ui/Menu.d.ts","content":"import Point from '../geo/Point';\nimport type { Geometry } from '../geometry';\nimport type { Map } from '../map';\nimport UIComponent, { UIComponentOptionsType } from './UIComponent';\n/**\n * @classdesc\n * Class for context menu, useful for interactions with right clicks on the map.\n * @category ui\n * @extends ui.UIComponent\n * @memberOf ui\n */\ndeclare class Menu extends UIComponent {\n    options: MenuOptionsType;\n    /**\n     * Menu items is set to options.items or by setItems method. <br>\n     * <br>\n     * Normally items is a object array, containing: <br>\n     * 1. item object: {'item': 'This is a menu text', 'click': function() {alert('oops! You clicked!');)}} <br>\n     * 2. minus string \"-\", which will draw a splitor line on the menu. <br>\n     * <br>\n     * If options.custom is set to true, the menu is considered as a customized one. Then items is the customized html codes or HTMLElement. <br>\n     * @param {Object} options - options defined in [ui.Menu]{@link ui.Menu#options}\n     */\n    constructor(options: MenuOptionsType);\n    _getClassName(): string;\n    addTo(owner: Geometry | Map): any;\n    /**\n     * Set the items of the menu.\n     * @param {Object[]|String|HTMLElement} items - items of the menu\n     * return {ui.Menu} this\n     * @example\n     * menu.setItems([\n     *      //return false to prevent event propagation\n     *     {'item': 'Query', 'click': function() {alert('Query Clicked!'); return false;}},\n     *     '-',\n     *     {'item': 'Edit', 'click': function() {alert('Edit Clicked!')}},\n     *     {'item': 'About', 'click': function() {alert('About Clicked!')}}\n     * ]);\n     */\n    setItems(items: Array<MenuItem>): this;\n    /**\n     * Get items of  the menu.\n     * @return {Object[]|String|HTMLElement} - items of the menu\n     */\n    getItems(): MenuItem[];\n    /**\n     * Create the menu DOM.\n     * @protected\n     * @return {HTMLElement} menu's DOM\n     */\n    buildOn(): HTMLElement;\n    /**\n     * Offset of the menu DOM to fit the click position.\n     * @return {Point} offset\n     * @private\n     */\n    getOffset(): Point;\n    getTransformOrigin(): string;\n    getEvents(): {\n        '_zoomstart _zoomend _movestart _dblclick _click': () => void;\n    };\n    _createMenuItemDom(): HTMLElement;\n    _getMenuWidth(): number;\n}\nexport default Menu;\nexport type MenuItem = {\n    name?: string;\n    click?: () => void;\n};\nexport type MenuOptionsType = {\n    containerClass?: string;\n    animationDelay?: number;\n    animationOnHide?: boolean;\n    autoPan?: boolean;\n    width?: number;\n    maxHeight?: number;\n    custom?: boolean;\n    items?: Array<MenuItem>;\n} & UIComponentOptionsType;\n"},{"path":"types/ui/Menuable.d.ts","content":"import Menu, { MenuItem, MenuOptionsType } from './Menu';\nimport { Coordinate } from '../geo';\ninterface MenuAbles {\n    _menuOptions: MenuOptionsType;\n    _menu: Menu;\n    setMenu(options: MenuOptionsType): this;\n    getMenu(): Menu;\n    openMenu(coordinate?: Coordinate): this;\n    setMenuItems(items: Array<MenuItem>): this;\n    getMenuItems(): Array<MenuItem>;\n    closeMenu(): this;\n    removeMenu(): this;\n    _bindMenu(): this;\n    _unbindMenu(): this;\n    _defaultOpenMenu(param: any): boolean;\n}\ndeclare module \"../geometry/Geometry\" {\n    interface Geometry extends MenuAbles {\n    }\n}\ndeclare module \"../map/Map\" {\n    interface Map extends MenuAbles {\n    }\n}\n/**\n * Mixin of the context menu methods.\n * @mixin ui.Menuable\n */\ndeclare const Menuable: {\n    /**\n     * Set a context menu\n     * @param {Object} options - menu options\n     * @return {*} this\n     * @example\n     * foo.setMenu({\n     *  'width'  : 160,\n     *  'custom' : false,\n     *  'items' : [\n     *      //return false to prevent event propagation\n     *     {'item': 'Query', 'click': function() {alert('Query Clicked!'); return false;}},\n     *     '-',\n     *     {'item': 'Edit', 'click': function() {alert('Edit Clicked!')}},\n     *     {'item': 'About', 'click': function() {alert('About Clicked!')}}\n     *    ]\n     * });\n     * @function ui.Menuable.setMenu\n     */\n    setMenu(options: MenuOptionsType): any;\n    /**\n    * get a context menu\n    * @return {*} ui.Menu\n    * @function ui.Menuable.getMenu\n    */\n    getMenu(): Menu;\n    /**\n     * Open the context menu, default on the center of the geometry or map.\n     * @param {Coordinate} [coordinate=null] - coordinate to open the context menu\n     * @return {*} this\n     * @function ui.Menuable.openMenu\n     */\n    openMenu(coordinate?: Coordinate): any;\n    /**\n     * Set menu items to the context menu\n     * @param {Object[]} items - menu items\n     * @return {*} this\n     * @function ui.Menuable.setMenuItems\n     */\n    setMenuItems(items: Array<MenuItem>): any;\n    /**\n     * Get the context menu items\n     * @return {Object[]}\n     * @function ui.Menuable.getMenuItems\n     */\n    getMenuItems(): Array<MenuItem>;\n    /**\n     * Close the contexnt menu\n     * @return {*} this\n     * @function ui.Menuable.closeMenu\n     */\n    closeMenu(): any;\n    /**\n     * Remove the context menu\n     * @return {*} this\n     * @function ui.Menuable.removeMenu\n     */\n    removeMenu(): any;\n    _bindMenu(): any;\n    _unbindMenu(): any;\n    /**\n     * If contextmenu is not listened, open the menu in default.<br>\n     * Otherwise, do nothing here.\n     * @param  {Object} param - event parameter\n     * @return {Boolean} true | false to stop event propagation\n     * @private\n     */\n    _defaultOpenMenu(param: any): boolean;\n};\nexport default Menuable;\n"},{"path":"types/ui/ToolTip.d.ts","content":"/// <reference types=\"node\" />\nimport type { Geometry } from '../geometry';\nimport UIComponent, { UIComponentOptionsType } from './UIComponent';\n/**\n * @classdesc\n * Class for tooltip, a tooltip used for showing some useful infomation attached to geometries on the map.\n * @category ui\n * @extends ui.UIComponent\n * @memberOf ui\n */\ndeclare class ToolTip extends UIComponent {\n    options: ToolTipOptionsType;\n    _content: string;\n    _timeout: NodeJS.Timeout;\n    _owner: Geometry;\n    _getClassName(): string;\n    /**\n     * @param {String} content         - content of tooltip\n     * @param {Object} [options=null]  - options defined in [ToolTip]{@link ToolTip#options}\n     */\n    constructor(content: string, options?: ToolTipOptionsType);\n    /**\n     * Adds the UI Component to a geometry UIMarker Other graphic elements\n     * @param {Geometry} owner - geometry to add.\n     * @returns {UIComponent} this\n     * @fires UIComponent#add\n     */\n    addTo(owner: Geometry): this;\n    /**\n     * set ToolTip's content's css class name.\n     * @param {String} css class name - set for ToolTip's content.\n     */\n    setStyle(cssName: string): this;\n    /**\n     * get ToolTip's  content's css class name\n     * @returns {String} css class name - set for ToolTip's content.\n     */\n    getStyle(): string;\n    /**\n     * get the UI Component's content\n     * @returns {String} tooltip's content\n     */\n    getContent(): string;\n    buildOn(): HTMLElement;\n    onMouseOut(): void;\n    onMouseMove(e: any): void;\n    /**\n     * remove the tooltip, this method will be called by 'this.remove()'\n     */\n    onRemove(): void;\n    hideDom(): void;\n    onEvent(): this;\n    /**\n     * override UIComponent method\n     * ignore altitude calculation\n     */\n    _getViewPoint(): import(\"src\").Point;\n}\nexport default ToolTip;\nexport type ToolTipOptionsType = {\n    width?: number;\n    height?: number;\n    animation?: string;\n    containerClass?: string;\n    cssName?: string;\n    showTimeout?: number;\n} & UIComponentOptionsType;\n"},{"path":"types/ui/UIComponent.d.ts","content":"/// <reference types=\"node\" />\nimport Class from '../core/Class';\nimport Size from '../geo/Size';\nimport Geometry from '../geometry/Geometry';\nimport Coordinate from '../geo/Coordinate';\nimport type { Map } from './../map/Map';\nimport { Point } from '../geo';\ndeclare const UIComponent_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any; /**\n         * Adds the UI Component to a geometry or a map\n         * @param {Geometry|Map} owner - geometry or map to addto.\n         * @returns {ui.UIComponent} this\n         * @fires ui.UIComponent#add\n         */\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any; /**\n         * Decide whether the ui component is open\n         * @returns {Boolean} true|false\n         */\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Class;\n/**\n * @classdesc\n * Base class for all the UI component classes, a UI component is a HTMLElement positioned with geographic coordinate. <br>\n * It is abstract and not intended to be instantiated.\n *\n * @category ui\n * @abstract\n * @mixes Eventable\n * @memberOf ui\n * @extends Class\n */\ndeclare class UIComponent extends UIComponent_base {\n    options: UIComponentOptionsType;\n    _owner: Map | Geometry;\n    _coordinate: Coordinate;\n    _showBySymbolChange: boolean;\n    _mapEventsOn: boolean;\n    __uiDOM: HTMLElement;\n    _pos: Point;\n    _autoPanId: NodeJS.Timeout;\n    _domContentRect: {\n        width: number;\n        height: number;\n    };\n    _size: Size;\n    _resizeObserver: ResizeObserver;\n    /**\n     *  Some instance methods subclasses needs to implement:  <br>\n     *  <br>\n     * 1. Optional, returns the Dom element's position offset  <br>\n     * function getOffset : Point  <br>\n     *  <br>\n     * 2. Method to create UI's Dom element  <br>\n     * function buildOn : HTMLElement  <br>\n     *  <br>\n     * 3 Optional, to provide an event map to register event listeners.  <br>\n     * function getEvents : void  <br>\n     * 4 Optional, a callback when dom is removed.  <br>\n     * function onDomRemove : void  <br>\n     * 5 Optional, a callback when UI Component is removed.  <br>\n     * function onRemove : void  <br>\n     * @param  {Object} options configuration options\n     */\n    constructor(options: UIComponentOptionsType);\n    onAdd(): void;\n    onRemove(): void;\n    onDomRemove(): void;\n    getEvents(): {\n        [key: string]: () => void;\n    };\n    getOwnerEvents(): {\n        [key: string]: () => void;\n    };\n    buildOn(): HTMLElement;\n    /**\n     * Adds the UI Component to a geometry or a map\n     * @param {Geometry|Map} owner - geometry or map to addto.\n     * @returns {ui.UIComponent} this\n     * @fires ui.UIComponent#add\n     */\n    addTo(owner: Geometry | Map): this;\n    /**\n     * Get the map it added to\n     * @return {Map} map instance\n     * @override\n     */\n    getMap(): Map;\n    _collides(): this;\n    _collidesEffect(show: boolean): this;\n    /**\n     * Show the UI Component, if it is a global single one, it will close previous one.\n     * @param {Coordinate} [coordinate=null] - coordinate to show, default is owner's center\n     * @return {ui.UIComponent} this\n     * @fires ui.UIComponent#showstart\n     * @fires ui.UIComponent#showend\n     */\n    show(coordinate: Coordinate): this;\n    /**\n     * Hide the UI Component.\n     * @return {ui.UIComponent} this\n     * @fires ui.UIComponent#hide\n     */\n    hide(): this;\n    /**\n     * Decide whether the ui component is open\n     * @returns {Boolean} true|false\n     */\n    isVisible(): boolean;\n    /**\n     * Remove the UI Component\n     * @return {ui.UIComponent} this\n     * @fires ui.UIComponent#hide\n     * @fires ui.UIComponent#remove\n     */\n    remove(): this;\n    /**\n     * Get pixel size of the UI Component.\n     * @return {Size} size\n     */\n    getSize(): Size;\n    getOwner(): Map | Geometry;\n    /**\n     * get Dom Node\n     * @returns {HTMLDivElement} dom|null\n     */\n    getDOM(): HTMLElement;\n    /**\n     * set Dom Node zIndex\n     *\n     */\n    setZIndex(zIndex: number): this;\n    _roundPoint(point: Point): Point;\n    getPosition(): Point;\n    _getAnimation(): {\n        fade: boolean;\n        scale: boolean;\n        ok: boolean;\n        transition: string;\n    };\n    _getViewPoint(): Point;\n    _meterToPoint(center: Coordinate, altitude: number): number;\n    _autoPan(): void;\n    /**\n     * Measure dom's size\n     * @param  {HTMLElement} dom - element to measure\n     * @return {Size} size\n     * @private\n     */\n    _measureSize(dom: HTMLElement): Size;\n    /**\n     * Remove previous UI DOM if it has.\n     *\n     * @private\n     */\n    _removePrevDOM(): void;\n    /**\n     * generate the cache key to store the singletong UI DOM\n     * @private\n     * @return {String} cache key\n     */\n    _uiDomKey(): string;\n    _singleton(): boolean;\n    _getUIContainer(): import(\"./../map/Map\").PanelDom;\n    _getClassName(): string;\n    _switchMapEvents(to: string): void;\n    _switchEvents(to: string): void;\n    _getDefaultEvents(): {\n        'zooming rotate pitch': () => void;\n        zoomend: () => void;\n        moving: () => void;\n        moveend: () => void;\n        resize: () => void;\n    };\n    _getOwnerEvents(): {\n        [key: string]: (...args: any[]) => void;\n    };\n    onGeometryPositionChange(param: any): void;\n    onMoving(): void;\n    onEvent(): void;\n    onZoomEnd(): void;\n    onResize(): void;\n    onDomSizeChange(): void;\n    _updatePosition(): this;\n    _setPosition(): void;\n    _toCSSTranslate(p: Point): string;\n    _observerDomSize(dom: HTMLElement): this;\n    isSupportZoomFilter(): boolean;\n    onConfig(): this;\n    static isSupport(owner: Geometry | Map): boolean;\n    _bindDomEvents(dom: HTMLElement, to: string): void;\n    _getDomEvents(): {\n        mouseover: () => void;\n        mouseout: () => void;\n    };\n    _configMapPreventWheelScroll(preventWheelScroll: boolean): void;\n    _onDomMouseover(): void;\n    _onDomMouseout(): void;\n}\nexport default UIComponent;\nexport type UIComponentOptionsType = {\n    eventsPropagation?: boolean;\n    eventsToStop?: string;\n    dx?: number;\n    dy?: number;\n    autoPan?: boolean;\n    autoPanDuration?: number;\n    single?: boolean;\n    animation?: string;\n    animationOnHide?: boolean;\n    animationDuration?: number;\n    pitchWithMap?: boolean;\n    rotateWithMap?: boolean;\n    visible?: boolean;\n    roundPoint?: boolean;\n    collision?: boolean;\n    collisionBufferSize?: number;\n    collisionWeight?: number;\n    collisionFadeIn?: boolean;\n    zIndex?: number;\n};\n"},{"path":"types/ui/UIMarker.d.ts","content":"import Handler from '../handler/Handler';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport UIComponent, { UIComponentOptionsType } from './UIComponent';\nimport type { Map } from '../map';\ndeclare const UIMarker_base: {\n    new (...args: any[]): {\n        _handlers?: Handler[];\n        addHandler(name: any, handlerClass: any): any;\n        removeHandler(name: any): any;\n        _clearHandlers(): void;\n    };\n} & typeof UIComponent;\n/**\n *\n * @classdesc\n * Class for UI Marker, a html based marker positioned by geographic coordinate. <br>\n *\n * @category ui\n * @extends ui.UIComponent\n * @mixes Handlerable\n * @memberOf ui\n * @example\n * var dom = document.createElement('div');\n * dom.innerHTML = 'hello ui marker';\n * var marker = new maptalks.ui.UIMarker([0, 0], {\n *      draggable : true,\n *      content : dom\n *  }).addTo(map);\n */\ndeclare class UIMarker extends UIMarker_base {\n    _markerCoord: Coordinate;\n    options: UIMarkerOptionsType;\n    _owner: Map;\n    _mousedownEvent: MouseEvent;\n    _mouseupEvent: MouseEvent;\n    _touchstartTime: number;\n    /**\n     * As it's renderered by HTMLElement such as a DIV, it: <br>\n     * 1. always on the top of all the map layers <br>\n     * 2. can't be snapped as it's not drawn on the canvas. <br>\n     * @param  {Coordinate} coordinate - UIMarker's coordinates\n     * @param {Object} options - options defined in [UIMarker]{@link UIMarker#options}\n     */\n    constructor(coordinate: Coordinate | Array<number>, options: UIMarkerOptionsType);\n    _getClassName(): string;\n    /**\n     * Sets the coordinates\n     * @param {Coordinate} coordinates - UIMarker's coordinate\n     * @returns {UIMarker} this\n     * @fires UIMarker#positionchange\n     */\n    setCoordinates(coordinates: Coordinate): this;\n    /**\n     * Gets the coordinates\n     * @return {Coordinate} coordinates\n     */\n    getCoordinates(): Coordinate;\n    getCenter(): Coordinate;\n    getAltitude(): number;\n    setAltitude(alt: number): this;\n    /**\n     * Sets the content of the UIMarker\n     * @param {String|HTMLElement} content - UIMarker's content\n     * @returns {UIMarker} this\n     * @fires UIMarker#contentchange\n     */\n    setContent(content: string | HTMLElement): this;\n    /**\n     * Gets the content of the UIMarker\n     * @return {String|HTMLElement} content\n     */\n    getContent(): string | HTMLElement;\n    onAdd(): this;\n    /**\n     * Show the UIMarker\n     * @returns {UIMarker} this\n     * @fires UIMarker#showstart\n     * @fires UIMarker#showend\n     */\n    show(): this;\n    /**\n     * Flash the UIMarker, show and hide by certain internal for times of count.\n     *\n     * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)\n     * @param {Number} [count=4]          - flash times\n     * @param {Function} [cb=null]        - callback function when flash ended\n     * @param {*} [context=null]          - callback context\n     * @return {UIMarker} this\n     */\n    flash(interval: number, count: number, cb?: (arg: any) => void, context?: any): any;\n    /**\n     * A callback method to build UIMarker's HTMLElement\n     * @protected\n     * @param {Map} map - map to be built on\n     * @return {HTMLElement} UIMarker's HTMLElement\n     */\n    buildOn(): HTMLElement;\n    /**\n     * Gets UIMarker's HTMLElement's position offset, it's caculated dynamically accordiing to its actual size.\n     * @protected\n     * @return {Point} offset\n     */\n    getOffset(): Point;\n    /**\n     * Gets UIMarker's transform origin for animation transform\n     * @protected\n     * @return {Point} transform origin\n     */\n    getTransformOrigin(): string;\n    onDomRemove(): void;\n    /**\n     * Whether the uimarker is being dragged.\n     * @returns {Boolean}\n     */\n    isDragging(): boolean;\n    _registerDOMEvents(dom: HTMLElement): void;\n    _onDomEvents(e: MouseEvent): void;\n    _removeDOMEvents(dom: HTMLElement): void;\n    _mouseClickPositionIsChange(): boolean;\n    /**\n     * Get the connect points of panel for connector lines.\n     * @private\n     */\n    _getConnectPoints(): Coordinate[];\n    _getViewPoint(): Point;\n    _getDefaultEvents(): {\n        'zooming rotate pitch': () => void;\n        zoomend: () => void;\n        moving: () => void;\n        moveend: () => void;\n        resize: () => void;\n    } & {\n        'zooming zoomend': () => void;\n    };\n    _setPosition(): void;\n    onZoomFilter(): void;\n    isVisible(): boolean;\n    isSupportZoomFilter(): boolean;\n}\nexport default UIMarker;\nexport type UIMarkerOptionsType = {\n    containerClass?: string;\n    eventsPropagation?: boolean;\n    draggable?: boolean;\n    single?: boolean;\n    content?: string | HTMLElement;\n    altitude?: number;\n    minZoom?: number;\n    maxZoom?: number;\n    horizontalAlignment?: 'middle' | 'left' | 'right';\n    verticalAlignment?: 'middle' | 'top' | 'bottom';\n} & UIComponentOptionsType;\n"},{"path":"ui/index.d.ts","content":"import UIComponent from './UIComponent';\nimport UIMarker from './UIMarker';\nimport InfoWindow from './InfoWindow';\nimport ToolTip from './ToolTip';\nimport Menu from './Menu';\nimport Menuable from './Menuable';\nexport { UIComponent, UIMarker, InfoWindow, ToolTip, Menuable, Menu };\n"},{"path":"ui/InfoWindow.d.ts","content":"import Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport { Geometry, LineString } from '../geometry';\nimport type { Map } from '../map';\nimport { MapEventDataType } from '../map/Map.DomEvents';\nimport UIComponent, { UIComponentOptionsType } from './UIComponent';\n/**\n * @classdesc\n * Class for info window, a popup on the map to display any useful infomation you wanted.\n * @category ui\n * @extends ui.UIComponent\n * @param {Object} options - options defined in [InfoWindow]{@link InfoWindow#options}\n * @memberOf ui\n */\ndeclare class InfoWindow extends UIComponent {\n    options: InfoWindowOptionsType;\n    _onCloseBtnClick: () => void;\n    _getClassName(): string;\n    /**\n     * Adds the UI Component to a geometry or a map\n     * @param {Geometry|Map} owner - geometry or map to addto.\n     * @returns {UIComponent} this\n     * @fires UIComponent#add\n     */\n    addTo(owner: Geometry | Map): this;\n    /**\n     * Set the content of the infowindow.\n     * @param {String|HTMLElement} content - content of the infowindow.\n     * return {InfoWindow} this\n     * @fires InfoWindow#contentchange\n     */\n    setContent(content: string | HTMLElement): this;\n    /**\n     * Get content of  the infowindow.\n     * @return {String|HTMLElement} - content of the infowindow\n     */\n    getContent(): string | HTMLElement;\n    /**\n     * Set the title of the infowindow.\n     * @param {String|HTMLElement} title - title of the infowindow.\n     * return {InfoWindow} this\n     * @fires InfoWindow#titlechange\n     */\n    setTitle(title: string): this;\n    /**\n     * Get title of  the infowindow.\n     * @return {String|HTMLElement} - content of the infowindow\n     */\n    getTitle(): string;\n    buildOn(): HTMLElement;\n    _replaceTemplate(dom: Element): this;\n    /**\n     * Gets InfoWindow's transform origin for animation transform\n     * @protected\n     * @return {Point} transform origin\n     */\n    getTransformOrigin(): string;\n    getOffset(): Point;\n    show(coordinate: Coordinate): this;\n    getEvents(): {};\n    getOwnerEvents(): {};\n    onRemove(): void;\n    onDomRemove(): void;\n    _onAutoOpen(e: MapEventDataType): void;\n    _rectifyMouseCoordinte(owner: Geometry | Map, mouseCoordinate: Coordinate): Coordinate;\n    _rectifyLineStringMouseCoordinate(lineString: LineString, mouseCoordinate: Coordinate): {\n        dis: number;\n        coordinate: Coordinate;\n    };\n    _getWindowWidth(): string;\n}\nexport default InfoWindow;\nexport type InfoWindowOptionsType = {\n    containerClass?: string;\n    autoPan?: boolean;\n    autoCloseOn?: string;\n    autoOpenOn?: string;\n    width?: string;\n    minHeight?: number;\n    custom?: boolean;\n    title?: string;\n    content?: string | HTMLElement;\n    enableTemplate?: boolean;\n} & UIComponentOptionsType;\n"},{"path":"ui/Menu.d.ts","content":"import Point from '../geo/Point';\nimport type { Geometry } from '../geometry';\nimport type { Map } from '../map';\nimport UIComponent, { UIComponentOptionsType } from './UIComponent';\n/**\n * @classdesc\n * Class for context menu, useful for interactions with right clicks on the map.\n * @category ui\n * @extends ui.UIComponent\n * @memberOf ui\n */\ndeclare class Menu extends UIComponent {\n    options: MenuOptionsType;\n    /**\n     * Menu items is set to options.items or by setItems method. <br>\n     * <br>\n     * Normally items is a object array, containing: <br>\n     * 1. item object: {'item': 'This is a menu text', 'click': function() {alert('oops! You clicked!');)}} <br>\n     * 2. minus string \"-\", which will draw a splitor line on the menu. <br>\n     * <br>\n     * If options.custom is set to true, the menu is considered as a customized one. Then items is the customized html codes or HTMLElement. <br>\n     * @param {Object} options - options defined in [ui.Menu]{@link ui.Menu#options}\n     */\n    constructor(options: MenuOptionsType);\n    _getClassName(): string;\n    addTo(owner: Geometry | Map): any;\n    /**\n     * Set the items of the menu.\n     * @param {Object[]|String|HTMLElement} items - items of the menu\n     * return {ui.Menu} this\n     * @example\n     * menu.setItems([\n     *      //return false to prevent event propagation\n     *     {'item': 'Query', 'click': function() {alert('Query Clicked!'); return false;}},\n     *     '-',\n     *     {'item': 'Edit', 'click': function() {alert('Edit Clicked!')}},\n     *     {'item': 'About', 'click': function() {alert('About Clicked!')}}\n     * ]);\n     */\n    setItems(items: Array<MenuItem>): this;\n    /**\n     * Get items of  the menu.\n     * @return {Object[]|String|HTMLElement} - items of the menu\n     */\n    getItems(): MenuItem[];\n    /**\n     * Create the menu DOM.\n     * @protected\n     * @return {HTMLElement} menu's DOM\n     */\n    buildOn(): HTMLElement;\n    /**\n     * Offset of the menu DOM to fit the click position.\n     * @return {Point} offset\n     * @private\n     */\n    getOffset(): Point;\n    getTransformOrigin(): string;\n    getEvents(): {\n        '_zoomstart _zoomend _movestart _dblclick _click': () => void;\n    };\n    _createMenuItemDom(): HTMLElement;\n    _getMenuWidth(): number;\n}\nexport default Menu;\nexport type MenuItem = {\n    name?: string;\n    click?: () => void;\n};\nexport type MenuOptionsType = {\n    containerClass?: string;\n    animationDelay?: number;\n    animationOnHide?: boolean;\n    autoPan?: boolean;\n    width?: number;\n    maxHeight?: number;\n    custom?: boolean;\n    items?: Array<MenuItem>;\n} & UIComponentOptionsType;\n"},{"path":"ui/Menuable.d.ts","content":"import Menu, { MenuItem, MenuOptionsType } from './Menu';\nimport { Coordinate } from '../geo';\ninterface MenuAbles {\n    _menuOptions: MenuOptionsType;\n    _menu: Menu;\n    setMenu(options: MenuOptionsType): this;\n    getMenu(): Menu;\n    openMenu(coordinate?: Coordinate): this;\n    setMenuItems(items: Array<MenuItem>): this;\n    getMenuItems(): Array<MenuItem>;\n    closeMenu(): this;\n    removeMenu(): this;\n    _bindMenu(): this;\n    _unbindMenu(): this;\n    _defaultOpenMenu(param: any): boolean;\n}\ndeclare module \"../geometry/Geometry\" {\n    interface Geometry extends MenuAbles {\n    }\n}\ndeclare module \"../map/Map\" {\n    interface Map extends MenuAbles {\n    }\n}\n/**\n * Mixin of the context menu methods.\n * @mixin ui.Menuable\n */\ndeclare const Menuable: {\n    /**\n     * Set a context menu\n     * @param {Object} options - menu options\n     * @return {*} this\n     * @example\n     * foo.setMenu({\n     *  'width'  : 160,\n     *  'custom' : false,\n     *  'items' : [\n     *      //return false to prevent event propagation\n     *     {'item': 'Query', 'click': function() {alert('Query Clicked!'); return false;}},\n     *     '-',\n     *     {'item': 'Edit', 'click': function() {alert('Edit Clicked!')}},\n     *     {'item': 'About', 'click': function() {alert('About Clicked!')}}\n     *    ]\n     * });\n     * @function ui.Menuable.setMenu\n     */\n    setMenu(options: MenuOptionsType): any;\n    /**\n    * get a context menu\n    * @return {*} ui.Menu\n    * @function ui.Menuable.getMenu\n    */\n    getMenu(): Menu;\n    /**\n     * Open the context menu, default on the center of the geometry or map.\n     * @param {Coordinate} [coordinate=null] - coordinate to open the context menu\n     * @return {*} this\n     * @function ui.Menuable.openMenu\n     */\n    openMenu(coordinate?: Coordinate): any;\n    /**\n     * Set menu items to the context menu\n     * @param {Object[]} items - menu items\n     * @return {*} this\n     * @function ui.Menuable.setMenuItems\n     */\n    setMenuItems(items: Array<MenuItem>): any;\n    /**\n     * Get the context menu items\n     * @return {Object[]}\n     * @function ui.Menuable.getMenuItems\n     */\n    getMenuItems(): Array<MenuItem>;\n    /**\n     * Close the contexnt menu\n     * @return {*} this\n     * @function ui.Menuable.closeMenu\n     */\n    closeMenu(): any;\n    /**\n     * Remove the context menu\n     * @return {*} this\n     * @function ui.Menuable.removeMenu\n     */\n    removeMenu(): any;\n    _bindMenu(): any;\n    _unbindMenu(): any;\n    /**\n     * If contextmenu is not listened, open the menu in default.<br>\n     * Otherwise, do nothing here.\n     * @param  {Object} param - event parameter\n     * @return {Boolean} true | false to stop event propagation\n     * @private\n     */\n    _defaultOpenMenu(param: any): boolean;\n};\nexport default Menuable;\n"},{"path":"ui/ToolTip.d.ts","content":"/// <reference types=\"node\" />\nimport type { Geometry } from '../geometry';\nimport UIComponent, { UIComponentOptionsType } from './UIComponent';\n/**\n * @classdesc\n * Class for tooltip, a tooltip used for showing some useful infomation attached to geometries on the map.\n * @category ui\n * @extends ui.UIComponent\n * @memberOf ui\n */\ndeclare class ToolTip extends UIComponent {\n    options: ToolTipOptionsType;\n    _content: string;\n    _timeout: NodeJS.Timeout;\n    _owner: Geometry;\n    _getClassName(): string;\n    /**\n     * @param {String} content         - content of tooltip\n     * @param {Object} [options=null]  - options defined in [ToolTip]{@link ToolTip#options}\n     */\n    constructor(content: string, options?: ToolTipOptionsType);\n    /**\n     * Adds the UI Component to a geometry UIMarker Other graphic elements\n     * @param {Geometry} owner - geometry to add.\n     * @returns {UIComponent} this\n     * @fires UIComponent#add\n     */\n    addTo(owner: Geometry): this;\n    /**\n     * set ToolTip's content's css class name.\n     * @param {String} css class name - set for ToolTip's content.\n     */\n    setStyle(cssName: string): this;\n    /**\n     * get ToolTip's  content's css class name\n     * @returns {String} css class name - set for ToolTip's content.\n     */\n    getStyle(): string;\n    /**\n     * get the UI Component's content\n     * @returns {String} tooltip's content\n     */\n    getContent(): string;\n    buildOn(): HTMLElement;\n    onMouseOut(): void;\n    onMouseMove(e: any): void;\n    /**\n     * remove the tooltip, this method will be called by 'this.remove()'\n     */\n    onRemove(): void;\n    hideDom(): void;\n    onEvent(): this;\n    /**\n     * override UIComponent method\n     * ignore altitude calculation\n     */\n    _getViewPoint(): import(\"src\").Point;\n}\nexport default ToolTip;\nexport type ToolTipOptionsType = {\n    width?: number;\n    height?: number;\n    animation?: string;\n    containerClass?: string;\n    cssName?: string;\n    showTimeout?: number;\n} & UIComponentOptionsType;\n"},{"path":"ui/UIComponent.d.ts","content":"/// <reference types=\"node\" />\nimport Class from '../core/Class';\nimport Size from '../geo/Size';\nimport Geometry from '../geometry/Geometry';\nimport Coordinate from '../geo/Coordinate';\nimport type { Map } from './../map/Map';\nimport { Point } from '../geo';\ndeclare const UIComponent_base: {\n    new (...args: any[]): {\n        _eventMap?: Record<string, {\n            handler: import(\"../core/Eventable\").HandlerFn;\n            context: any;\n        }[]>;\n        _eventParent?: any;\n        _eventTarget?: any;\n        on(eventsOn: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        addEventListener(...args: any[]): any; /**\n         * Adds the UI Component to a geometry or a map\n         * @param {Geometry|Map} owner - geometry or map to addto.\n         * @returns {ui.UIComponent} this\n         * @fires ui.UIComponent#add\n         */\n        once(eventTypes: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        off(eventsOff: string | import(\"../core/Eventable\").EventRecords, handler: import(\"../core/Eventable\").HandlerFn, context?: any): any;\n        removeEventListener(...args: any[]): any;\n        listens(eventType: string, handler?: import(\"../core/Eventable\").HandlerFn, context?: any): number;\n        getListeningEvents(): string[];\n        copyEventListeners(target: any): any;\n        fire(eventType: string, param?: import(\"../core/Eventable\").BaseEventParamsType): any;\n        _wrapOnceHandler(evtType: string, handler: import(\"../core/Eventable\").HandlerFn, context?: any): (...args: any[]) => void;\n        _switch(to: string, eventRecords: import(\"../core/Eventable\").EventRecords, context?: any): any; /**\n         * Decide whether the ui component is open\n         * @returns {Boolean} true|false\n         */\n        _clearListeners(eventType: string): void;\n        _clearAllListeners(): void;\n        _setEventParent(parent: any): any;\n        _setEventTarget(target: any): any;\n        _fire(eventType: string, param: import(\"../core/Eventable\").BaseEventParamsType): any;\n    };\n} & typeof Class;\n/**\n * @classdesc\n * Base class for all the UI component classes, a UI component is a HTMLElement positioned with geographic coordinate. <br>\n * It is abstract and not intended to be instantiated.\n *\n * @category ui\n * @abstract\n * @mixes Eventable\n * @memberOf ui\n * @extends Class\n */\ndeclare class UIComponent extends UIComponent_base {\n    options: UIComponentOptionsType;\n    _owner: Map | Geometry;\n    _coordinate: Coordinate;\n    _showBySymbolChange: boolean;\n    _mapEventsOn: boolean;\n    __uiDOM: HTMLElement;\n    _pos: Point;\n    _autoPanId: NodeJS.Timeout;\n    _domContentRect: {\n        width: number;\n        height: number;\n    };\n    _size: Size;\n    _resizeObserver: ResizeObserver;\n    /**\n     *  Some instance methods subclasses needs to implement:  <br>\n     *  <br>\n     * 1. Optional, returns the Dom element's position offset  <br>\n     * function getOffset : Point  <br>\n     *  <br>\n     * 2. Method to create UI's Dom element  <br>\n     * function buildOn : HTMLElement  <br>\n     *  <br>\n     * 3 Optional, to provide an event map to register event listeners.  <br>\n     * function getEvents : void  <br>\n     * 4 Optional, a callback when dom is removed.  <br>\n     * function onDomRemove : void  <br>\n     * 5 Optional, a callback when UI Component is removed.  <br>\n     * function onRemove : void  <br>\n     * @param  {Object} options configuration options\n     */\n    constructor(options: UIComponentOptionsType);\n    onAdd(): void;\n    onRemove(): void;\n    onDomRemove(): void;\n    getEvents(): {\n        [key: string]: () => void;\n    };\n    getOwnerEvents(): {\n        [key: string]: () => void;\n    };\n    buildOn(): HTMLElement;\n    /**\n     * Adds the UI Component to a geometry or a map\n     * @param {Geometry|Map} owner - geometry or map to addto.\n     * @returns {ui.UIComponent} this\n     * @fires ui.UIComponent#add\n     */\n    addTo(owner: Geometry | Map): this;\n    /**\n     * Get the map it added to\n     * @return {Map} map instance\n     * @override\n     */\n    getMap(): Map;\n    _collides(): this;\n    _collidesEffect(show: boolean): this;\n    /**\n     * Show the UI Component, if it is a global single one, it will close previous one.\n     * @param {Coordinate} [coordinate=null] - coordinate to show, default is owner's center\n     * @return {ui.UIComponent} this\n     * @fires ui.UIComponent#showstart\n     * @fires ui.UIComponent#showend\n     */\n    show(coordinate: Coordinate): this;\n    /**\n     * Hide the UI Component.\n     * @return {ui.UIComponent} this\n     * @fires ui.UIComponent#hide\n     */\n    hide(): this;\n    /**\n     * Decide whether the ui component is open\n     * @returns {Boolean} true|false\n     */\n    isVisible(): boolean;\n    /**\n     * Remove the UI Component\n     * @return {ui.UIComponent} this\n     * @fires ui.UIComponent#hide\n     * @fires ui.UIComponent#remove\n     */\n    remove(): this;\n    /**\n     * Get pixel size of the UI Component.\n     * @return {Size} size\n     */\n    getSize(): Size;\n    getOwner(): Map | Geometry;\n    /**\n     * get Dom Node\n     * @returns {HTMLDivElement} dom|null\n     */\n    getDOM(): HTMLElement;\n    /**\n     * set Dom Node zIndex\n     *\n     */\n    setZIndex(zIndex: number): this;\n    _roundPoint(point: Point): Point;\n    getPosition(): Point;\n    _getAnimation(): {\n        fade: boolean;\n        scale: boolean;\n        ok: boolean;\n        transition: string;\n    };\n    _getViewPoint(): Point;\n    _meterToPoint(center: Coordinate, altitude: number): number;\n    _autoPan(): void;\n    /**\n     * Measure dom's size\n     * @param  {HTMLElement} dom - element to measure\n     * @return {Size} size\n     * @private\n     */\n    _measureSize(dom: HTMLElement): Size;\n    /**\n     * Remove previous UI DOM if it has.\n     *\n     * @private\n     */\n    _removePrevDOM(): void;\n    /**\n     * generate the cache key to store the singletong UI DOM\n     * @private\n     * @return {String} cache key\n     */\n    _uiDomKey(): string;\n    _singleton(): boolean;\n    _getUIContainer(): import(\"./../map/Map\").PanelDom;\n    _getClassName(): string;\n    _switchMapEvents(to: string): void;\n    _switchEvents(to: string): void;\n    _getDefaultEvents(): {\n        'zooming rotate pitch': () => void;\n        zoomend: () => void;\n        moving: () => void;\n        moveend: () => void;\n        resize: () => void;\n    };\n    _getOwnerEvents(): {\n        [key: string]: (...args: any[]) => void;\n    };\n    onGeometryPositionChange(param: any): void;\n    onMoving(): void;\n    onEvent(): void;\n    onZoomEnd(): void;\n    onResize(): void;\n    onDomSizeChange(): void;\n    _updatePosition(): this;\n    _setPosition(): void;\n    _toCSSTranslate(p: Point): string;\n    _observerDomSize(dom: HTMLElement): this;\n    isSupportZoomFilter(): boolean;\n    onConfig(): this;\n    static isSupport(owner: Geometry | Map): boolean;\n    _bindDomEvents(dom: HTMLElement, to: string): void;\n    _getDomEvents(): {\n        mouseover: () => void;\n        mouseout: () => void;\n    };\n    _configMapPreventWheelScroll(preventWheelScroll: boolean): void;\n    _onDomMouseover(): void;\n    _onDomMouseout(): void;\n}\nexport default UIComponent;\nexport type UIComponentOptionsType = {\n    eventsPropagation?: boolean;\n    eventsToStop?: string;\n    dx?: number;\n    dy?: number;\n    autoPan?: boolean;\n    autoPanDuration?: number;\n    single?: boolean;\n    animation?: string;\n    animationOnHide?: boolean;\n    animationDuration?: number;\n    pitchWithMap?: boolean;\n    rotateWithMap?: boolean;\n    visible?: boolean;\n    roundPoint?: boolean;\n    collision?: boolean;\n    collisionBufferSize?: number;\n    collisionWeight?: number;\n    collisionFadeIn?: boolean;\n    zIndex?: number;\n};\n"},{"path":"ui/UIMarker.d.ts","content":"import Handler from '../handler/Handler';\nimport Coordinate from '../geo/Coordinate';\nimport Point from '../geo/Point';\nimport UIComponent, { UIComponentOptionsType } from './UIComponent';\nimport type { Map } from '../map';\ndeclare const UIMarker_base: {\n    new (...args: any[]): {\n        _handlers?: Handler[];\n        addHandler(name: any, handlerClass: any): any;\n        removeHandler(name: any): any;\n        _clearHandlers(): void;\n    };\n} & typeof UIComponent;\n/**\n *\n * @classdesc\n * Class for UI Marker, a html based marker positioned by geographic coordinate. <br>\n *\n * @category ui\n * @extends ui.UIComponent\n * @mixes Handlerable\n * @memberOf ui\n * @example\n * var dom = document.createElement('div');\n * dom.innerHTML = 'hello ui marker';\n * var marker = new maptalks.ui.UIMarker([0, 0], {\n *      draggable : true,\n *      content : dom\n *  }).addTo(map);\n */\ndeclare class UIMarker extends UIMarker_base {\n    _markerCoord: Coordinate;\n    options: UIMarkerOptionsType;\n    _owner: Map;\n    _mousedownEvent: MouseEvent;\n    _mouseupEvent: MouseEvent;\n    _touchstartTime: number;\n    /**\n     * As it's renderered by HTMLElement such as a DIV, it: <br>\n     * 1. always on the top of all the map layers <br>\n     * 2. can't be snapped as it's not drawn on the canvas. <br>\n     * @param  {Coordinate} coordinate - UIMarker's coordinates\n     * @param {Object} options - options defined in [UIMarker]{@link UIMarker#options}\n     */\n    constructor(coordinate: Coordinate | Array<number>, options: UIMarkerOptionsType);\n    _getClassName(): string;\n    /**\n     * Sets the coordinates\n     * @param {Coordinate} coordinates - UIMarker's coordinate\n     * @returns {UIMarker} this\n     * @fires UIMarker#positionchange\n     */\n    setCoordinates(coordinates: Coordinate): this;\n    /**\n     * Gets the coordinates\n     * @return {Coordinate} coordinates\n     */\n    getCoordinates(): Coordinate;\n    getCenter(): Coordinate;\n    getAltitude(): number;\n    setAltitude(alt: number): this;\n    /**\n     * Sets the content of the UIMarker\n     * @param {String|HTMLElement} content - UIMarker's content\n     * @returns {UIMarker} this\n     * @fires UIMarker#contentchange\n     */\n    setContent(content: string | HTMLElement): this;\n    /**\n     * Gets the content of the UIMarker\n     * @return {String|HTMLElement} content\n     */\n    getContent(): string | HTMLElement;\n    onAdd(): this;\n    /**\n     * Show the UIMarker\n     * @returns {UIMarker} this\n     * @fires UIMarker#showstart\n     * @fires UIMarker#showend\n     */\n    show(): this;\n    /**\n     * Flash the UIMarker, show and hide by certain internal for times of count.\n     *\n     * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)\n     * @param {Number} [count=4]          - flash times\n     * @param {Function} [cb=null]        - callback function when flash ended\n     * @param {*} [context=null]          - callback context\n     * @return {UIMarker} this\n     */\n    flash(interval: number, count: number, cb?: (arg: any) => void, context?: any): any;\n    /**\n     * A callback method to build UIMarker's HTMLElement\n     * @protected\n     * @param {Map} map - map to be built on\n     * @return {HTMLElement} UIMarker's HTMLElement\n     */\n    buildOn(): HTMLElement;\n    /**\n     * Gets UIMarker's HTMLElement's position offset, it's caculated dynamically accordiing to its actual size.\n     * @protected\n     * @return {Point} offset\n     */\n    getOffset(): Point;\n    /**\n     * Gets UIMarker's transform origin for animation transform\n     * @protected\n     * @return {Point} transform origin\n     */\n    getTransformOrigin(): string;\n    onDomRemove(): void;\n    /**\n     * Whether the uimarker is being dragged.\n     * @returns {Boolean}\n     */\n    isDragging(): boolean;\n    _registerDOMEvents(dom: HTMLElement): void;\n    _onDomEvents(e: MouseEvent): void;\n    _removeDOMEvents(dom: HTMLElement): void;\n    _mouseClickPositionIsChange(): boolean;\n    /**\n     * Get the connect points of panel for connector lines.\n     * @private\n     */\n    _getConnectPoints(): Coordinate[];\n    _getViewPoint(): Point;\n    _getDefaultEvents(): {\n        'zooming rotate pitch': () => void;\n        zoomend: () => void;\n        moving: () => void;\n        moveend: () => void;\n        resize: () => void;\n    } & {\n        'zooming zoomend': () => void;\n    };\n    _setPosition(): void;\n    onZoomFilter(): void;\n    isVisible(): boolean;\n    isSupportZoomFilter(): boolean;\n}\nexport default UIMarker;\nexport type UIMarkerOptionsType = {\n    containerClass?: string;\n    eventsPropagation?: boolean;\n    draggable?: boolean;\n    single?: boolean;\n    content?: string | HTMLElement;\n    altitude?: number;\n    minZoom?: number;\n    maxZoom?: number;\n    horizontalAlignment?: 'middle' | 'left' | 'right';\n    verticalAlignment?: 'middle' | 'top' | 'bottom';\n} & UIComponentOptionsType;\n"}]